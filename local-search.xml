<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot-Configuration</title>
    <link href="/2023/04/17/SpringBoot-Configuration/"/>
    <url>/2023/04/17/SpringBoot-Configuration/</url>
    
    <content type="html"><![CDATA[<p>前面提到，对于<code>Spring</code>项目来说，项目的功能取决于<code>Spring容器</code>中有哪些<code>bean</code>，每一个<code>bean</code>都是一个功能模块的实例化对象。所以问题就来到了如何向<code>Spring容器</code>中添加<code>bean</code>。</p><h2 id="XML-配置文件"><a href="#XML-配置文件" class="headerlink" title="XML 配置文件"></a>XML 配置文件</h2><p><code>XML配置文件</code>是最原始的添加<code>bean</code>的方式。使用<code>XML配置文件</code>符合了<code>配置文件分离</code>的原则。可以通过修改<code>XML配置文件</code>直接修改程序的功能，而不需要将项目重新编译。</p><p>在<code>XML配置文件</code>中通过<code>&lt;bean&gt;</code>标签来声明一个<code>bean</code>，并指定其类名、属性、依赖关系等信息，将该<code>bean</code>注册到<code>Spring</code>容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;anotherBean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此处定义了一个<code>bean</code>，为<code>com.example.MyBean</code>类的实例对象，其标识符通过<code>id</code>属性指定。通过<code>&lt;property&gt;</code>标签，可以对其成员变量进行属性注入。对于基础数据类型，可以直接使用<code>value</code>属性进行赋值；对于对象数据类型，可以使用<code>ref</code>属性进行引用，属性值为另一个容器中<code>bean</code>的<code>id</code>。也可以通过设置<code>bean</code>的<code>autowire</code>属性来指定是否采用自动注入。例如可以指定<code>autowire=&quot;byType&quot;</code>来采用类型匹配自动注入。如果容器中符合成员变量类型的<code>bean</code>只有一个，那么就可以自动赋值。</p><p>启动时，通过指定<code>XML配置文件</code>，即可启动<code>Spring容器</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;configuration.xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>在定义<code>bean</code>时，还有许多可配置属性。但作为便于理解的笔记，这部分内容此处不再深入，可以在需要的时候去查相关文档。</p><ul><li><code>id</code>：指定 bean 的唯一标识符，用于在容器中进行引用。</li><li><code>class</code>：指定 bean 的类名，用于实例化 bean 对象。</li><li><code>scope</code>：指定 bean 的作用域，包括 singleton（单例，默认值）、prototype（原型）、request（请求）、session（会话）等。</li><li><code>init-method</code>：指定 bean 初始化时调用的方法。</li><li><code>destroy-method</code>：指定 bean 销毁时调用的方法。</li><li><code>property</code>：用于设置 bean 的属性值。</li></ul><p>其中可以指定<code>bean</code>的初始化<code>init-method</code>和销毁方法<code>destroy-method</code>，这也是上篇提到的管理<code>bean</code>生命周期的功能。</p><h2 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h2><p>如果需要往容器中添加一百个<code>bean</code>，那么需要在<code>XML配置文件</code>中写一百个<code>&lt;bean&gt;</code>标签，过程十分繁琐。实际项目中，需要添加到容器中的<code>bean</code>往往是自己写的<code>Java类</code>，这些<code>Java类</code>在<code>类路径</code>上通常有特点，例如处于某个包之下。指定某个<code>类路径/包</code>下的所有<code>Java类</code>都加入到<code>Spring容器中</code>这个想法就十分自然。这种批量添加<code>bean</code>的方式叫组件扫描。</p><p><code>XML配置文件</code>中开启组件扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用注解<code>@ComponentScan</code>开启组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages=&quot;com.example&quot;)</span><br></code></pre></td></tr></table></figure><p>组件扫描需要搭配<code>@Component</code>使用，这是一个类注解。只有扫描路径下带有<code>@Component</code>注解的类才会被添加到容器，没有的类则会被忽略。组件扫描<code>@ComponentScan</code>和<code>@Component</code>组合使用可以灵活地控制路径下哪些类会被添加入容器。</p><p>除了<code>@Component</code>，还可以通过设置<code>@ComponentScan</code>的<code>includeFilters</code>和<code>excludeFilters</code>属性，来灵活地自定义扫描路径下的过滤规则。</p><h2 id="配置类-Configuration"><a href="#配置类-Configuration" class="headerlink" title="配置类@Configuration"></a>配置类@Configuration</h2><p><code>Java</code>的注解特性太过便捷，<code>Spring</code>项目逐渐从传统<code>XML配置文件</code>方式向注解方式迁移，这种大量依赖注解来配置和管理<code>Spring容器</code>中的<code>Bean</code>的方式叫<code>注解驱动</code>。</p><p>在<code>注解驱动</code>下，一个<code>XML配置文件</code>对应于一个带有<code>@Configuration</code>注解的<code>Java类</code>。<code>XML配置文件</code>中所有的标签，都有对应的定义方式。其中最重要的<code>&lt;bean&gt;</code>标签，在配置类中对应一个方法。这个方法会被添加<code>@bean</code>注解，并且要求返回一个<code>对象实例</code>或对象的<code>工厂bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回Bean的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要一提的是，配置类本身也是一个<code>bean</code>，存在于容器中。</p><p>基于单一职责原则，一般一个配置类往往只负责一类高度相关的功能。要开启某个功能往往就是把这个功能对应的配置类加入到容器中。配置类就会自动把功能相关的bean注册到容器中。</p><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p>实际项目开发中，可能会同时运用<code>XML配置文件</code>和<code>@Configuration配置类</code>。<code>配置类</code>作为主流的导入<code>bean</code>方式，那么就需要提供在其中引入<code>XML配置文件</code>的方法。<code>@ImportResource</code>就是这个作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(&quot;classpath:appCtx-dubbo.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在公司项目中，提供的对外Dubbo服务没有采用<code>配置类</code>的方式，而是将其写在了<code>XML配置文件</code>。通过在<code>XML文件</code>引入<code>xmlns:dubbo</code>，在文件内部可以使用dubbo提供的特定标签<code>&lt;dubbo:service&gt;</code>来注册服务。然后通过<code>@ImportResource(&quot;classpath:appCtx-dubbo.xml&quot;)</code>将生产者和消费者对应的<code>bean</code>加入到容器中。</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>在Java配置类上使用<code>@Import</code>注解，将其他Java配置类引入当前配置类中，从而将这些配置类中定义的<code>Bean</code>一同注册到<code>Spring容器</code>中。<code>@Import</code>也能导入非配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;AnotherConfig.class, YetAnotherConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-comment">// 引入其他配置类中的Bean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相较于<code>@bean</code>的方式，<code>@Import</code>要简单很多。由于<code>@bean</code>注解在方法之上，可以通过编程式对每个<code>bean</code>进行细粒度的配置，而<code>@Import</code>就没法进行细粒度的控制。</p><p><code>@Import</code>通常也用于注解之上，使其变得更容易理解。例如<code>@Import(AspectJAutoProxyRegistrar.class)</code>就是<code>@EnableAspectJAutoProxy</code>上的注解。开启自动代理功能，本质就是导入了<code>AspectJAutoProxyRegistrar.class</code>注册器。注册器中，通过重载了<code>registerBeanDefinitions</code>的回调方法，向容器中动态注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>，从而开了<code>AspectJ</code>代理功能。相较于<code>@Import(AspectJAutoProxyRegistrar.class)</code>，<code>@EnableAspectJAutoProxy</code>更具有语义化。实际上，大部分的<code>@Enablexxx</code>本质都是利用了<code>@Import</code>导入了一些特殊的<code>bean</code>。</p><h2 id="实现BeanFactoryPostProcessor接口"><a href="#实现BeanFactoryPostProcessor接口" class="headerlink" title="实现BeanFactoryPostProcessor接口"></a>实现BeanFactoryPostProcessor接口</h2><p>这种方式作为用户不常用。一般作为开发者设计第三方库时的选择。</p><p>通过自定义一个实现了<code>BeanFactoryPostProcessor</code>接口的类，在其<code>postProcessBeanFactory()</code>方法中使用<code>BeanDefinitionRegistry</code>接口手动注册Bean到Spring容器中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 使用BeanDefinitionRegistry接口手动注册Bean</span><br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(MyBean.class);<br>        beanFactory.registerBeanDefinition(<span class="hljs-string">&quot;myBean&quot;</span>, beanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上还有<code>ImportBeanDefinitionRegistrar </code>。由于这部分内容找到的资料不多且良莠不齐，在此不深入讨论。</p><p>总的来说，这类方式是通过实现接口中预先定义的回调函数，在<code>Spring容器</code>启动过程的早期阶段会调用这些函数。在这些函数中，可以获取到<code>Spring容器</code>，并通过<code>Spring容器</code>的注册方法向其中注册自定义<code>bean</code>。</p><p>这部分内容令人感到困惑的原因是，<code>Spring容器</code>本身有多个接口和实现类，其中有许多都提供了注册方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Spring</code>应用的功能取决于其中的<code>bean</code>。向容器中添加&#x2F;注册<code>bean</code>可以通过许多形式。其中最常用的是通过<code>@Configuration</code>的方式自定义配置类。结合<code>SpringBoot</code>的<code>AutoConfiguration</code>，可以很容易将各种应用集成到<code>Spring</code>中。由于<code>AutoConfiguration</code>内容太复杂，限于篇幅放到下一篇。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Testing</title>
    <link href="/2023/04/13/SpringBoot-Testing/"/>
    <url>/2023/04/13/SpringBoot-Testing/</url>
    
    <content type="html"><![CDATA[<p>在写上一篇<code>IoC</code>和<code>DI</code>之前，本来想记录的是<code>SpringBoot</code>如何完成<code>AutoConfiguration</code>自动配置，但因为篇幅直接分离出来了一篇。这次又把<code>Testing</code>给分离了出来。</p><p>事情的起因是，写项目代码时，常常需要对自己写的部分进行测试和调试。根据自己以往的编程经验，个人习惯于写一点就运行一点，并通过断点调试来确认内存的运行状态，避免犯一些低级的逻辑错误。虽然公司有专门的测试岗位，但从代码提交到GitLab请求合并，到部署到测试服务器，到测试人员设计用例并测试，到反馈到开发人员，整个过程涉及多个人员，太过漫长。而一些代码本身就需要反复调试，例如写了一些数据库操作，需要确认数据库实际执行结果是否符合预期。例如一个循环的跳出是否符合预期。执行结果符合预期本身是个很玄乎的事，很多时候代码看起来没啥问题，跑起来却又满脸问号。询问同事，都回答说让测试去测。而我觉得开发人员有义务确保代码没有低级的逻辑错误。</p><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>在<code>SpringBoot</code>框架中，常用的测试框架是<code>JUnit</code>。现在最新版本<code>SpringBoot3.0.5</code>对应的<code>Junit5</code>版本，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing">官方文档</a>。公司内部使用的是<code>Junit4</code>。</p><p>对于<code>JUnit</code>框架内部原理暂时没深入了解。从使用角度，常常会对需要测试的类，新生成一个对应的测试类，命名规范通常为 <code>新测试类命 = 旧类命 + &quot;Test&quot;</code>。例如有一个<code>Calculator</code>类，那会新定义一个<code>CalculatorTest</code>测试类，并在测试类中定义成员测试方法，对应于被测试类中的方法。在每个成员方法中添加注解<code>@Test</code>，通过IDE或者构建工具就可以自动执行测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Addition方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtraction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Subtraction方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还可以编写其他测试方法...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在测试中，可以通过构建测试用例，并使用断言，将方法输出和预期输出进行对比。还可以使用代码覆盖率工具，来分析测试覆盖率。这些是<code>JUnit</code>核心功能，其他功能暂时还未深入了解。</p><h2 id="Testing-in-SpringBoot"><a href="#Testing-in-SpringBoot" class="headerlink" title="Testing in SpringBoot"></a>Testing in SpringBoot</h2><p>在<code>SpringBoot</code>中，一个应用有什么功能，取决于在容器中有哪些<code>Bean</code>实例。例如我需要访问数据库，容器中必须要有<code>JDBC</code>相关的<code>Bean</code>，我需要处理<code>web</code>请求，容器中必须有<code>Tomcat</code>和<code>Sevlet</code>相关的<code>Bean</code>。</p><p>如果采用上文的方式去测试<code>Spring</code>项目中某个模块，那必然会报错。因为<code>JUnit</code>并不会像<code>Spring</code>一样启动，并将这些功能<code>Bean</code>添加到容器中。也就无法完成例如依赖注入等功能。</p><p>为了让<code>JUnit</code>能启动容器环境，<code>Spring</code>提供了<code>@SpringBootTest</code>注解。只需要在测试类前添加<code>@SpringBootTest</code>，就可以在测试时启动<code>Spring</code>容器。如果不指定注解的<code>classes</code>属性，也就是启动的配置类，那么会将主应用程序类，也就带有<code>@SpringBootApplication</code>注解的类作为配置类。</p><p>另外，如果使用的是<code>JUnit4</code>，还需要在测试类上额外添加<code>@RunWith(SpringRunner.class)</code>。需要这么做的原因涉及<code>JUnit</code>框架原理，在此不深究。</p><p>但问题是，使用<code>@SpringBootTest</code>注解时，会创建一个真实的<code>SpringBoot</code>上下文，并加载所有的<code>Bean</code>，这会导致测试的运行速度较慢。测试可能往往只是想测一个刚写完的某个方法，但却需要将许多不相关的<code>Bean</code>都加载进来，这会造成严重性能浪费。较长的测试启动时间也会大大降低测试时的主观感受。</p><p>要解决这个问题，就需要知道容器里的<code>Bean</code>是怎么样的方式被加载进去的，已经如何自定义加载需要的<code>Bean</code>，这也是下一篇要讨论的内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JUnit</code>是<code>Java</code>中最公认的测试框架。使用时只需要在测试类的测试方法上加<code>@Test</code>注解，即可对目标方法进行测试。在测试类中，可以使用许多功能并生成测试报告，来判断目标方法是否按照预期执行。</p><p>由于<code>JUnit</code>框架默认不会启动<code>Spring</code>容器，而<code>Spring</code>应用的功能依赖于<code>Spring</code>容器。因此直接使用<code>JUnit</code>测试<code>Spring</code>项目中的类会发生错误。可以使用<code>@SpringBootTest</code>在测试类中启动<code>Spring</code>容器环境。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-IoC-DI</title>
    <link href="/2023/04/13/SpringBoot-IoC-DI/"/>
    <url>/2023/04/13/SpringBoot-IoC-DI/</url>
    
    <content type="html"><![CDATA[<p>在讨论<code>Spring</code>框架时，其中最核心的组件莫过于 <code>Spring Core</code>。而<code>Spring Core</code>完成了两个关键概念：<code>IoC</code>（Inversion of Control，控制反转）和<code>DI</code>（Dependency Injection，依赖注入）。</p><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><code>IoC</code>是一种设计模式，它将对象的创建和管理的控制从应用程序代码转移到了容器中。在Java当中，为了提高代码的复用率和可维护性，我们采用模块化编程，将功能相关的代码抽取成一个类&#x2F;模块。在本文中，模块专指提供方法，被其他类调用的类，本身也是一个类；而模块的调用类就称为类。</p><p>如果不采用<code>IoC</code>，使用某个模块的方法时，需要通过<code>new</code>关键字创造对象，再调用其中的方法，或者通过模块类直接调用其中的静态方法。这样在代码中需要显示地创建对象。并且如果一个模块在多个类中被使用时，会被重复创建多次，造成性能浪费。如果采用单实例，则需要通过构造函数显示地将实例传递进来。这在一个模块被多个类使用，一个类会使用多个模块的情况下变得十分繁琐。</p><p>而在<code>IoC</code>模式下，所有类的实例都会由容器统一创建并管理。容器本身很像<code>HashMap</code>，可以通过类名&#x2F;类型等作为<code>key</code>，从容器中获取到<code>value</code>实例对象。当需要在某个类中使用某个模块的方法，不再需要手动创建，而是直接从容器中获取已经创建好的实例对象。这就是<code>IoC</code>创建对象实例的功能。实际上<code>IoC</code>常还被用来解决对象之间的依赖关系、处理对象的生命周期等，在此不赘述。</p><p>从描述中可以发现，每个模块的实例化时机也发生了变化。本来是在每次将被访问时，<code>new</code>一个实例；而<code>IoC</code>一般是在程序启动时就将所有模块进行实例化并放入容器。但这本身也可以通过配置项进行修改。</p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>在上文介绍中，<code>IoC</code>管理了实例的创建，并将所创实例统一用一个容器进行管理访问。那么每当需要使用某个模块时，操作变成了从容器中获取实例，再调用实例的方法。当一个类中有多个方法都使用同一个实例，这个实例会在每个方法中都需要获取一次。因为方法内定义的是局部变量，方法运行结束就会出栈。为了简化开发，可以将用到的实例都设置为成员变量，这样实例的作用域扩大到整个类，所有成员方法都能使用。额外一提，将实例设置为成员变量，只会记录实例的指针&#x2F;引用，并不会新建一个实例，因此其开销是可接受的。这种将某个实例赋值给成员变量的过程，叫依赖注入。</p><p>但问题还存在，每个成员变量的初始化该怎么操作。可以通过直接在声明时赋值、使用代码块初始化，或者通过构造函数初始化。但无论使用哪种方式，为每个成员变量显示地从容器中根据类名&#x2F;类型获取实例的代码不可避免。实际情况中，大部分实例在容器中都是单实例模式的，这意味着根据成员变量的类型，在容器中有且仅能获取到一个。</p><p>为了简化开发，<code>Spring</code>提供了<code>@Autowire</code>注解。只需要在每个实例成员变量上添加这个注解，<code>Spring</code>就会在创建对象时，自动从容器中找到每个成员变量对应的单实例并赋值。这里也引出了新的问题，如果被引用的实例还没创建该怎么办，循环引用了该怎么办。这些问题可以单独再写一篇，在此略过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>IoC</code>和<code>DI</code>，程序员的开发过程变成了：</p><ol><li>开发每个模块，并通过<code>IoC</code>将模块实例化并放到容器中。</li><li>在需要引用模块的地方，声明模块实例的成员变量，并通过<code>@Autowire</code>关键字实现<code>DI</code>。</li></ol><p>如果不使用<code>IoC</code>，那么程序员将难以知晓创建了多少实例，每个实例的状态，每个实例的生命周期。而<code>IoC</code>将创建的实例统一放在了容器当中，相当于提供了一个控制台，可以很容易的获取每个实例的信息。如果不使用<code>DI</code>，那么在每个类中调用某个模块的方法会十分繁琐。而通过<code>成员变量</code> + <code>DI</code>的模式，可以清楚地读到每个类依赖了哪些模块，并简化开发流程。</p><p>通过<code>IoC</code>和<code>DI</code>，整个过程的耦合度大大降低，基于这种模式的开发也成为了最佳实践。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-ConfigurationProperties</title>
    <link href="/2023/04/07/SpringBoot-ConfigurationProperties/"/>
    <url>/2023/04/07/SpringBoot-ConfigurationProperties/</url>
    
    <content type="html"><![CDATA[<p>写代码时，常会在代码中使用配置相关的常量。</p><p>对于这些配置常量，最佳实践是配置文件分离，即将这些配置常量写入一个配置文件中。常见的配置文件包括如properties、XML文件、JSON文件、YAML文件。这样每次修改配置时，不需要改动源文件并重新编译，也不需要通过命令行传参，只需改动配置文件中对应属性即可。而且把配置信息放在一起会使代码可读性，可维护性更好。</p><h2 id="Java中的配置文件"><a href="#Java中的配置文件" class="headerlink" title="Java中的配置文件"></a>Java中的配置文件</h2><p>Java的常用配置文件为properties文件。可以通过<code>FileInputStream</code>或<code>ClassLoader</code>来读取配置文件。并通过包装成<code>Properties</code>对象，来解析文件中的属性。由于Java的配置文件通常位于类路径下，因此使用<code>ClassLoader</code>来读取有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-comment">// 使用ClassLoader获取配置文件的输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getClassLoader().getResourceAsStream(fileName);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to find &quot;</span> + fileName + <span class="hljs-string">&quot; in classpath&quot;</span>);<br>    &#125;<br>    properties.load(inputStream);<br>    inputStream.close();<br>    <span class="hljs-keyword">return</span> properties;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后需要将配置文件中的属性赋值到Java类的字段上。这种配置文件和类字段映射的思想叫做<code>配置文件驱动开发</code>。</p><p>但在实际开发中，一整个项目的配置信息是十分多的。如果对于每一个配置属性都显式地赋值给一个类字段，那整个赋值过程会十分繁琐。因此需要一种方式，能将配置文件自动映射到类字段上。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="ConfigurationProperties"></a>ConfigurationProperties</h2><p>谈到Java开发就离不开Spring（SpringBoot）。Spring提供了许多常见且通用的功能和工具来简化 Java 应用程序的开发，例如上文提到的配置文件的自动映射。</p><p>在Spring当中，如果需要将配置文件映射到某个类上，那么只需要在这个类上添加<code>@ConfigurationProperties</code>注解，并将这个类在Spring容器中实例化，Spring就会自动完成配置属性注入的功能。</p><p>具体实现时，通常有两种方式。</p><ol><li><p><code>@ConfigurationProperties</code> + <code>@Component</code> </p></li><li><p><code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code></p></li></ol><p>其中<code>@ConfigurationProperties</code> 加在需要配置属性注入的类上，并在注解中指定配置属性的前缀。并通过<code>@Component</code> 将类加入到容器中。需要注意的是，通过这种方式需要确保在主配置类中开启了<code>@ComponentScan</code>，并且能扫描到此类。</p><p>而Spring的默认配置文件名为<code>application.properties</code>，且位于类路径的根目录下。这是Spring的<code>默认大于配置</code>软件设计原则。也就是如果没特殊情况，大家都遵守这样的约定。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">abc.name</span>=Tom<br><span class="hljs-attr">abc.version</span>=V1.<span class="hljs-number">1</span><br><span class="hljs-attr">logging.level.root</span>=info<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处定义了<code>MyConfiguration</code>类，并且包含两个字段<code>name</code>，<code>version</code>，字段名与配置文件中的属性键去掉前缀对应。并通过<code>@ConfigurationProperties(prefix = &quot;abc&quot;)</code>注解指定了配置文件中的前缀，这样就可以在配置文件中通过前缀组织不同配置的属性。</p><p>或者，可以使用<code>@EnableConfigurationProperties</code>，添加在主配置类上，此时可以将属性注入的类上的<code>@Component</code>去掉，否则容器中会有两个<code>MyConfiguration</code>的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyConfig.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>@EnableConfigurationProperties</code>中指定需要开启属性注入功能的类。</p><p>但在实际过程中，出现了一些问题。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在实际学习过程中，属性注入一直失败。最后排查发现，对于属性注入的类，还需要配置Setter方法。这是因为配置属性注入，是通过Java反射，调用了对应的Setter方法。可以自行显示地定义Setter方法，或者使用<code>@Data</code>注解，自动生成类的Getter、Setter方法。</p><p>但在定义完Setter方法后，使用<code>@ConfigurationProperties</code> + <code>@Component</code>的方式配置属性注入依旧无法完成。通过对类属性打上断点，并查看调用栈，发现要使用这种方式完成配置属性注入，容器内必须要有<code>ConfigurationPropertiesBindingPostProcessor</code>。这是一个<code>BeanPostProcessor</code>，本质也是一个Bean，但和普通Bean的不同在于它可以参与Bean的实例化过程，以对其他Bean进行属性修改或功能增强。而在不使用<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>的最小配置启动下，默认没有向容器中导入这个<code>BeanPostProcessor</code>。</p><p><img src="/img/ConfigurationPropertiesBindingPostProcessor.png" alt="ConfigurationPropertiesBindingPostProcessor"></p><p>并且在调用栈中，可以观察到最后是通过反射的方式，调用Setter方法来完成了配置属性注入。</p><p><img src="/img/SetName.png" alt="SetName"></p><p>而使用<code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code> 的方式则不需要<code>@EnableAutoConfiguration</code>配置项。通过调试发现，<code>@EnableConfigurationProperties</code> 带有<code>@Import(EnableConfigurationPropertiesRegistrar.class)</code>注解，而<code>EnableConfigurationPropertiesRegistrar</code>在方法<code>registerBeanDefinitions</code>中，向容器中注册了<code>ConfigurationPropertiesBindingPostProcessor</code>，而后被实例化以提供配置属性注入的功能。</p><p>这一部分内容很涉及框架层面的内容，暂时不准备挖的更深。总之，<code>@EnableConfigurationProperties</code> 本身就会向容器内导入<code>ConfigurationPropertiesBindingPostProcessor</code>，因此不需要<code>@EnableAutoConfiguration</code>也能完成配置属性注入工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置文件分离是软件部署的最佳实践，熟悉其过程和原理也是每个程序员的必修课。在Spring框架中，使用<code>@ConfigurationProperties</code> 来完成配置文件与类的绑定，在使用时需要指定每个类对应配置文件键的前缀。并把这个类放入容器中，以被<code>ConfigurationPropertiesBindingPostProcessor</code>完成属性注入的功能。而<code>ConfigurationPropertiesBindingPostProcessor</code>可以通过<code>@EnableAutoConfiguration</code>或<code>@EnableConfigurationProperties</code>导入。<code>ConfigurationPropertiesBindingPostProcessor</code>最终是通过Java反射完成属性注入，需要调用对应的Setter方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>ConfigurationProperties</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除/高亮页面元素的JS脚本</title>
    <link href="/2023/04/06/remove-highlight-javascript/"/>
    <url>/2023/04/06/remove-highlight-javascript/</url>
    
    <content type="html"><![CDATA[<p>最近开发了一个基于TamperMonkey的JS脚本，其主要功能为去除特定页面中的广告、Header等无效信息元素，并根据逻辑高亮其中重要信息元素。</p><p><a href="https://github.com/DracoYus/lolalytics-light">Github</a></p><p>从解决需求角度出发，常见的去除页面中的广告可以通过CSS植入，并利用样式选择器将广告元素的display属性设置为none。但需要根据逻辑高亮元素（如经过元素内文本排序后，对前n位进行高亮），简单的CSS植入无法满足这个需求。因此最后采用了TamperMonkey执行JS脚本的方案，利用JS操纵DOM元素来达到去除&#x2F;高亮元素的目的。</p><p>目标页面采用了懒加载处理，可见范围外的元素不会提前加载。而TamperMonkey的内置执行时机，只能在页面开始加载或加载完成后执行一次。对于页面加载完成后，动态新加载的元素，无法完成功能。</p><table><thead><tr><th>@run-at</th><th>Timing</th></tr></thead><tbody><tr><td>document-start</td><td>as fast as possible</td></tr><tr><td>document-body</td><td>body element exists</td></tr><tr><td>document-end</td><td>when or after the DOMContentLoaded event was dispatched</td></tr><tr><td>document-idle</td><td>after the DOMContentLoaded event was dispatched</td></tr><tr><td>context-menu</td><td>it is clicked at the browser context menu</td></tr></tbody></table><p>由于页面的动态加载，需要多次执行目标函数。一种做法是，通过<code>setInterval</code>函数来指定目标函数每隔一段时间执行。这样的优点是编码简单，缺点是消耗系统资源，不太优雅。页面动态加载会导致DOM元素的增加或减少，因此更为优雅的做法是注册事件，当页面元素发生变化时，重新执行目标函数，这就用到了<code>MutationObserver</code>。</p><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p><code>MutationObserver</code>可以检测页面元素属性变化、子节点的添加或删除、文本内容的变化等。</p><p><code>MutationObserver</code> 的使用步骤如下：</p><ol><li><p>创建一个 MutationObserver 对象，传入一个回调函数作为参数，该回调函数将在 DOM 树变化时被调用。在此问题中，callback就是去除&#x2F;高亮页面元素的函数。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>observe</code> 方法开始监视 DOM 元素的变化，传入要观察的 DOM 元素以及要观察的变化类型的配置对象。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">observer.<span class="hljs-title function_">observe</span>(target, options);<br></code></pre></td></tr></table></figure><p> <code>target</code> 是要观察的 DOM 元素，一般为<code>document.documentElement</code>，表示监视整个页面文档的元素变化。<code>options</code> 是一个配置对象，用于指定要观察的变化类型。此处为<code>&#123;childList: true, subtree: true&#125;</code>，表示检测target以及其子节点的元素变化。如果不设置，默认只监测<code>target</code>本身，子节点的添加和减少不会被监测到。</p></li><li><p>在回调函数中处理 DOM 变化的情况。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">mutationsList, observer</span>) &#123;<br>  <span class="hljs-comment">// mutationsList 是一个 MutationRecord 对象的数组，包含了发生的 DOM 变化</span><br>  <span class="hljs-comment">// observer 是当前的 MutationObserver 对象</span><br><br>  <span class="hljs-comment">// 在这里处理 DOM 变化的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 回调函数可以接收到发生变化的元素的信息。可以通过判断改变的是哪个元素，来具体执行去除&#x2F;高亮的动作。在本项目中，为了偷懒并没有在此进行判断。</p></li></ol><h2 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h2><p>在采用<code>MutationObserver</code>之后，页面出现了无法加载的情况。通过调试器查看到，目标函数被反复调用，整个页面陷入卡死的状态。猜测是页面元素发生变动，调用了目标函数后，目标函数也改变了页面元素（但是我的代码里没有啊？），反复触发了<code>MutationObserver</code>的目标函数，形成了递归死循环。为了解决这个问题，了解了函数防抖和函数节流。</p><h2 id="函数防抖和函数节流"><a href="#函数防抖和函数节流" class="headerlink" title="函数防抖和函数节流"></a>函数防抖和函数节流</h2><p>函数防抖和函数节流都是用于限制某个函数的执行频率。如果函数调用的频率小于设定的阈值，那么是否采用函数防抖和函数节流对程序执行没有任何区别。</p><p>防抖的基本思想是在一定的时间间隔内，只执行最后一次触发事件的处理函数，忽略在此时间间隔内的其他触发事件。与函数防抖不同，函数节流是在一定的时间间隔内，定期执行事件处理函数。</p><p>函数防抖就像拍卖，拍卖成功（目标函数执行）会在敲三锤（一定间隔后）执行，一旦在敲三锤前进行了竞拍（再次调用用防抖包裹的目标函数），那么间隔会被重置。</p><p>函数节流就像大学抢浴室。一个人进了浴室（调用用节流包裹的目标函数），其他人再想进去（再次调用用节流包裹的目标函数）就不行，必须等这个人洗完（一定间隔），一旦他洗完（目标函数执行），所有人都可以再次抢浴室（调用用节流包裹的目标函数）。从某种角度，这和锁机制很像，被上锁的对象为计时器。只有获得计时器的调用才会被真正执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId; <span class="hljs-comment">// 记录定时器的ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 如果已存在定时器，则先清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timerId) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    <span class="hljs-comment">// 创建新的定时器，延迟执行 func 函数</span><br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行 func 函数</span><br>      timerId = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空定时器ID</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123; <span class="hljs-comment">// 判断当前时间与上次执行的时间间隔是否超过指定的等待时间</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>      lastTime = now; <span class="hljs-comment">// 更新上次执行的时间戳</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖和节流都能限制函数被调用的频率，区别是什么时候能再次被调用，防抖是从多次小于设定间隔的连续调用的最后一次开始计算，而节流是从第一次调用开始计算，因此相同条件下，节流可以更快地进行第二次有效调用。</p><p>总的来说，函数防抖适合在需要等待一段时间后再执行函数的场景。如果目标函数不需要等待可以立即执行，则使用节流即可。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TamperMonKey</tag>
      
      <tag>MutationObserver</tag>
      
      <tag>函数防抖</tag>
      
      <tag>函数节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
