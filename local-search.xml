<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Design-Pattern-Adapter</title>
    <link href="/2024/07/03/Design-Pattern-Adapter/"/>
    <url>/2024/07/03/Design-Pattern-Adapter/</url>
    
    <content type="html"><![CDATA[<p><strong>创建型模式</strong>已经全部介绍完，接下来是<strong>结构型模式</strong>。</p><p>在以往的文中提过，<strong>结构型模式</strong>和<strong>行为型模式</strong>边界比较模糊。根据定义，<strong>结构型模式</strong>侧重于类和对象的组合以构建灵活且高效的结构，而<strong>行为型模式</strong>侧重于类和对象之间的通信和职责分配。但<strong>结构</strong>和<strong>行为</strong>本身就会相互影响，因此会存在模棱两可的分类。例如<strong>代理</strong>语义上是个行为，但是<strong>代理模式</strong>是<strong>结构模式</strong>；<strong>中介者</strong>组织了<strong>组件</strong>间的结构关系，但是<strong>中介者模式</strong>是<strong>行为模式</strong>。</p><p><strong>结构模式</strong>和<strong>行为模式</strong>都涉及多个类或对象。通常来说，<strong>结构模式</strong>中的单个类通常是不完整的，需要通过特定结构，来组成完整的功能。而<strong>行为模式</strong>中的单个类通常是独立的，模式定义了这些类之间的交互。</p><p>此定义能提供一些解释，但也不严谨，存在反例。笔者认为对于设计模式分类过度纠结是钻牛角尖，在实际使用时也不会纠结如何辨别两者。</p><h2 id="场景">场景</h2><p>假设现在有一段<strong>客户端</strong>代码，其中和<code>A</code>类对象进行交互。根据业务需求，在代码中需要新增与<code>B</code>类对象进行交互的需求。为了更形象，可以想象客户端代码是一个进行数据分析的功能，<code>A</code>和<code>B</code>类是某种特定格式的数据。客户端代码需要读取数据，对数据进行处理并展示结果。</p><p>由于<code>B</code>类的交互方式与<code>A</code>类不同，因此无法在不修改客户端代码的情况下对<code>B</code>进行适配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端代码，与A类对象交互</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">client</span><span class="hljs-params">(A a)</span> &#123;<br>    ...<br>    a.methodA();<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <span class="hljs-type">Result</span> <span class="hljs-variable">resultA</span> <span class="hljs-operator">=</span> client(a);<br>    <span class="hljs-comment">// B b = new B();</span><br>    <span class="hljs-comment">// Result resultB = client(a); 类型不匹配，无法通过编译</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不想改变客户端代码，要使得代码能运行。直观的想法，可以<strong>在调用客户端方法前，把<code>B</code>类对象转化为<code>A</code>对象</strong>。如果代码中很多位置都会用到这个方法，可以把这个转化方法设置为静态公共方法。如果后续还要兼容其他<code>C</code>、<code>D</code>类等，可以把这些转换方法都抽取到一个工具类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> convertBToA(b);<br>    <span class="hljs-type">Result</span> <span class="hljs-variable">resultB</span> <span class="hljs-operator">=</span> client(a); <br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换方法，将B类对象转化为A类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">convertBToA</span><span class="hljs-params">(B b)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <span class="hljs-comment">// 一些初始化代码</span><br>    ...<br>    B.methodB();<br>    ...<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>从面向接口编程的思想出发，客户端代码如果需要兼容功能相似的多个类，应该定义统一的接口，并将多个类都实现这个接口。在客户端代码中，通过接口定义的方法与这些类进行交互，实现代码通用性。所以另一种修改思路就是定义共同接口，并<code>A</code>和<code>B</code>中都实现这个接口，并将客户端改为使用接口作为参数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端代码，与A接口交互</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">client</span><span class="hljs-params">(InterfaceA a)</span> &#123;<br>    ...<br>    a.methodA();<br>    ...<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;...&#125;;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;...&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的写法通常是最佳实践。但此处存在一个前提，对于<code>B</code>类，我们有修改其代码的权限。具体来说我们修改<code>B</code>类实现了<code>InterfaceA</code>接口。但这个前提不是一定成立的。例如<code>B</code>类代码在别处还有引用，修改可能会破坏其它功能；例如<code>B</code>类来自某个第三方库。在这种场景下，就需要用到适配器模式了。</p><h2 id="适配器模式">适配器模式</h2><p>适配器模式中，新增了一个<strong>适配器（Adapter）类</strong>。适配器类实现了<strong>目标（Target）接口</strong>，并通过组合形式持有一个<strong>被适配对象（Adaptee）类/接口</strong>。</p><p>对于上文例子来说，目标接口就是<code>InterfaceA</code>，被适配对象就是类<code>B</code>。由此可以</p><pre><code class=" mermaid">classDiagram    direction TB    class client        class InterfaceA    &lt;&lt; interface &gt;&gt; InterfaceA    client ..&gt; InterfaceAclass BAdapter &#123;-B b&#125;    BAdapter ..|&gt; InterfaceA    BAdapter --&gt; B</code></pre>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Singleton</title>
    <link href="/2024/05/15/Design-Pattern-Singleton/"/>
    <url>/2024/05/15/Design-Pattern-Singleton/</url>
    
    <content type="html"><![CDATA[<p><strong>单例模式<code>(Singleton)</code></strong>是一种创建型模式。目的是，<strong>确保类只有一个实例</strong>，并提供一个<strong>访问该实例的全局节点</strong>。</p><p>会产生这样的需求，理由也十分自然：在全局范围内使用同一个对象或资源，方便统一配置与管理。典型的场景如：配置类、日志类、资源管理类（数据库连接池）等。</p><p>在<code>SpringBoot</code>常见的分层架构中，<code>Controller</code>层、<code>Service</code>层通常不需要多个实例，因其成员变量通常为对其他<code>Service</code>的引用，几乎不包含状态信息。如果有多个实例，实例间也无法体现差异。因此在<code>Spring</code>框架中，容器中的各种<code>bean</code>默认是单实例的。并通过<code>IoC</code>和<code>DI</code>，去组织不同单实例间的依赖关系。需要注意单实例不一定是单例模式，因为其并不是全局范围都能访问，而是通过<code>DI</code>组织了依赖关系。但如果是通过<code>BeanFactory.getBean()</code>来获取单实例，则和单例模式十分相似。</p><p>不同实例间的差异体现在其成员变量上。如果创建的多个实例成员变量都相同，并且实例在全局范围内有比较多使用的地方，则可以考虑使用单例模式。</p><h2 id="单例模式vs静态公共方法">单例模式VS静态公共方法</h2><p>如果为了提供一些方法和变量的全局访问权限，在<code>java</code>中可以将这些方法和变量设置为<code>public static</code>，可以得到类似的效果。静态公共方法可以在任意位置通过<strong>类名.方法名</strong>调用。类的加载机制又保证了，在不同位置调用的方法，引用的都是相同的静态成员变量，模拟了只有一个实例的效果。</p><p>但这么做也多了很多限制：静态方法中只能引用静态变量；静态变量属于类而不是实例，无法被继承，也无法实现接口；无法通过多态来进行动态调用；无法控制其生命周期；无法进行垃圾回收；无法实现延迟初始化等等。</p><p>由于单例模式比静态公共方法灵活得多，因此更多使用单例模式来达成全局访问的效果。</p><h2 id="单例模式vs全局变量">单例模式VS全局变量</h2><p>在一些面向对象语言中，如<code>C++</code>、<code>Python</code>，可以通过全局变量的方式来建立全局访问的效果。通常我们认为全局变量是需要避免的。而单例模式，很多人认为其是对全局变量的一种包装，因此也反对使用单例模式。例如<code>C++ Core Guidelines</code>中就不建议使用<ahref="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-singleton">单例模式</a>。</p><p>使用全局变量的缺点同样也是单例模式的缺点。例如全局范围内的访问和修改可能会导致全局变量的状态无法估计；需要考虑并发访问，线程安全性；使得模块之间的依赖关系变得隐匿（如两个模块共同与全局变量进行了交互），造成了模块间的耦合；使得单元测试变得更困难，无法<code>mock</code>替换；<code>C++</code>中无法保证全局变量初始化的顺序。</p><p>可以看出，这些缺点很多都与全局的写权限有关。因此单例模式如果不提供写的权限，或者不包含状态类型的变量（状态通常会在程序运行中改变），或者本身就是不可变对象，那么可以很好地规避上述缺点。此时单例模式的使用通常是合适且优雅的。</p><p>网上关于设计模式、反设计模式的讨论还有很多。程序员需要根据实际情况，来决定是否使用，而不是一昧支持或反对。</p><h2 id="单例模式的通用实现">单例模式的通用实现</h2><p>单例模式在不同语言中，根据每种语言的特性，有着不同的实现。在不同实现中，有一些共同之处。综合这些共同之处，便是一个通用实现。</p><p>为了符合单例模式<strong>确保类只有一个实例</strong>的特性，需要限制程序员在其他地方主动<code>new</code>实例的权限，把类的构造函数设置为<code>private</code>。而<strong>全局访问</strong>的特性，通常会在类内定义一个<code>public static</code>静态方法，返回一个类对象。</p><p>这个单例对象需要被某个变量引用。基于其全局唯一的特性，通常会定义为类的静态变量。并在静态方法中作为方法返回值。</p><p>基于上述描述，可以给出如下<code>java</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 私有构造方法防止外部实例化</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，静态变量<code>INSTANCE</code>通过直接赋值来进行初始化。对于静态变量，初始化会在类被加载时执行。而<strong>类的加载机制</strong>保证了线程安全性，<code>new Singleton()</code>只会被执行一次，确保全局只会存在一个实例。</p><p>由于上述过程中，类被加载时就会完成实例的初始化，初始化的时机比较早，此方法被称作“<strong>饿汉式</strong>"。</p><p>与之相对的是，在<code>getInstance()</code>被首次调用时才完成初始化，初始化时机更晚，被称作“<strong>懒汉式</strong>”。在懒汉式中。由于静态方法可能被多线程同时调用，多个线程只能有一个完成对象的创建和初始化，需要在方法中通过锁机制，来保证线程安全性。关于如何实现线程安全太过细节，为了避免掩盖单例模式的特点，在此不再赘述。</p><h2 id="总结">总结</h2><p>单例模式是一种创建型模式，旨在确保一个类只有一个实例，并提供一个全局访问点。</p><p>由于单例模式的全局性，通常会把其与全局变量比较。全局变量的缺点，可能在单例模式上也存在。通常可以通过在单例中不包含状态或提供改变状态的方法来避免这些缺点。程序员需要根据实际情况判断场景是否适合单例模式。</p><p>单例模式的通用实现的特点是，把构造函数私有化，以及提供一个公开静态函数。前者支持<strong>唯一性</strong>，后者提供<strong>全局访问性</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Term-Definaition-BeanFactory</title>
    <link href="/2024/04/23/SpringBoot-Term-Definaition-BeanFactory/"/>
    <url>/2024/04/23/SpringBoot-Term-Definaition-BeanFactory/</url>
    
    <content type="html"><![CDATA[<h2 id="beanfactory">BeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>The root interface for accessing a Spring bean container.</p></blockquote><p>今天讲到Spring中最关键的概念<code>BeanFactory</code>。从注释中可以得到，<code>beanFactory</code>就是平常说的<strong>容器</strong>，后文会不加区分使用<code>beanFactory</code>和容器。</p><blockquote><p>This is the basic client view of a bean container; further interfacessuch as ListableBeanFactory andorg.springframework.beans.factory.config.ConfigurableBeanFactory areavailable for specific purposes.</p></blockquote><p>其子接口<code>ListableBeanFactory</code>与<code>ConfigurableBeanFactory</code>，对功能进行了拓展，具体有哪些拓展等后续介绍完<code>BeanFactory</code>再说。</p><blockquote><p>This interface is implemented by objects that hold a number of beandefinitions, each uniquely identified by a String name. Depending on thebean definition, the factory will return either an independent instanceof a contained object (the Prototype design pattern), or a single sharedinstance (a superior alternative to the Singleton design pattern, inwhich the instance is a singleton in the scope of the factory). Whichtype of instance will be returned depends on the bean factoryconfiguration: the API is the same. Since Spring 2.0, further scopes areavailable depending on the concrete application context (e.g. "request"and "session" scopes in a web environment).</p></blockquote><p><code>BeanFactory</code>的最主要的功能，就是储存了一系列<code>BeanDefinition</code>，并且每个都使用了一个唯一的字符串来标识。我们可以通过这个唯一字符串，检索到<code>BeanDefinition</code>，并根据此来决定是使用已有的对象(<code>Singleton</code>)，还是新建一个对象(<code>Prototype</code>)。</p><p>容器中大部分<code>BeanDefinition</code>，都是<code>Singleton</code>类型，因此<code>BeanDefinition</code>和大部分对象也是一一对应的关系，从而字符串到大部分对象也是一一对应的关系。所以常规中，我们会认为容器完成了字符串到对象的映射。</p><blockquote><p>The point of this approach is that the BeanFactory is a centralregistry of application components, and centralizes configuration ofapplication components (no more do individual objects need to readproperties files, for example). See chapters 4 and 11 of "ExpertOne-on-One J2EE Design and Development" for a discussion of the benefitsof this approach.</p></blockquote><p>容器是一种把应用中用到的所有组件，中心化配置的一种设计理念。并引用了一本书中的内容来说明这么做的好处。在此不多赘述。</p><blockquote><p>Note that it is generally better to rely on Dependency Injection("push" configuration) to configure application objects through settersor constructors, rather than use any form of "pull" configuration like aBeanFactory lookup. Spring's Dependency Injection functionality isimplemented using this BeanFactory interface and its subinterfaces.</p></blockquote><p>在<code>spring</code>应用中，可以在对象初始化时，或在对象创建完后，通过构造函数或<code>setter</code>方法完成依赖注入，把依赖注册为成员变量。这是更推荐的“推式”注入。与之对应的是在方法内需要用到时，通过<code>BeanFactory</code>的查询方法获取对象，此为不推荐的“拉式”注入。无论是“推式”还是“拉式”，都会使用到<code>BeanFactory</code>来完成功能，因此两者的最大区别是注入的时机。广泛使用的<code>@Resource</code>或<code>@Autowired</code>就是“推式”注入。</p><blockquote><p>Normally a BeanFactory will load bean definitions stored in aconfiguration source (such as an XML document), and use theorg.springframework.beans package to configure the beans. However, animplementation could simply return Java objects it creates as necessarydirectly in Java code. There are no constraints on how the definitionscould be stored: LDAP, RDBMS, XML, properties file, etc. Implementationsare encouraged to support references amongst beans (DependencyInjection).</p></blockquote><p><code>BeanFactory</code>获取对象，先加载<code>BeanDefinition</code>，并使用<code>SpringBean</code>包来创建具体对象并返回，这不是绝对的。在某些情况<code>BeanDefinition</code>来源特殊，可以越过上述过程，直接获取对象。</p><blockquote><p>In contrast to the methods in ListableBeanFactory, all of theoperations in this interface will also check parent factories if this isa HierarchicalBeanFactory. If a bean is not found in this factoryinstance, the immediate parent factory will be asked. Beans in thisfactory instance are supposed to override beans of the same name in anyparent factory.</p></blockquote><p><code>HierarchicalBeanFactory</code>会同时检查父容器，而<code>ListableBeanFactory</code>不会。当存在多级容器时，会遵循“就近原则”，子容器的同名<code>BeanDefination</code>会覆盖父容器。</p><p>以上是<code>BeanFactory</code>的注释内容。查看<code>BeanFactory</code>中定义的方法，基本就是根据名称/类型获取对象，根据名称检查<code>BeanDefination</code>是否存在和其属性值。总的来说，容器的功能就是储存名称和<code>BeanDefination</code>，并可以通过名称获取<code>BeanDefination</code>对应的对象。</p><h2 id="listablebeanfactory">ListableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.beans.factory;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>Extension of the BeanFactory interface to be implemented by beanfactories that can enumerate all their bean instances, rather thanattempting bean lookup by name one by one as requested by clients.BeanFactory implementations that preload all their bean definitions(such as XML-based factories) may implement this interface.</p></blockquote><p><code>ListableBeanFactory</code>是<code>BeanFactory</code>的扩展。在原有基础上新增了获取枚举容器中<code>BeanDefinition</code>数量、名称的功能。</p><blockquote><p>If this is a HierarchicalBeanFactory, the return values will not takeany BeanFactory hierarchy into account, but will relate only to thebeans defined in the current factory. Use the BeanFactoryUtils helperclass to consider beans in ancestor factories too.</p></blockquote><p>与<code>BeanFactory</code>不同的是，<code>ListableBeanFactory</code>扩展的功能，不会考虑层级结构，也就是不会搜索父容器中定义的<code>BeanDefinition</code>。</p><blockquote><p>The methods in this interface will just respect bean definitions ofthis factory. They will ignore any singleton beans that have beenregistered by other means likeorg.springframework.beans.factory.config.ConfigurableBeanFactory'sregisterSingleton method, with the exception of getBeanNamesForType andgetBeansOfType which will check such manually registered singletons too.Of course, BeanFactory's getBean does allow transparent access to suchspecial beans as well. However, in typical scenarios, all beans will bedefined by external bean definitions anyway, so most applications don'tneed to worry about this differentiation.</p></blockquote><p><code>ListableBeanFactory</code>扩展的功能基本只考虑根据<code>BeanDefinition</code>创建的<code>bean</code>。通过其他方法例如<code>registerSingleton</code>注册进容器的<code>bean</code>，不予考虑。</p><p>总的来说，<code>ListableBeanFactory</code>的扩展就在于<code>Listable</code>上，使得容器增加了枚举所有<code>BeanDefinition</code>的功能。</p><h2 id="hierarchicalbeanfactory">HierarchicalBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HierarchicalBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>Sub-interface implemented by bean factories that can be part of ahierarchy.</p><p>The corresponding setParentBeanFactory method for bean factories thatallow setting the parent in a configurable fashion can be found in theConfigurableBeanFactory interface.</p></blockquote><p><code>HierarchicalBeanFactory</code>接口非常简单，在<code>BeanFactory</code>上扩展了层级功能。容器可以指定其父容器。为了区分是否搜索父容器的场景，新增了<code>containsLocalBean</code>方法。见名知意，这个方法不搜索父容器，而<code>BeanFactory</code>中声明的<code>containsBean</code>则会搜索父容器。</p><h2 id="singletonbeanregistry">SingletonBeanRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SingletonBeanRegistry</span><br></code></pre></td></tr></table></figure><blockquote><p>Interface that defines a registry for shared bean instances. Can beimplemented by org.springframework.beans.factory.BeanFactoryimplementations in order to expose their singleton management facilityin a uniform manner.</p></blockquote><p><code>SingletonBeanRegistry</code>看似和<code>BeanFactory</code>没有直接关系，但通常被<code>BeanFactory</code>的实现类同时实现，以提供把某个<code>bean</code>实例注册进容器中。</p><p>注册<code>bean</code>实例和上文提到的大部分注册<code>beanDefinition</code>的主要区别是，注册的实例默认为单实例模式，并且默认已完成初始化。已完成初始化意味着，<code>BeanFactory</code>不会对其进行生命周期控制，不会执行初始化、销毁函数的回调。</p><p><code>SingletonBeanRegistry</code>还提供了查看容器内已初始化的<code>Singleton</code>，由于不是很重要，在此不再赘述。</p><h2 id="configurablebeanfactory">ConfigurableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigurableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HierarchicalBeanFactory</span>, SingletonBeanRegistry<br></code></pre></td></tr></table></figure><blockquote><p>Configuration interface to be implemented by most bean factories.Provides facilities to configure a bean factory, in addition to the beanfactory client methods in the BeanFactory interface.</p><p>This bean factory interface is not meant to be used in normalapplication code: Stick to BeanFactory ororg.springframework.beans.factory.ListableBeanFactory for typical needs.This extended interface is just meant to allow for framework-internalplug'n'play and for special access to bean factory configurationmethods.</p></blockquote><p><code>ConfigurableBeanFactory</code>是<code>HierarchicalBeanFactory</code>和<code>SingletonBeanRegistry</code>的扩展，额外拓展了对<code>BeanFactory</code>进行配置的功能。</p><p>那么这个配置指什么，查看<code>ConfigurableBeanFactory</code>新增的方法声明，<code>parentBeanFactory</code>、<code>beanClassLoader</code>、<code>tempClassLoader</code>、<code>cacheBeanMetadata</code>...</p><p>这里出现了很多新的细节与概念，暂且搁置。而且通常用户层面更多使用<code>BeanFactory</code>和<code>ListableBeanFactory</code>访问容器，很少会有对容器进行配置的需求，因此此部分内容只是简单描述。</p><h2 id="autowirecapablebeanfactory">AutowireCapableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AutowireCapableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>Extension of the BeanFactory interface to be implemented by beanfactories that are capable of autowiring, provided that they want toexpose this functionality for existing bean instances.</p><p>This subinterface of BeanFactory is not meant to be used in normalapplication code: stick to BeanFactory ororg.springframework.beans.factory.ListableBeanFactory for typical usecases.</p></blockquote><p><code>AutowireCapableBeanFactory</code>关注自动装配相关的功能。通常是对那些在容器外部创建<code>bean</code>实例执行自动装配功能，内部的<code>bean</code>可以通过<code>@AutoWired</code>和<code>@Resource</code>来配置需要使用自动装配功能的地方。</p><p>虽然名称叫<code>AutowireCapableBeanFactory</code>，接口还提供了自动装配以外的功能，例如执行容器的回调<code>setBeanName</code>、<code>setBeanFactory</code>，或者执行<code>BeanPostProcessors</code>。</p><h2id="configurablelistablebeanfactory">ConfigurableListableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigurableListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ListableBeanFactory</span>, AutowireCapableBeanFactory, ConfigurableBeanFactory<br></code></pre></td></tr></table></figure><blockquote><p>Configuration interface to be implemented by most listable beanfactories. In addition to ConfigurableBeanFactory, it providesfacilities to analyze and modify bean definitions, and topre-instantiate singletons.</p></blockquote><p>从继承关系来看，<code>ConfigurableListableBeanFactory</code>就是上文提到三个的合体版。此外，提供了分析修改<code>BeanDefinition</code>和预实例化单实例的功能。由于此接口提供的方法相对简单，不多赘述。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>TermDefinition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Term-Definition</title>
    <link href="/2024/04/22/SpringBoot-Term-Definition/"/>
    <url>/2024/04/22/SpringBoot-Term-Definition/</url>
    
    <content type="html"><![CDATA[<p>近期，在<code>Github</code>上读到了关于源码学习的<ahref="https://github.com/doocs/source-code-hunter">仓库</a>，并跟着学习了<code>Spring</code>全家桶源码。这对设计模式的学习和程序设计是十分有帮助的，因为<code>Spring</code>源码中存在大量设计模式的优秀实践。但设计模式的广泛运用也导致<code>Spring</code>类之间关系复杂，源码阅读费力。</p><p>在学习过程中，发现自己对<code>Spring</code>中许多概念是模糊的。这可能是因为学习<code>Spring</code>时，都是从使用侧考虑，忽略了非常多底层细节。对于概念的认知，更多来自于口口相传或望文生义的猜测。例如能否严谨地阐述容器，<code>BeanFactory</code>和<code>ApplicationContext</code>三者间的关系。很多文章，包括笔者自己，都在不加区分地使用这三个概念。这种模糊的概念认知，对于日常使用<code>Spring</code>没有任何影响，但在学习源码时，就会产生大量歧义。</p><p>比较常见的源码学习方式，例如跟踪<code>SpringApplication.run</code>方法，查看一层层的调用情况，容易让读者迷失在概念的海洋当中。这样的学习模式是在用未知解释未知，很大一部分还是要靠猜，并且很难靠自己验证猜想是否准确。由于笔者对<code>Spring</code>整体并没有很深刻认知，本篇笔记更多是对源码的翻译和转述，着重描述<code>Spring</code>的概念。这些概念的解释全部来自于<code>Spring</code>源码和注释。</p><p>源码基于<code>SpringBoot3.1.7</code>版本。此版本没特别之处，只是上一个做的项目恰好使用了这个版本。通常在核心层面源码也不会发生大改动，任意一个常用的版本应该都能得到一致的概念描述。</p><h2 id="接口抽象类具体类">接口、抽象类、具体类</h2><p>学习<code>Spring</code>源码，最大的体验就是复杂的类关系。使用了大量的抽象，定义了许多接口、抽象类。</p><p>在面向对象编程的学习中，接口实现通常用来表示“能干什么”，而类继承通常表示“是什么”。但在<code>Spring</code>源码中，很多地方使用接口表示了“是什么”的概念。当然也可以玩文字游戏，接口可以表示“作为什么应该具有的功能”。例如<code>Resource</code>接口表示了，作为资源应该具有的功能。但笔者认为直接使用“是什么”去解释接口更符合人们常规理解。实现了<code>Resource</code>接口表示某个具体类是一种<code>Resource</code>。</p><p>会产生这样的情况，很大原因是<code>java</code>无法进行多继承。而<code>spring</code>由于高度的抽象，功能划分地十分细致（<strong>接口隔离原则</strong>）。当一个具体类具有多个功能，多实现避免了无法多继承的限制。</p><p>但针对某个接口具体实现类中，通常包含大量相似的代码。虽然<code>java 8</code>后，可以通过提供默认方法，将相似代码抽取到接口中。但许多接口方法都依赖于具体的成员变量，而接口中只能包含常量，不能包含非常量的成员变量。因此这部分具体实现类中重复的代码，通常会被抽取到一个抽象类中，将这个抽象类实现接口，并在抽象类中提供许多接口方法的默认实现。</p><p>这样的模式在<code>Spring</code>中极为常见，识别这种模式能更便于理解类之间的关系。</p><h2 id="resource">Resource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.core.io<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamSource</span><br></code></pre></td></tr></table></figure><blockquote><p>Interface for a resource descriptor that abstracts from the actualtype of underlying resource, such as a file or class path resource.</p><p>An InputStream can be opened for every resource if it exists inphysical form, but a URL or File handle can just be returned for certainresources. The actual behavior is implementation-specific.</p></blockquote><p><code>Resource</code>接口用来表示可以被读取内容的资源。<strong>通俗地理解就是某个文件</strong>，但这个文件可以使用多种方式来定位。例如可以使用文件系统路径(<code>FileSystemResource</code>)，也可以使用类路径(<code>ClassPathResource</code>)，或者使用<code>URL/URI</code>来表示位于网络上的资源(<code>UrlResource</code>)。不同的定位方式对应了不同的实现类。早期使用<code>xml</code>文件启动<code>Spring</code>，就是在启动过程中将<code>xml</code>文件的路径，包装成了一个<code>FileSystemResource</code>，用于读取其中定义的配置信息。</p><p>一些<code>Resource</code>接口的实现类也在资源包含的内容进行了声明。例如<code>BeanDefinitionResource</code>、<code>MultipartFileResource</code>。</p><p><code>Resource</code>接口有一个默认实现抽象类<code>AbstractResource</code>。</p><p><code>Resource</code>接口继承于<code>InputStreamSource</code>接口。<code>InputStreamSource</code>接口只声明了一个方法<code>getInputStream</code>，用于从资源中获取流对象，用于读取资源内容。</p><h2 id="beandefinition">BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config.<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AttributeAccessor</span>,BeanMetadataElement<br></code></pre></td></tr></table></figure><blockquote><p>A BeanDefinition describes a bean instance, which has propertyvalues, constructor argument values, and further information supplied byconcrete implementations.</p><p>This is just a minimal interface: The main intention is to allow aBeanFactoryPostProcessor to introspect and modify property values andother bean metadata.</p></blockquote><p><code>BeanDefinition</code>接口定义了<code>Spring</code>容器中所管理的<code>Bean</code>实例的配置元数据，包含了各种属性值、构造器的参数值。<code>BeanDefinition</code>实例和容器中的<code>Bean</code>实例一一对应。</p><p>除此外，还包括<code>parentName</code>、<code>beanClassName</code>、<code>scope</code>、<code>lazyInit</code>、<code>dependsOn</code><code>autowireCandidate</code>、<code>primary</code>、<code>factoryBeanName</code>、<code>factoryMethodName</code>、<code>initMethodName</code>、<code>destroyMethodName</code>、<code>role</code>、<code>description</code>、<code>resolvableType</code>、<code>singleton</code>、<code>prototype</code>、<code>abstract</code>、<code>resourceDescription</code>、<code>originatingBeanDefinition</code>等元数据的访问/修改。关于这些元数据的概念，建议参考源码，在此不赘述。</p><p><code>BeanDefinition</code>接口也有默认实现抽象类<code>AbstractBeanDefinition</code>。</p><p><code>BeanDefinition</code>继承了<code>AttributeAccessor</code>接口。<code>AttributeAccessor</code>接口声明了查询、访问、修改对象数据的方法。对于<code>BeanDefinition</code>来说，这里的数据指的就是元数据。使得对象的元数据可以在运行时动态地添加、获取和删除，从而提高了对象的灵活性和可扩展性。</p><p><code>BeanDefinition</code>继承了<code>BeanMetadataElement</code>接口。<code>BeanMetadataElement</code>接口声明了获取<code>BeanDefinition</code>来源的信息，例如来自xml标签、注解、配置类等可能包含<code>BeanDefinition</code>信息的对象。</p><p>综上，<code>BeanDefinition</code>包含了<code>bean</code>的元数据信息，并包含了查询/修改元数据，获取元数据来源的功能。此接口主要用于<code>BeanFactoryPostProcessor</code>中，对<code>BeanDefinition</code>进行动态调整。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>TermDefinition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Prototype</title>
    <link href="/2024/03/22/Design-Pattern-Prototype/"/>
    <url>/2024/03/22/Design-Pattern-Prototype/</url>
    
    <content type="html"><![CDATA[<p><strong>原型模式<code>(Prototype)</code></strong>是创建型模式中最简单、最不重要的一个设计模式。说不重要不是因为用不到，而是在实践过程中通常使用了其他更简便的方法进行了替代。前两篇设计模式在撰写时文本量超过了预期，本篇尽量言简意赅。</p><h2 id="场景">场景</h2><p>假设现在有个对象，需要根据这个对象中的属性，去创建新的同类对象。这么做的目的可能是重新创建对象过程复杂，直接从已有对象中复制相当于节省了许多步骤，可以<strong>快速获取大量同类对象</strong>。也可能是需要<strong>保留一份对象当前的状态</strong>。这样的需求十分常见。</p><p>在没有学过设计模式或一些现代开发技巧前，想当然的解决办法是，先通过<code>new</code>关键字新建一个对象，然后反复调用其<code>set</code>方法，设置值来自调用原型中的<code>get</code>方法。一些语言，例如C++，也可以通过拷贝构造函数，来完成对象的克隆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassA</span> <span class="hljs-variable">newObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>newObject.setA(oldObject.getA());<br>newObject.setB(oldObject.getB());<br>...<br></code></pre></td></tr></table></figure><p>这样做有时行得通，但需要满足一些前提条件。例如这需要被克隆的类需要提供所有字段的<code>get</code>和<code>set</code>的公共方法。例如客户端需要明确被克隆类的具体类型，才能使用<code>new</code>关键字创建具体类对象。客户端也需要知道关于被克隆类的细节，有哪些字段，增加了代码的耦合度。</p><p>原型模式提供了一个方案，<strong>基于一个已存在的对象克隆生成新的对象，而无需知道具体实现细节</strong>。</p><h2 id="原型模式">原型模式</h2><p>在不知道被克隆对象类型的情况下，需要根据运行时具体类型产生不同运行结果，通常会利用<strong>多态</strong>特性，并在具体类中定义克隆方法，在克隆方法中新建自身类的对象，并完成字段从原型到新对象的复制。由于方法定义在类中，因此也不涉及字段的访问权限问题，也做到了克隆过程和客户端分离的作用。</p><p>在<code>Java</code>中，所有类都继承于<code>Object</code>类。在<code>Object</code>类中，声明了一个克隆方法，方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p><code>protected</code>意味着所有继承的子类均可调用这个方法，<code>native</code>关键字则声明方法是由本地语言实现的，而不是由<code>Java</code>语言实现的。这个方法在<code>JDK</code>中的注释如下：</p><blockquote><p>The method clone for class Object performs a specific cloningoperation. First, if the class of this object does not implement theinterface Cloneable, then a CloneNotSupportedException is thrown. Notethat all arrays are considered to implement the interface Cloneable andthat the return type of the clone method of an array type T[] is T[]where T is any reference or primitive type. Otherwise, this methodcreates a new instance of the class of this object and initializes allits fields with exactly the contents of the corresponding fields of thisobject, as if by assignment; the contents of the fields are notthemselves cloned. Thus, this method performs a "shallow copy" of thisobject, not a "deep copy" operation. The class Object does not itselfimplement the interface Cloneable, so calling the clone method on anobject whose class is Object will result in throwing an exception at runtime.</p></blockquote><p>在每个对象上调用这个方法时，会先检查具体类是否实现了<code>Cloneable</code>接口，然后新建对象，并完成了所有字段的<strong>浅拷贝</strong>。这个<code>Object</code>类的<code>clone</code>方法，相当于帮我们完成了<code>new</code>对象和字段复制。</p><p>如果想通过这种方式完成对象克隆，需要在具体类中实现<code>Cloneable</code>接口。并重写<code>clone</code>方法，将访问修饰符改为<code>public</code>。方法体内可以简单调用<code>super.clone()</code>，也就是<code>Object</code>类的<code>clone</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">public</span> ClassA <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (ClassA)<span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 调用原型对象的clone方法</span><br><span class="hljs-type">ClassA</span> <span class="hljs-variable">newObject</span> <span class="hljs-operator">=</span> oldObject.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>上例代码中，对返回对象做了<strong>类型转换</strong>。原方法返回<code>Object</code>类型，重写时可以返回其子类类型。这是因为在此具体类中，<code>clone</code>方法返回对象的类型是确定的，可以在此直接完成类型转换，而不是由客户端执行类型转换。</p><p>在<code>java</code>之外的语言中，由于无法调用<code>Object</code>类的<code>clone</code>方法，也没有<code>Cloneable</code>接口，可以在方法体中通过调用空参或有参构造函数，再进行字段设置并返回来实现。以下是<code>C++</code>中的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ProductA</span>(<span class="hljs-type">const</span> ProductA&amp; other)&#123;<br>    <span class="hljs-comment">// 拷贝构造函数实现</span><br>    ...<br>&#125;<br><br><span class="hljs-function">ProductA* <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProductA</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>总之，最简单的原型模式就是在类中定义一个拷贝方法，在拷贝方法中完成创建自身类对象，属性复制，并返回对象的操作。</p><h2 id="抽象产品拓展">抽象产品拓展</h2><p>在上一章中，只涉及了一种产品类的复制。产品类的拓展模式在前些篇中已出现多次，被细分为抽象产品和具体产品。如果在需要客户端中使用抽象产品作为变量类型，调用克隆方法，则这意味着克隆方法需要声明在接口中。在<code>java</code>中，可以通过继承<code>Cloneable</code>接口，并声明返回接口类型的克隆方法。并在子类中实现这个克隆方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口实现</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    InterfaceA <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">private</span> String field;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductA</span><span class="hljs-params">(String field)</span> &#123;<br>        <span class="hljs-built_in">this</span>.field = field;<br>    &#125;<br>    <span class="hljs-comment">// 实现克隆方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (ProductA) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建接口类型对象，并调用clone方法</span><br>    <span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>(<span class="hljs-string">&quot;Draco&quot;</span>);<br>    <span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> objectA.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象产品也可以定义为抽象类。如果所有子类都是简单调用<code>Object</code>中的<code>clone</code>方法，则可以在抽象类中实现<code>Cloneable</code>接口，并提供方法默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类实现</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProduct</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">public</span> AbstractProduct <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (AbstractProduct) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProduct</span> &#123;<br>    <span class="hljs-keyword">private</span> String field;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductA</span><span class="hljs-params">(String field)</span> &#123;<br>        <span class="hljs-built_in">this</span>.field = field;<br>    &#125;<br>    <span class="hljs-comment">// 无需实现克隆方法，使用抽象父类中的默认方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建抽象类对象，并调用clone方法</span><br>    <span class="hljs-type">AbstractProduct</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>(<span class="hljs-string">&quot;Draco&quot;</span>);<br>    <span class="hljs-type">AbstractProduct</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> objectA.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果语言未提供类似<code>java</code>的<code>Cloneable</code>接口，则可以自定义一个接口，在接口中声明一个克隆方法，在抽象产品接口类中继承此接口，并在子类中实现克隆方法的具体实现。</p><h2 id="现代方法">现代方法</h2><p>由于将属性从一个对象复制到另一个对象，这个功能是如此的使用频繁，以至于许多工具类都提供类似功能。因此上文提到的原型模式，在实际使用中通常都被工具类的使用给替代了，使用频率并不高。</p><p>就<code>java</code>来说，最常用的就是<code>Apache BeanUtils</code>和<code>Spring BeanUtils</code>。通常认为后者在可用性和性能上更好，使用更多。这两者都是通过<strong>反射</strong>特性来完成对象间属性拷贝。<code>Spring BeanUtils</code>提供了静态方法，可以传入两个对象，即可把其中一个对象的属性复制到另一个当中。甚至传入的两个对象在类型上不需要有相同或继承的关系，只要有同名同类型的属性即可拷贝。<code>hutool BeanUtil</code>还提供了静态方法，可以传入返回对象的类型，直接获取拷贝后的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>(<span class="hljs-string">&quot;Draco&quot;</span>);<br><span class="hljs-comment">// 新建一个空对象</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>();<br><span class="hljs-comment">// Spring BeanUtils 完成属性复制</span><br>BeanUtils.copyProperties(objectA, objectB)<br>    <br><span class="hljs-comment">// hutool BeanUtil 完成对象创建和属性复制</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectC</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(objectA, ProductA.class)<br></code></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2><p>在不同语言中，数据类型大致可以分为<strong>基础数据类型</strong>和<strong>引用数据类型</strong>。成员变量中，基础数据类型会将实际数值储存在对象中，而引用数据类型存储的是对象的地址，通过这个地址可以访问对象的属性和方法。</p><p>在复制对象时，对于基础数据类型，是内存区域的复制，实际数值会在两个对象中各保存一份；而对于引用数据类型，如果只是引用的复制，复制完两个引用仍指向了同一个对象。这种对于复制模式，称为<strong>浅拷贝</strong>。与之对应的<strong>深拷贝</strong>，则是将每个引用数据类型的对象，在内存中新<code>new</code>了一份，并将返回的引用赋值给成员变量。</p><p>浅拷贝可能存在的问题是，复制完后，对其中一个对象进行了改动，另一个对象的内容也会随之改动，<strong>引用数据类型的成员变量不满足拷贝后的对象与原对象相互独立的特性</strong>。但由于深拷贝需要创建新的对象，会更耗费内存和时间。实际情况下，如果对象在复制完后，不会对其中引用数据类型进行变动，使用浅拷贝提升性能是可取的。</p><p>另外，对于一些不可变类型来说，由于每次变动都会新建一个对象，就算是引用数据类型，使用浅拷贝也是安全的。最典型的便是<code>String</code>、包装数据类型，如果对象中只包含基础数据类型、<code>String</code>和包装数据类型，那么使用浅拷贝也是安全的。</p><h2 id="总结">总结</h2><p>最简单的原型模式，就是在产品类中定义一个拷贝方法，在方法体中完成新建对象和属性的复制。</p><p>如果产品类需要拓展，细分为抽象产品和具体产品，则需要在抽象产品中定义拷贝方法，返回类型设定为抽象产品类，并在具体产品类中实现拷贝方法。</p><p>现代开发习惯中，通常使用工具类来完成对象的拷贝，实现原型模式。</p><p>浅拷贝性能好，但可能存在拷贝后的对象与原型不独立的问题。需要根据实际情况来选择。如果成员变量都是不可变对象，则可以安全地使用浅拷贝。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Builder</title>
    <link href="/2024/03/13/Design-Pattern-Builder/"/>
    <url>/2024/03/13/Design-Pattern-Builder/</url>
    
    <content type="html"><![CDATA[<p>本篇简单描述生成器模式<code>(Builder)</code>的结构和特征，并着重讨论<strong>为什么要使用生成器模式</strong>的思考。</p><h3 id="场景">场景</h3><p><strong>生成器模式</strong>是一种<strong>创建型模式</strong>，目的是创建一个对象。通常创建对象，可以通过<code>new</code>关键字调用构造函数，并在构造函数中传入需要的参数。这在对象结构简单时十分容易。但当类的成员变量变得众多类型复杂，且某些参数可以不是必输的时候，会变得复杂。在一些语言，例如<code>Python</code>中，可以通过提供方法的<strong>默认参数</strong>，避开这个问题，来满足不同场景下的构造函数调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">&quot;default_name&quot;</span>, age=<span class="hljs-number">0</span></span>):<br>        self.name = name<br>        self.age = age<br><br>obj1 = MyClass()<br>obj2 = MyClass(<span class="hljs-string">&quot;Draco&quot;</span>)<br>obj3 = MyClass(age=<span class="hljs-number">35</span>)<br>obj4 = MyClass(<span class="hljs-string">&quot;Draco&quot;</span>, <span class="hljs-number">35</span>)<br></code></pre></td></tr></table></figure><p><code>Java</code>不支持方法默认参数，但可以通过<strong>函数重载</strong>，定义多个不同参数数量，种类组合的构造函数，来适应这种参数非必输时，使用构造函数来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">MyClass() &#123; ... &#125;<br>MyClass(String name) &#123; ... &#125;<br>MyClass(Integer age) &#123; ... &#125;<br>MyClass(String name, Integer age) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>但这会出现一些问题。当对象有<code>n</code>个成员变量需要初始化，那么需要<span class="math inline">\(2^n\)</span>个构造函数。这种指数增长的构造函数显然是不合理的。并且当相邻两个参数为相同类型时，去掉其中任意一个参数会导致方法签名完全一致，编译器无法区分两个方法的区别，会显示编译错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">MyClass() &#123; ... &#125;<br>MyClass(String name) &#123; ... &#125;<br>MyClass(String age) &#123; ... &#125; <span class="hljs-comment">// 编译错误，重复定义</span><br>MyClass(String name, String age) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>又或者不提供所有的构造函数，只提供一个全参的构造函数，如果某个参数无需初始化时，则在构造时将对应参数位置传入<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">MyClass(String name, String address, Integer age) &#123; ... &#125;<br><span class="hljs-comment">// 不需要初始化的参数对应位置传入null</span><br><span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&quot;Draco&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">35</span>);<br></code></pre></td></tr></table></figure><p>当对象的成员变量较多时，会产生一个参数列表非常长的构造函数调用。程序员需要记住每个位置的参数的含义，并在构造时确保不出错。当然现代<code>IDE</code>都提供了参数提示的功能，在输入参数时敲入逗号，或者鼠标悬停至参数位置时，会提供参数列表变量名和类型的提示。但超长的构造函数总归是不方便也不优雅的。</p><p>至于为什么不通过新建对象后，重复调用<code>set</code>方法，这部分原因放到后文再来谈。</p><p>为了解决上述问题，引入了<strong>生成器模式</strong>。</p><h3 id="最简单的生成器模式">最简单的生成器模式</h3><p>类似于<strong>工厂模式</strong>，<strong>生成器模式</strong>也使用了一个独立的类，将对象的创建过程从产品类中抽取出来。<strong>生成器模式提供了逐步构建复杂对象的方法</strong>。将构造函数的一次性调用，拆解成了对生成器设置方法的多次调用。</p><p>这个生成器类可以定义在独立的<code>.java</code>文件中。也可以定义在产品类中，通常是<code>public static class</code>的形式。生成器类通常拥有和原产品类相同的，或其中一部分成员变量，用于作为调用产品类构造函数的参数。在生成器类中，提供了设置成员变量的方法，通常这个方法的返回值类型会被设置为生成器类本身。这样生成器类对象，可以链式调用设置生成器中的成员变量，如此可以<strong>逐步构建复杂对象</strong>，而不是直接调用构造函数本身。最后生成器类还提供了生成方法，调用产品类构造函数，返回产品类对象。在生成方法中，还可以包含一些校验逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用lombok注解生成全参构造函数</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br>    ...<br>    <span class="hljs-comment">// 通过静态内部类形式定义生成器类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassBuilder</span> &#123;<br>        <span class="hljs-comment">// 具有产品类全部或部分成员变量</span><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> Integer age;<br>        <span class="hljs-keyword">private</span> String address;<br>        <span class="hljs-comment">// 提供set方法，设置成员变量</span><br>        <span class="hljs-keyword">public</span> MyClassBuilder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 提供生成方法，返回产品对象</span><br>        <span class="hljs-keyword">public</span> MyClass <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span>(StringUtil.isEmpty(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;姓名不得为空&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 调用产品类构造函数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(name, age, address);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyClassBuilder</span> <span class="hljs-variable">myClassBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassBuilder</span>();<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> myClassBuilder.setName(<span class="hljs-string">&quot;DracoYu&quot;</span>)<br>                .setAge(<span class="hljs-number">35</span>)<br>                .setAddress(<span class="hljs-string">&quot;Hangzhou&quot;</span>)<br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure><p>以上便是生成器模式的最简化的结构。究其核心部分，是和产品类相同的<strong>成员变量</strong>，提供了设置成员变量的<strong>设置方法</strong>，以及创建对象的<strong>生成方法</strong>。这样的结构在第三方库中可以经常看到，但这和大部分教材中描述的生成器模式还是有些区别。接下来描述教材中的生成器模式，并描述相对于最简单的生成器模式，多了些什么东西。</p><h3 id="复杂些的生成器模式">复杂些的生成器模式</h3><p>在上一节中，描述了最简单的生成器结构，创建了一种产品类。对于单个产品类来说，这样子的结构是足够且合适的。</p><p>但设计模式考虑代码<strong>拓展性</strong>，如果多个产品类具有类似的成员变量和构建过程，则这些产品类的构建过程可以被抽象为生成器接口/抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Builder</span> &#123;<br>    Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>;<br>    Builder <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span>;<br>    Builder <span class="hljs-title function_">setSalary</span><span class="hljs-params">(Double salary)</span>;<br>    Builder <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span>;<br>    Person <span class="hljs-title function_">build</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当多个产品类实现了共同的接口或继承于共同的父类，那么在生成器中可以提供<code>build</code>生成方法，并返回接口/父类类型。如果没有共同的接口或父类，则<code>build</code>方法需要在每个具体<code>builder</code>中单独定义。</p><p>定义完生成器接口后，需要针对每一个产品类，定义对应的具体生成器类，这点和<code>工厂方法</code>模式很像。区别是工厂方法通常只声明了创建抽象产品的方法，而在生成器接口中通常还声明了多个产品共同构建过程的设置方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaffBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-meta">@override</span><br>    builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        ...<br>    &#125;<br>    ...<br>    <span class="hljs-meta">@override</span><br>    Person <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回具体产品类对象，其中Staff类实现了Person接口</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Staff</span>(name, age, salary, address);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Staff</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Builder</span> <span class="hljs-variable">staffBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaffBuilder</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">staff</span> <span class="hljs-operator">=</span> staffBuilder.setName(<span class="hljs-string">&quot;DracoYu&quot;</span>)<br>                .setAge(<span class="hljs-number">35</span>)<br>                .setSalary(<span class="hljs-number">0</span>)<br>                .setAddress(<span class="hljs-string">&quot;Hangzhou&quot;</span>)<br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时，客户端通过实例化具体的生成器类，并调用其中由生成器接口声明的设置方法和生成方法，获取产品类对象。</p><p>但此刻，客户端类仍体现出对生成器接口过度的依赖：客户端需要了解生成器接口声明的设置方法。如果多处对生成器类的设置方法调用，具有相似的结构，则可以将这些对于生成器设置方法的调用，抽取到专门的类当中，这个类通常称为<code>主管类(director)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>    <span class="hljs-comment">// 可以使用成员变量来管理生成器对象</span><br>    <span class="hljs-keyword">private</span> Builder builder;<br><span class="hljs-comment">// 通过构造函数注入生成器对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.builder = builder;<br>    &#125;<br><span class="hljs-comment">// 由于上述示例代码每次调用设置方法都不相同，此处没有遵循上面的例子</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>    &#125;<br>    <span class="hljs-comment">// 另一套设置方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">anotherConstruct</span><span class="hljs-params">()</span> &#123;<br>        builder.buildPartA();<br>        builder.buildPartC();<br>        builder.buildPartD();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Builder</span> <span class="hljs-variable">builderA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderA</span>();<br>    <span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(BuilderA);<br>    director.construct();<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> builderA.build();<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，整个生成器模式的结构应该和大部分设计模式教材中一致，总结一下其中包含的部分。</p><ul><li>产品：需要创建的对象，此处不分区抽象/具体产品。</li><li>生成器接口/抽象生成器：抽象了多种产品构建过程中的相同部分，声明为设置方法。设置方法通常返回生成器接口本身。</li><li>具体生成器：一个具体生成器对应一个具体产品，实现了生成器接口中声明的设置方法。并提供生成方法创建具体的产品对象。</li><li>主管类：通过生成器接口，调用了生成器的具体设置方法。</li></ul><h3 id="生成器模式的各种变体">生成器模式的各种变体</h3><p>由于生成器模式有不同的展现方式，在网上查资料时，虽然各种文章都在描述生成器模式，但感觉每篇文章讲的都不是同一个东西。这可能与原版生成器模式（四人帮提出的23种设计模式）过于复杂，在实践过程中产生了各种简化版本和变体有关。也可能是因为<code>builder</code>这个概念被滥用，而导致发生了众多歧义。笔者结合自己看过的文章，以及查阅<code>JDK</code>和各种第三方库中的生成器源代码，来对不同实现做个列举。</p><ul><li>简单生成器：大部分情况下，产品类不需要拓展，因此也不需要生成器接口，主管类也可以省略。此时只新增了一个生成器类，这个类可以通过静态内部类形式定义在产品类本身代码中。<strong>简单生成器是实践中最常见的形式</strong>。</li><li>产品类：多个具体产品类可以实现相同接口，也可以不实现。只要有相似的构建过程，完全不相同的产品类也可以使用相同的生成器接口。这是因为生成器接口只定义了构建过程，而具体实现由具体生成器类实现。</li><li>生成器接口/抽象生成器：如果生成的产品实现了同一接口，可以像<code>工厂方法</code>那样定义生成方法返回产品接口类型。如果没有，则可以让具体生成器定义生成方法的返回类型。此时主管类中也无法通过生成器接口调用生成方法，转由客户端来调用。</li><li>具体生成器：具体生成器可以拥有和产品类相同的成员变量，也可以用产品作为成员变量。如果以产品作为成员变量，需要在构造时或提供初始化方法新建产品对象，并赋值给成员变量。调用生成方法时将成员变量返回即可。</li><li>主管类：大部分情况下可以省略，对设置方法的调用通常转由客户端来完成。一方面是因为大部分设置方法的调用是定制的，无法确定每个产品设置方法的调用顺序，次数，以及参数，难以抽取公共方法。另一方面客户端类对生成器接口的依赖是可以被接受的。</li></ul><h3 id="为什么使用生成器模式">为什么使用生成器模式</h3><p>笔者在学习完生成器模式后，很长一段时间无法体会到其实用性。浏览网上众多资料，给出的原因大多归于这么几类：</p><ol type="1"><li>避免过于复杂的构造函数调用，提供了逐步构建复杂对象的方法</li><li>链式调用</li></ol><p>对于原因1，另一个想当然的解决方法就是调用空参构造函数，并在新建完对象后，反复调用<code>java bean</code>规范的<code>set</code>方法，便可以达成逐步构建复杂对象的目的。对于原因2，可以手动将<code>set</code>方法设置为返回对象本身（这会破坏<code>java bean</code>规范），便可实现链式调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-comment">// set方法返回对象本身</span><br>    <span class="hljs-keyword">public</span> MyClass <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-comment">// 满足逐步构建、链式调用</span><br>        myObject.setName(<span class="hljs-string">&quot;Draco&quot;</span>)<br>                .setAge(<span class="hljs-number">35</span>)<br>                .setAddress(<span class="hljs-string">&quot;Hangzhou&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>如此来看生成器模式仿佛是多余的，所有的特性都可以通过其他更简便的形式来实现。</p><p>会产生这样的想法，是因为上述例子中，将产品的设置方法、生成方法都做了简化。上述生成器中的设置方法，除了返回生成器本身，和<code>java bean</code>的<code>set</code>方法无异。而实际情况中，<strong>设置方法可能复杂包含逻辑</strong>的。例如设置方法会对输入进行校验，可以联动调整多个属性，或者向一个<code>Collection</code>中反复添加元素。这些功能不是简单的<code>setter</code>能实现的。如果在产品类中添加太多创建对象的逻辑规则，则又违反了表现和构建相分离的原则（单一职责原则）。</p><p>另一个十分重要的原因是，在<code>JDK</code>和许多第三方库中使用了<strong>不可变对象</strong>。不可变对象<code>(immutable objects)</code>是指一旦创建后，其状态就不能被修改的对象。这意味着对象的所有成员变量都是不可变的，它们的值在对象的整个生命周期内保持不变。</p><p>不可变对象有许多优秀特性，例如线程安全，无副作用等。不过这不是本篇讨论的重点。要创建一个不可变对象，最简单的是将所有成员变量声明为<code>private</code>和<code>final</code>，并且不提供修改成员变量的公共方法<code>(setter)</code>。由于成员变量被声明为<code>final</code>，则必须要在构造函数中进行初始化，否则会报编译错误。<strong>不可变对象无法先新建对象，再调用设置方法的形式去为对象赋值</strong>。</p><p>从这个视角看，生成器替不可变对象<strong>暂存了成员变量</strong>，并提供了基于成员变量的<strong>一些设置方法、校验规则</strong>。如果生成器的目的是创建不可变对象，则无法使用产品类作为成员变量的变体。</p><p>一个体现了这个原因，最常用的生成器便是<code>StringBuilder</code>。在<code>java</code>中，<code>String</code>类为不可变类，所有的<code>String</code>对象在实例后就不会再变化，所有涉及字符串操作，都是通过创建新<code>String</code>对象来实现。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;2&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果暂不考虑常量池，这行代码一共存在了三个<code>String</code>对象，分别为<code>"1"</code>，<code>"2"</code>，<code>"12"</code>。如果每一次字符串操作都会新实例化一个<code>String</code>，多次的字符串操作所带来的申请、初始化内存操作是性能低下的。<code>String</code>本身是个字节数组，<code>StringBuilder</code>通过一个字节数组成员变量，并提供了对字节数组增删改的操作，使得进行字符串操作时，无需每次操作都生成一个<code>String</code>对象。最后，调用<code>toString()</code>方法，来将生成器中的数据用来构造<code>String</code>对象。</p><p>此外，生成器模式还体现了一种，维护对象<strong>原子性、一致性、有效性</strong>的作用。如果采用新建对象再设置的方式，则对象可能处于无效状态。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid, not good</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid, not good</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure><p>创建了一个长方形对象。对于一个长方形来说，长和宽都是必须的，不存在没有长或者没有宽的长方形。新建对象后再设置的过程中，不可避免对象会处于这种无效的状态。为了避免这种无效的状态，必须要在构造函数中提供所有必须的参数。</p><p>而在生成器的生成方法中，可以通过参数校验，来限制这种无效对象的产生，保证产生的不可变对象都是有效的。</p><h3 id="总结">总结</h3><p><strong>生成器模式</strong>是一种<strong>创建型设计模式</strong>，用于将复杂对象的构建过程与其表示分离，以便可以按步骤构建对象，同时隐藏其构建细节。</p><p>最常见、最简单的生成器模式只包含一个产品类，一个生成器类，并且通常将生成器类以静态内部类定义在产品类中。</p><p>生成器类通过提供设置方法和生成方法，提供了逐步构建复杂对象的方法。</p><p>生成器模式可以通过新增抽象产品、抽象生成器、主管类来进行拓展。</p><p>笔者认为生成器模式最重要的目的是保证对象的<strong>原子性、一致性、有效性</strong>。通常和<strong>不可变对象</strong>一起使用。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Factory-Pattern</title>
    <link href="/2023/11/03/Design-Pattern-Factory-Pattern/"/>
    <url>/2023/11/03/Design-Pattern-Factory-Pattern/</url>
    
    <content type="html"><![CDATA[<p>接下来就是介绍具体的比较经典的设计模式。</p><p>按照常规的分类方式，设计模式分为<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。创建型模式关注对象的<strong>创建</strong>，结构型模式关注类/对象之间的<strong>关系</strong>，行为型模式关注对象之间的<strong>交互</strong>。</p><p>实际上，结构型模式和行为模式的边界很模糊。不同对象/类之间的关系限制了之间的交互模式，交互模式又依赖于对象之间的关系。总之，结构型模式关注系统的<strong>静态结构</strong>，用于构建对象和类之间的关系，而行为型模式关注系统的<strong>动态行为</strong>，用于管理对象之间的交互以实现特定行为。</p><p>本系列首先从创建型模式开始介绍，这是相对简单，使用频率更高的设计模式。创建型模式包含<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>生成器模式</strong>、<strong>原型模式</strong>、<strong>单例模式</strong>。</p><h2 id="工厂模式">工厂模式</h2><p>通常来说，工厂模式包括<strong>简单工厂</strong>（不被包含在许多设计模式教材中）、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。在一些书籍中可能还会包含其他模式，本篇只介绍这三种模式。</p><p>归根结底，工厂模式是一种创建型模式，其根本目的是<strong>创建对象</strong>。在开发中，最常见的新建对象的方式是通过<code>new</code>关键字，后面跟着构造函数的调用，使用一个目标类型的变量来接受新建对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br></code></pre></td></tr></table></figure><p>如果使用<strong>默认构造函数</strong>（无其他明确定义的构造函数，自动生成的无参构造函数），生成的对象属性默认初始化为<code>null</code>，通常需要在后续代码中调用对象的<code>setter</code>给对象赋值。<strong>新建对象，并对其属性赋值的过程统称为创建对象</strong>。</p><p>如果在代码中，多处地方都使用了此类<code>new</code>之后<code>.setX()</code>的代码来创建对象，并且代码有非常多重复的地方，便可以新建一个类专门负责这类对象创建的过程，这个类就是<strong>工厂类</strong>。这样做的好处是，如果这个类发生变动，例如新增/删除了一个属性，则不需要去追溯所有创建此类对象的地方，而只需在一个<strong>统一入口</strong>中进行调整，以便于代码维护。这也符合<strong>单一职责</strong>原则，即使用这些对象的地方不该拥有创建对象的职责，否则代码会变得更耦合。</p><p>额外思考一下，是否一定需要新建一个类来负责对象创建过程？能否把这个创建过程写在类的定义中，例如类的构造函数或静态方法中，是否也能实现<strong>创建对象统一入口</strong>的特性？笔者认为这是可行的。但当对象创建过程复杂时，例如需要查配置文件、查数据库表、访问网络时，把这些实现写在一个需要在多处使用的<code>Java Bean</code>中，这个<code>Bean</code>会添加很多依赖，这不符合<strong>模块化编程</strong>的思想，也增加了<strong>创建过程</strong>和<strong>使用过程</strong>的耦合。而静态方法中没法依赖非静态的属性，写法上会多很多限制。并且当涉及代码扩展时，会希望有一个统一的入口去创建这些有些相似但不同的类，而不是分布在每个类的构造函数中。</p><p>所以当类简单且不涉及扩展时，使用构造函数或静态方法来创建对象是可行的；但涉及创建过程复杂和类的拓展性时，工厂模式是更为合适的实践。</p><p>当涉及<strong>类的拓展</strong>时，为了保证代码的<strong>通用性</strong>，通常会使用接口来表示一系列具有类似功能的类。当工厂类中创建对象方法，返回的不是某个特定类的对象，而是一系列实现某个对象的接口，那么认为这就是工厂模式。此时在实际使用这个对象的地方，可以使用<strong>接口类型</strong>作为变量类型。如此这样，当替换/拓展了具体对象的类型，只要是实现了同一个接口，在使用这个对象的地方（例如使用变量接收创建的对象，调用对象的方法等，通常称为<code>客户端</code>）不需要改变代码就能正常运行，代码具有良好的拓展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个客户端代码是通用的，可以拓展createA()方法返回的具体类型，只要这个具体类实现了InterfaceA接口，在客户端不修改其他代码就能正常运行</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> factoryA.createA();<br>objectA.interfaceMethodA();<br></code></pre></td></tr></table></figure><h3 id="简单工厂">简单工厂</h3><p>上文描述的场景，基本上就是简单工厂的核心了。为了总结简单工厂的特征，对上文中提到的一些概念进行命名。</p><ul><li><p><strong>抽象产品接口</strong>：为了描述一系列具有相似功能的具体产品类定义的接口，相似部分通过声明接口方法来表示。在客户端中使用产品接口，可以不改变客户端代码，即可实现功能的拓展，符合开闭原则。</p></li><li><p><strong>具体产品类</strong>：产品接口的具体实现类。需要进行扩展时，可以定义一个新的具体产品，实现产品接口，并在工厂类的创建方法中新增对应的实例化此类的代码。</p></li><li><p><strong>工厂类</strong>：包含了创建产品对象的方法，返回一个产品接口类型的对象，根据客户端的需求来创建具体产品类对象</p></li><li><p><strong>客户端</strong>：调用工厂类方法来创建对象，并使用产品接口作为变量类型接收返回的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 产品接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span><br><span class="hljs-comment">// 具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> <br><span class="hljs-comment">// 工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creater</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">(String name)</span>;<br>&#125; <br><span class="hljs-comment">// 客户端</span><br>&#123;<br>...<br><span class="hljs-comment">// 使用产品接口作为变量类型</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> Creater.createInterfaceA(<span class="hljs-string">&quot;classA&quot;</span>);<br><span class="hljs-comment">// 调用产品接口中声明的方法</span><br>objectA.interfaceMethodA();<br>...<br>&#125; <br></code></pre></td></tr></table></figure><p>对于简单工厂，“简单”二字体现在工厂类中，通常使用一个<strong>静态公共方法</strong>，并通过接受一个入参，根据入参来决定具体创建哪个具体产品类。这在代码中通常由一系列的<code>if else</code>或<code>switch</code>语句来实现。如果创建对象<strong>过程复杂</strong>，需要<strong>依赖其他对象</strong>，静态方法可能无法满足，那么写成一般方法，并在客户端中完成工厂类的实例化，再来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简单工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creater</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ClassA&quot;</span>.equals(name)) &#123;<br>object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ClassB&quot;</span>.equals(name)) &#123;<br>object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB</span>();<br>&#125; ...<br><span class="hljs-keyword">return</span> object;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能这样描述还无法感受简单在哪。在后文介绍工厂方法和抽象工厂时，对比不同工厂模式的工厂类怎么处理，会有更直观的感受。</p><p>对于简单工厂来说，如果需要进行拓展，需要：</p><ol type="1"><li>新建一个具体产品类并实现产品接口</li><li>工厂类中的创建方法中新增一个<code>if else</code>分支，用于返回新建的具体产品类对象</li><li>客户端中调整调用创建方法时的入参</li></ol><h3 id="工厂方法">工厂方法</h3><p>在简单方法中，所有具体产品类的创建方法都在同一个工厂类中，因此拓展新具体产品时，不可避免地会对已有代码进行修改，违反了<strong>开闭原则</strong>。而在客户端中，由于只存在一个工厂类，不需要利用多态的特性，所以直接调用工厂类的静态方法。</p><p>要避免扩展时对已有代码的修改，这意味着工厂的创建方法也需要被拓展，<strong>工厂类本身也需要抽象</strong>。</p><p>因此相对于简单工厂，工厂方法对工厂类进行了抽象，新增以下定义</p><ul><li><strong>抽象工厂接口/抽象类</strong>：声明了创建产品接口的方法。如果除创建产品接口方法外，多个具体工厂类有许多类似代码，可以把这些代码抽取到工厂抽象类中（通常认为接口不提供方法实现），提供这些公共方法的默认实现。抽象类的特性也限制了其无法被实例化，并且子类必须实现声明的抽象方法。某种程度上可以理解为提供默认方法的接口。</li><li><strong>具体工厂类</strong>：具体工厂是抽象工厂的实现类/子类，实现了抽象工厂中定义的工厂方法</li></ul><p>与简单工厂不同，工厂方法通过抽象工厂来创建对象。这意味着客户端使用的是抽象工厂，而不是具体工厂类。相对于简单工厂中调用工厂类的静态方法，进一步降低了代码耦合。</p><p>抽象工厂这个词可能会产生歧义。前文提到“工厂模式包括<strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>”中的抽象工厂是指抽象工厂<strong>设计模式</strong>，而在此处定义的抽象工厂是<strong>接口/抽象类</strong>，是工厂方法模式中类组织关系中的一个<strong>角色</strong>。至于为什么工厂方法模式包含抽象工厂的概念，还要叫工厂方法，就不是本文要讨论的。设计模式的命名沿用了四人帮的著作《设计模式：可复用面向对象软件的基础》。</p><figure><img src="/img/factory-method.png" alt="工厂方法类图" /><figcaption aria-hidden="true">工厂方法类图</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CreaterInterfaceA</span> &#123;<br>InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 具体工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreaterClassA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CreaterInterfaceA</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">abstractCreater</span> &#123;<br>    <span class="hljs-keyword">abstract</span> InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span>;<br>    ...<br><span class="hljs-comment">// 一些其他公共方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sharedMethod</span><span class="hljs-params">()</span>;<br>    ...<br>&#125;<br><span class="hljs-comment">// 具体工厂类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreaterClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">abstractCreater</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 客户端</span><br>&#123;<br>    <span class="hljs-comment">// 实例化工厂类，使用工厂接口类型接收</span><br><span class="hljs-type">CreaterInterfaceA</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreaterClassA</span>();<br>...<br>InterfaceA = factory.createInterfaceA()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码来看，由于通过<code>new CreaterClassA()</code>实例化具体工厂类，客户端仍含有对具体工厂类的依赖。但可以定义成员变量，并通过<code>IoC</code>注入，那么在客户端中将不会有关于任何<code>CreaterClassA</code>的依赖，降低了代码的耦合度。</p><p>对于工厂方法来说，如果需要进行拓展，需要：</p><ol type="1"><li>新建一个具体产品类并实现产品接口，这和简单工厂是一样的</li><li>需要新增一个具体工厂类，并实现抽象工厂接口的创建对象方法</li><li>在客户端中实例化具体工厂类，如果是通过依赖注入则不需要改动客户端</li></ol><h3 id="抽象工厂">抽象工厂</h3><p>在工厂方法模式中，抽象工厂定义了一个创建某种抽象产品的方法。在实际开发场景中，某个抽象产品可能并不是单独使用，还需要与其他有关联的抽象产品<strong>一起使用</strong>。例如在GUI相关代码中，按钮是一个抽象产品，文本框也是一个抽象产品。对于按钮这个抽象产品来说，有对应的Windows按钮具体产品实现，也有Mac按钮具体产品实现。文本框同理。对于程序来说，绘制GUI需要多种组件。但在一个应用程序中，创建这些组件对象，使用的都是同一个平台的具体产品实现。几乎不出现使用Windows的按钮，但使用Mac的文本框这种情况。这意味着具体产品可以通过<strong>平台维度进行分类</strong>。</p><table><thead><tr class="header"><th>平台</th><th>按钮抽象产品</th><th>文本框抽象产品</th></tr></thead><tbody><tr class="odd"><td>Windows</td><td>Windows按钮具体产品</td><td>Windows文本框具体产品</td></tr><tr class="even"><td>Mac</td><td>Mac按钮具体产品</td><td>Mac文本框具体产品</td></tr></tbody></table><p>如果沿用工厂方法模式，需要创建按钮抽象工厂接口、文本框抽象工厂接口、以及Windows按钮具体工厂类、Mac按钮具体工厂类、Windows文本框具体工厂类、Mac文本框具体工厂类。这是只有两种平台、两种抽象产品的情况下，当产品和平台数量变多时，具体工厂类的数量会<strong>急剧增加</strong>。</p><p>对于产品来说，每个产品都要有对应的代码，具体产品类的数量是无法减少的。而对于具体工厂类来说，由于某些产品会一起使用，而某些产品不可能一起使用。<strong>可以把能一起使用的抽象产品的创建都定义在同一个抽象工厂中</strong>。如此一来，抽象工厂不是只创建一种抽象产品，而是多种相关联的抽象产品。具体工厂类的数量可以从<code>抽象产品种类 * 平台种类</code>压缩至<code>平台种类</code>。在客户端调用抽象工厂的方法也从创建一种产品，变成创建多种相关的产品。</p><figure><img src="/img/abstract-factory.png" alt="抽象类图" /><figcaption aria-hidden="true">抽象类图</figcaption></figure><p>对于抽象工厂来说，如果需要进行拓展，通常是新增一种平台，需要：</p><ol type="1"><li>实现所有抽象产品的具体产品类</li><li>新增一种具体工厂类，实现所有抽象产品的创建方法，返回1中新增的具体产品类</li></ol><p>总的来说，抽象工厂模式，适用于存在<strong>多种抽象产品相互关联</strong>，可以通过<strong>某种维度对具体产品类进行分类</strong>的场景（上文中的操作系统平台）。在抽象工厂中，声明创建一系列抽象产品的创建方法，并在每个维度的具体工厂中实现这些方法。</p><h2 id="总结">总结</h2><p>介绍了工厂模式，工厂模式包括<strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。</p><p>在工厂模式中，几个重要的概念为：抽象产品、具体产品、抽象工厂、具体工厂、客户端。</p><p>在简单工厂中，不存在抽象工厂，直接在具体工厂中提供了根据入参创建多种具体产品对象的创建方法，以抽象产品类型返回。这个方法通常是静态方法。客户端通过依赖具体工厂类来创建对象。</p><p>在工厂方法中，抽象工厂中定义了创建一种抽象产品的方法，需要在具体工厂中实现。客户端通过抽象工厂，调用创建方法来创建一种抽象产品对象。</p><p>在抽象方法中，抽象工厂中定义了一系列创建相关联的抽象产品的方法，一个具体工厂需要实现所有抽象产品的创建方法。客户端通过抽象工厂，调用创建方法来创建一系列抽象产品对象。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-SOLID</title>
    <link href="/2023/11/01/Design-Pattern-SOLID/"/>
    <url>/2023/11/01/Design-Pattern-SOLID/</url>
    
    <content type="html"><![CDATA[<p>距离上一次写博客已经过去了三个多月，一直忙于工作。</p><p>上次说到，设计原则是使得代码拥有更好复用性和拓展性的指南针，是一种基于优秀代码的经验总结。既然是经验总结，不同学者必然存在着不同归纳角度。上次提到的<strong>封装变化</strong>、<strong>面向接口而不是面向实现</strong>、<strong>组合优于继承</strong>原则是一种归纳，这次要讲的<strong>SOLID</strong>原则也是一种归纳。这些原则本是并列关系，但实际又会觉得互相关联、交融。因为本身可能都是对同一件事情，不同角度的描述。</p><p>SOLID原则是五条原则的简称，首次提出于罗伯特·马丁的著作《敏捷软件开发：原则、模式与实践》。每次遇到这类把多个原则或者理论，缩写成某个单词，我总是想，这是作者先想出来，然后发现这些原则凑巧就能拼成一个单词，还是在想原则名的时候，就在往这个单词上凑。</p><h2 id="single-responsibility-principle-单一职责原则">SingleResponsibility Principle 单一职责原则</h2><blockquote><p>一个类应该只有一个引起它变化的原因，或者说一个类应该只有一个职责。</p></blockquote><p><strong>改变的原因</strong>非常拗口，这是马丁对于职责的定义。使用更为通俗的说法，一个类应该只有一组互相关联的功能和属性（好像更复杂了）。如果一个类里面，不同的方法和属性没有互相依赖的关系，那么可以认为这个类具有了多个职责，可以将这些没有依赖的平行关系，拆分成多个类。</p><p>但这个原则最令人困惑，也是最模棱两可的地方，是很难界定某些功能和属性是否归属于相同职责。职责的界定依赖于人们对功能的主观理解，和划分的粒度。</p><p>不论如何，这个原则所表达的思想是，一个类里如果代码太多，可能就需要考虑是不是能拆成多个类。这与<strong>封装变化原则</strong>有相似的地方。封装变化原则将变化部分抽取为方法或类。有一种类内变化的部分负责一个职责，不变的部分负责另一个职责的感觉，最终实现单一职责原则的效果。</p><p>拆分成多个类的好处是：</p><ol type="1"><li>提高代码可读性。当你想要了解一个功能时，需要关注的内容变得更少</li><li>降低变更风险。修改代码时，可以减少影响到其他职责的风险。</li><li>增加代码的复用性。拆分出的类可以在多处被使用，而不用担心引入了过多不需要的功能。</li></ol><h2 id="openclosed-principle-开闭原则">Open/closed Principle开闭原则</h2><blockquote><p>对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的</p></blockquote><p>开闭原则关注在对代码扩展功能时，保持原有功能不发生变动。<strong>开放</strong>意味着拓展功能应该是容易且方便的，<strong>封闭</strong>意味着拓展时不应该改动已有代码的运行结果。</p><p>代码开发过程中，经常性会对已有功能进行拓展。拓展可能会对已有功能进行破坏，需要通过回归测试来确认改动的影响。一种解决办法是，每次拓展功能时都新增代码，不使用任何已经存在的代码。这样可以确保拓展的功能与源代码互不影响，但会导致代码复用率低。编程通常采用模块化编程和分层模型，就是为了提高代码的复用率。因此基本不采用这种办法。</p><p>比较合理的解决办法是，可以通过<strong>定义接口</strong>的形式，在方法中使用接口类型来接受变量。这样无需改动方法体本身，通过改变传入方法的参数，即可改变方法的实际行为，对功能进行了拓展，原有的功能也不会受到影响。这其实也体现了<strong>面向接口而不是面向实现</strong>的原则。另一种方法是<strong>使用继承</strong>，使得子类可以复用父类中的定义的方法，并在父类基础上进行调整。</p><p>开闭原则最关键的好处：</p><p>1.减少了回归测试的任务量</p><p>2.提高了代码的复用率</p><p>3.拓展新功能方便。如果在定义方法/成语变量时，使用接口作为参数类型，那么拓展功能只需改变传入方法或构造函数的参数，即可完成功能拓展。</p><h2 id="liskov-substitution-principle-里氏替换原则">Liskov SubstitutionPrinciple 里氏替换原则</h2><blockquote><p>派生类（子类）对象可以在程式中代替其基类（超类）对象。</p></blockquote><p>里氏替换原则是针对继承特性的原则。程序员通过继承，可以进行代码复用，在子类中复用其父类中定义的方法。在代码中，主要是通过调用父类中定义的公共方法，使用父类实例。里氏替换原则要求使用父类对象的地方，替换成子类对象，程序表现一致。</p><p>根据多态的特性，子类的对象可以赋值给父类的变量类型，并且只允许调用父类中定义的公共方法。如果子类中对父类定义的方法进行了重写，则实际会调用子类中重写的方法。要保证替换后程序行为一致，这意味着父类中实现的公共方法，不应该被子类重写。</p><p>稍宽松些，允许子类重写，需要保证逻辑符合父类中的定义，其方法的参数列表应该一致或更宽松，其返回类型应该兼容父类方法的返回类型。也就是父类方法中接受的参数，需要可以赋值给子类方法，子类方法中返回的对象，需要可以赋值给父类的返回类型。还有子类不能抛出比父类更多的异常类型、子类不应该加强其前置条件、子类不能削弱其后置条件等等要求。</p><p>由于在子类中重写父类方法会处处受限，因此更多的做法是不重写。或者直接将父类的方法定义为抽象方法，这样代码中就不会存在父类对象（抽象类不可实例化），自然也不涉及替换的问题了。</p><p>在开闭原则中提到，继承是一种遵循开闭原则的拓展类功能的方法。在代码中使用多态特性的地方很多，里氏替换原则保证了这些使用多态的地方，不会因为实际对象类型是父类还是子类，影响程序正常运行。在组合优于继承中提到，组合通常能达到和继承相同的作用，同时更灵活，但这也不是绝对的。实话说这很让人感到疑惑，前面说继承不好，现在又说使用继承应该注意的事项，不用不就行了吗？经验总结就会出现的情况是，归纳时通常只是针对某些特殊情况，虽然归纳本身已经是宽泛的理解。组合的优势在于，可以避免多维度继承带来的类数量爆炸，避免选择性继承的难题。如果不涉及多级继承，或者组合的对象数量不多，继承通常也是可以的选择。实际开发中可以根据继承层级、功能是否可分，以及是否需要动态性，选择使用组合和继承。</p><h2 id="interface-segregation-principle-接口隔离原则">InterfaceSegregation Principle 接口隔离原则</h2><blockquote><p>客户端不应被强迫依赖于其不使用的方法</p></blockquote><p>尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。</p><p>不同于继承，实现可以一次性实现多个接口，因此可以将功能过于复杂的接口，拆分成多个简单接口。这样在实现时可以选择性的实现，避免去实现那些用不到的方法（接口要求其实现类必须实现其定义的抽象方法）。</p><p>这一看和单一职责原则很像，都在表述需要将复杂的东西进行细分。但是单一职责原则针对类，而接口隔离原则针对接口。如果没有做好接口隔离原则，对接口进行细分，并且类中实现了接口定义的方法，那么通常这个类也是不满足单一职责原则的。</p><h2 id="dependency-inversion-principle-依赖倒置原则">DependencyInversion Principle 依赖倒置原则</h2><blockquote><p>高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。 具体实现应该依赖于抽象接口</p></blockquote><p>常规开发模式下，高层次类会调用低层次类提供的函数，体现出高层次类依赖低层次类的关系。在这种模式下，如果对低层次类进行改动，可能会对高层次类的运行产生影响。或者需要替换另一种低层次类的实现，例如数据不是从本地硬盘，而是从网络中获取，需要变动高层次类中的相关代码。</p><p>依赖倒置的<strong>倒置</strong>，指的就是改变这种高层次类直接依赖低层次类的关系。通过增加抽象层，依赖方向变成了两者都依赖抽象层。抽象层通常是通过接口，定义一组通用的方法或协议。高层次类直接依赖接口，低层次类通过实现的方式依赖接口。这样子分层的设计降低了层与层之间的耦合度。当需要更新低层次类，或者拓展出新的低层次类，只要保证低层次类实现了接口，在高层次类中的调用代码就无需改变。这也体现了开闭原则。</p><p>此外，由于高层次类中通过接口依赖低层次类。程序在运行时需要确定被引用的具体低层次类对象，这个创建低层次类对象，并将其赋值给高层次类对象的过程，通常是通过容器框架的依赖注入功能。这也和之前聊到的<code>Spring</code>框架的功能联系到了一起。</p><h2 id="总结">总结</h2><p>SOLID原则是一组优秀代码的经验总结。</p><p>单一职责原则是指，一个类只负责一系列相关功能，需要把过于复杂的类，根据功能划分，拆分成小的类。开闭原则是指程序设计，应该有良好的拓展性，拓展的同时又能保证已有功能不受影响，通常是通过继承或接口来实现。里氏替换原则限制了子类尽量不要重写父类中实现的公共方法，避免将子类对象赋值给父类类型时，可能会导致程序出错的情况。接口隔离是指定义接口时，如果存在实现类实现了不必要的方法的情况，可以考虑把接口进行拆分，使得实现类可以在实现时有选择进行实现。依赖倒置原则是指，高层次类不应该直接依赖低层次类，而是将依赖关系改成高层次类和低层次类都依赖于抽象类。在运行时，这些类的实际依赖通常通过框架的依赖注入来完成。</p><p>虽然这些原则广为人知，在写代码时仍要根据实际情况，决定是否遵循原则。例如可以思考未来是否会对其进行同类型功能的拓展；一个类行数比较多了是否要进行重构；改了一处代码，处处受影响。遇到这些情况时，就应该想起这些设计原则，并用于指导代码编写和重构。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven-Single-Module-Compilation</title>
    <link href="/2023/07/18/Maven-Single-Module-Compilation/"/>
    <url>/2023/07/18/Maven-Single-Module-Compilation/</url>
    
    <content type="html"><![CDATA[<p>最近工作比较繁忙，没有太多时间学习和写笔记，忙里偷闲写下了这篇。</p><p>在大型<code>Java</code>项目中，通常会有多个主应用。<strong>主应用</strong>是指具有诸如<code>public static void main</code>程序入口，可以被<code>java</code>执行的模块。<code>Maven</code>概念中一个<code>packing</code>属性不为<code>pom</code>的<code>pom</code>文件对应一个模块，可以单独编译、测试和打包。与应用相对的概念是<strong>库</strong>，不包含程序入口，但可以提供特定功能和服务被其他应用调用。在一个项目中，不同主应用之间独立运行又相互协作。例如常规<code>SpringBoot</code>应用提供页面操作接口，可以添加自动任务，而自动任务应用间隔扫描任务列表，并根据任务状态来执行对应操作。</p><p>当修改代码的范围只影响项目中一个应用，只需打包部署对应应用及其依赖即可。</p><p>在<code>IDEA</code>的<code>Maven</code>菜单界面中，有列出项目中的所有<code>pom</code>文件。如果选择其中某个主应用执行<code>mvn clean package</code>，则可能会提示无法找到依赖的项目中的其他模块，或者打包后发现受影响的依赖库没有更新。</p><p>解决问题最简单的方法是在所有模块的根<code>pom</code>执行<code>mvn clean package</code>，这样所有的模块都会进行编译。当然会得到正确的<code>jar</code>包，但不受影响的库和应用也进行了重新编译，增加了编译过程的耗时。</p><p>会出现这种问题的原因是，模块之间并不互相认识，因此在编译时无法区分其依赖是项目中的其他模块，还是在本地库中的第三方模块。为了说明这个情况，需要了解<strong>项目继承</strong>和<strong>项目聚合</strong>。</p><h2 id="项目继承">项目继承</h2><p>项目继承(Project Inheritance)<ahref="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#project-inheritance">官方文档</a>。</p><p>通俗来说，项目继承就是在<code>pom</code>文件中，通过<code>&lt;parent&gt;</code>标签指定父<code>pom</code>。具体可以通过<code>artifactId</code>或相对路径来指定。父<code>pom</code>可以来自于同一个项目，也可以来自其他第三方<code>pom</code>。如果来自于同一项目且使用<code>artifactId</code>时，则需要父<code>pom</code>文件位于子<code>pom</code>的上一级目录。</p><p>项目继承使得子<code>pom</code>可以继承父<code>pom</code>中的标签属性值。当然也不是所有的属性都会被继承，可以被继承的属性可以参考官方文档。</p><blockquote><p>Elements in the POM that are merged are the following:</p><ul><li>dependencies</li><li>developers and contributors</li><li>plugin lists (including reports)</li><li>plugin executions with matching ids</li><li>plugin configuration</li><li>resources</li></ul></blockquote><p>这意味着如果在子<code>pom</code>中，不显式地给某个属性赋值时，会默认使用父<code>pom</code>中的值。常见的作用是<ahref="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#dependency-management">依赖管理</a>。如果项目中多个模块会使用到同一个第三方库，依赖的版本不一致可能会出现问题。此时在父<code>pom</code>中进行了依赖版本的设定，那么在子<code>pom</code>中无需指定依赖的版本，会默认使用父<code>pom</code>中设定的版本。这样可以在单个<code>pom</code>文件中，进行整个项目用到的第三方库的版本管理。</p><h2 id="项目聚合">项目聚合</h2><p>项目聚合（Project Aggregation）<ahref="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#project-aggregation">官方文档</a>。</p><p>通俗来说，项目聚合就是在父<code>pom</code>文件中，通过<code>&lt;modules</code>&gt;标签指定其包含的模块。当在父<code>pom</code>处调用<code>maven</code>命令，如<code>mvn clean install</code>，则会递归地在其所有模块中调用相同命令。在项目根<code>pom</code>中调用可以编译所有模块使用的就是这个机制。此外还需要将父<code>pom</code>的<code>&lt;packaging&gt;</code>标签属性设置为<code>pom</code>。</p><p>值得一提的是，虽然使用了父<code>pom</code>这个概念，但项目聚合本身不必须进行项目继承。也就是在子<code>pom</code>中不必须指定<code>&lt;parent&gt;</code>。但通常项目聚合和项目继承会一起使用。其中项目继承常用来控制版本，项目聚合用来管理不同模块的递归编译。</p><h2 id="问题原因">问题原因</h2><p>在主应用所在的<code>pom</code>处执行<code>mvn clean package</code>，由于其没有子模块，因此不符合项目聚合的条件。所以并不知道其依赖来自于同一个项目，还是本地库。默认所有依赖都会去本地库中查找。如果本地库中存在同一个项目的模块上次打包的<code>jar</code>包，则会使用这个<code>jar</code>包，否则则会报错无法找到依赖。由于上次打包的<code>jar</code>包并不包含项目中现有的代码变动，因此会产生明明代码改了但没生效的情况。</p><p>一个直观的想法便是，在编译某个主应用前，手动将所有其他依赖的项目中的模块重新打包安装到本地库。确实可以解决问题，但这样会麻烦，而且模块之间的依赖和依赖传递关系靠手动分析很容易出错。</p><p>这个问题显然和项目聚合相关，而不是项目继承。出现这个问题的原因是，项目聚合只能在父<code>pom</code>处调用。父<code>pom</code>可以通过递归访问子模块信息，来组织子模块间的依赖关系。子<code>pom</code>无法通过递归访问父<code>pom</code>来了解父<code>pom</code>的其他模块信息。前文提到项目聚合不必须进行项目继承，也就是子<code>pom</code>可能都不知道父<code>pom</code>是谁，父<code>pom</code>有没有自己这个孩子。也就是说项目聚合的递归调用只能是从根到子节点，而不能是子节点向根（<code>pom</code>通过树的形式组织）。子<code>pom</code>所在的模块，项目中的其他模块对其来说是不可见的。</p><h2 id="解决方法">解决方法</h2><p>要能满足只编译主应用及其依赖模块，根据项目聚合的特性，只能在主应用和依赖模块的共同祖先节点处执行<code>maven</code>命令。不管项目具体结构如何，根目录一定满足这个共同祖先这个要求。所以为了解决这个问题通常还是会在根<code>pom</code>处执行<code>maven</code>命令。</p><p>而在根<code>pom</code>直接执行<code>maven</code>命令，默认行为会对所有模块执行。因此<code>maven</code>提供了一组参数来控制这个过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mvn">-pl, --projects<br>        Comma-delimited list of specified reactor projects to build instead of all projects. A project can be specified by [groupId]:artifactId or by its relative path<br>-am, --also-make<br>        If project list is specified, also build projects required by the list<br></code></pre></td></tr></table></figure><p><code>-pl</code>参数指定了编译的具体模块。指定后<code>maven</code>命令不再对所有模块执行。-am参数指定了目标模块如果依赖项目中其他模块，那会递归编译。</p><p>如果目标应用<code>pom</code>和根<code>pom</code>在文件目录上不是直接父子目录关系，通常使用<code>[groupId]:artifactId</code>的方式来指定具体模块。通常<code>[groupId]</code>可以省略，所以常见的写法是。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean install -pl :some-app -am<br></code></pre></td></tr></table></figure><p>把<code>some-app</code>替换为具体目标应用的<code>groupId</code>即可。</p><h2 id="总结">总结</h2><p><code>maven</code>中项目继承和项目聚合是两个非常常用的功能。但由于都涉及父子关系的概念，很容易将两者混淆。</p><p>项目继承是指子<code>pom</code>通过<code>&lt;parent&gt;</code>标签指定父<code>pom</code>。这样子<code>pom</code>就可以从父<code>pom</code>中获得很多属性的默认值。例如在依赖管理中，可以在父<code>pom</code>中指定依赖的版本，在子<code>pom</code>中就不需要指定依赖的版本号。</p><p>项目聚合是指在一个父<code>pom</code>中指定其拥有的模块，并将<code>&lt;packaging&gt;</code>标签属性设置为<code>pom</code>。此后在父<code>pom</code>中调用<code>maven</code>命令时，默认会在所有子模块中递归执行。执行顺序取决于子模块间的依赖关系。</p><p>项目聚合默认会对所有子模块执行，如果只相对其中某个应用执行，则可以通过<code>-pl am</code>参数来指定目标模块。</p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
      <tag>Single Module Compilation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-String-Pool</title>
    <link href="/2023/07/04/JVM-String-Pool/"/>
    <url>/2023/07/04/JVM-String-Pool/</url>
    
    <content type="html"><![CDATA[<p>最近在学习<code>JVM</code>的过程中，遇到了一个十分容易混淆的概念，<code>字符串池</code>。有关<code>字符串池</code>的代码，运行结果始终没有和预期对应上。查询了大量资料无果后，在<code>stackoverflow</code>上发布了提问，<ahref="https://stackoverflow.com/questions/76579840/java-string-intern-function-and">提问链接</a>。提问后的半天内（在此感叹下国际友人的钻研精神），有两位大佬和我就此问题进行了探讨。在交流中对这个概念的理解逐渐清晰。通过将这个事情记录下来，来理清自己的思路，并分享给更多人。</p><p>由于具体情况可能在不同<code>JVM</code>上表现不同，本次实验和讨论基于<code>JDK8</code>，<code>HotSpot JVM</code>。</p><h2 id="问题">问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;12&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;21&quot;</span>);<br>    s1.intern();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1221&quot;</span>;<br>    System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;12&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;21&quot;</span>);<br>    <span class="hljs-comment">// s1.intern();</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1221&quot;</span>;<br>    System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有上述两段代码，唯一的区别就是是否调用了<code>s1.intern()</code>，而产生了不同的输出结果。</p><p><code>intern</code>是一个<code>native</code>方法，在Java8源代码中的注释如下：</p><blockquote><p>When the intern method is invoked, if the pool already contains astring equal to this String object as determined by the equals(Object)method, then the string from the pool is returned. Otherwise, thisString object is added to the pool and a reference to this String objectis returned.</p></blockquote><p>这段代码的字节码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bytecode"> 0 new #2 &lt;java/lang/StringBuilder&gt;<br> 3 dup<br> 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br> 7 new #4 &lt;java/lang/String&gt;<br>10 dup<br>11 ldc #5 &lt;12&gt;<br>13 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br>16 invokevirtual #7 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br>19 new #4 &lt;java/lang/String&gt;<br>22 dup<br>23 ldc #8 &lt;21&gt;<br>25 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br>28 invokevirtual #7 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br>34 astore_1<br>35 aload_1<br>36 invokevirtual #10 &lt;java/lang/String.intern : ()Ljava/lang/String;&gt;<br>39 pop<br>40 ldc #11 &lt;1221&gt;<br>42 astore_2<br>43 getstatic #12 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br>46 aload_1<br>47 aload_2<br>48 if_acmpne 55 (+7)<br>51 iconst_1<br>52 goto 56 (+4)<br>55 iconst_0<br>56 invokevirtual #13 &lt;java/io/PrintStream.println : (Z)V&gt;<br>59 return<br></code></pre></td></tr></table></figure><h2 id="错误的理解">错误的理解</h2><ol type="1"><li>在源代码中，出现了<code>"12"</code>、<code>"21"</code>、<code>"1221"</code>字面量。因此编译后，字节码常量池中可以观察到这三个字面量对应的<code>CONSTANT_String_info</code>，这些<code>CONSTANT_String_info</code>在这些指令中被使用：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bytecode">11 ldc #5 &lt;12&gt;<br>23 ldc #8 &lt;21&gt;<br>40 ldc #11 &lt;1221&gt;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>当程序运行，类加载器加载这个类时，字节码文件中常量池被载入内存。在内存中称为运行时常量池。字符串池是运行时常量池的一部分，因此在字符串池中包含<code>"12"</code>、<code>"21"</code>、<code>"1221"</code>这些字符串。</p></li><li><p><code>new String("12")</code>在堆中申请了一块空间，容纳新<code>String</code>实例，并从字符串池中取出<code>"12"</code>，并用此对新实例进行初始化。对应的字节码如下，<code>new String("21")</code>也是同理。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bytecode"> 7 new #4 &lt;java/lang/String&gt;<br>11 ldc #5 &lt;12&gt;<br>13 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>+</code>进行字符串拼接，本质被编译器转化为了<code>StringBuilder</code>实例和进行<code>append</code>方法，并最后调用<code>toString</code>方法，对应的字节码:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bytecode">0 new #2 &lt;java/lang/StringBuilder&gt;<br>4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br>16 invokevirtual #7 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>在<code>toString</code>方法中，调用了<code>new String</code>，因此最后返回的<code>s1</code>是<code>"1221"</code>的<code>String</code>实例，位于堆上。</li><li>根据文档，<code>s1.intern()</code>方法，查看了字符串池，发现确实存在<code>"1221"</code>，返回了字符串池中的地址引用。不管如何，代码中没有利用返回值，只是将他<code>pop</code>掉了，因此不会对已有的变量进行任何改动。</li><li><code>String s2 = "1221"</code>查看了字符串池，发现存在，因此将其地址引用赋值给<code>s2</code>。对应字节码为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bytecode">40 ldc #11 &lt;1221&gt;<br>42 astore_2<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li><code>==</code>运算符对于引用类型来说，比较的是俩者的地址。<code>s1</code>的地址指向堆中，<code>s2</code>的地址指向字符串池中。俩者怎么可能会相等？</li></ol><h2 id="疑惑">疑惑</h2><ol type="1"><li><code>s1</code>和<code>s2</code>到底指向哪里？</li><li>为什么调用<code>intern</code>方法会影响代码行为，甚至没有去利用其返回值？</li></ol><h2 id="正解">正解</h2><p>错误出现在理解<strong>2</strong>和<strong>6</strong>中，字符串池并没有随着类加载，被载入运行时常量池。<code>s1.intern()</code>是首次将<code>"1221"</code>加入到字符串池中，而后运行的<code>String s2 = "1221"</code>，会根据字符串池中是否存在<code>"1221"</code>改变行为。</p><p>为了更好解释这个问题，首先对涉及的关键概念进行定义。</p><h3 id="关键概念">关键概念</h3><ul><li>常量池：字节码中的一种存储结构，用来存储源代码中用到的常数、字符串，类、字段、方法、接口、参数类型等。位于硬盘上的字节码文件中。具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">官方文档</a>。</li><li>运行时常量池：程序运行时，内存中的常量池。在类加载时，会将常量池数据加载到<code>JVM</code>方法区，形成运行时常量池。具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1">官方文档</a>。</li><li><code>CONSTANT_String_info</code>：常量池中的一种数据结构，储存了源代码中字符串字面量对应的<code>Unicode</code>序列，具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3">官方文档</a>。</li><li>字符串池：JDK8堆中的一块内存区域，用于存取用到过的<code>String</code>实例。源码中<code>String.intern()</code>函数的<ahref="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/String.html#intern()">官方文档</a>。</li></ul><blockquote><p>A pool of strings, initially empty, is maintained privately by theclass String.</p></blockquote><ul><li><code>ldc #5</code>，将序号为5的常量从运行时常量池中推到操作数栈上，具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-6.html#jvms-6.5.ldc">官方文档</a>。在使用到通过字面量表示的字符串，都会先检查字符串池中是否存在对应的<code>string</code>实例。如果存在，则入栈其引用地址；如果不存在，则在字符串池内创建<code>string</code>实例并入栈其地址。</li></ul><h3 id="错误原因">错误原因</h3><p>错误来自于误解了字符串池和常量池（此后不加区分地使用常量池和运行时常量池）间的关系。</p><p>虽然通常称其为<strong>字符串常量池</strong>，但其和常量池并不存在属于关系。因此并不会随着类的加载而载入。在<code>JDK6</code>时，字符串池和常量池都位于永久代，好似之间存在一些关系。但在<code>JDK8</code>中，字符串池被移到堆中。与其说是常量池的一部分，更不如说是<code>String</code>类的一部分。可以理解为<code>String</code>类的一个私有的成员变量，虽然在<code>String</code>源码中无法观察到。字符串池中的<code>String</code>实例在被创建后，无法改变实例中的字节数组字段。如果对已有的<code>String</code>实例进行改变的操作，会生成一个新的<code>String</code>实例，表现出<strong>常量</strong>的特性，所以通常称其为<strong>字符串常量池</strong>。但为了避免混淆字符串池和常量池，本文尽量使用<strong>字符串池</strong>，而不是<strong>字符串常量池</strong>。</p><p>与其容易混淆的另一个概念是常量池中的<code>CONSTANT_String_info</code>。里面以<code>Unicode</code>序列储存着字符串字面量，并且会随着类加载，载入到运行时常量池中。但其和字符串池有着本质区别：<code>CONSTANT_String_info</code>只储存了<code>Unicode</code>序列，而字符串池储存了<code>String</code>实例。<code>String</code>实例不仅包含了<code>Unicode</code>序列，还包含了其他成员属性，如<code>hash</code>。并且<code>String</code>类绑定了许多方法，这些方法无法在<code>CONSTANT_String_info</code>上执行。可以通过以<code>CONSTANT_String_info</code>中的<code>Unicode</code>序列为参数，执行<code>String</code>初始化函数，生成对应的<code>String</code>实例。</p><h3 id="具体行为">具体行为</h3><p>根据文档，字符串池初始为空，并会在字符串第一次被使用时被加入到字符串池中。以后再用到相同的字符串，会复用字符串池已经存在的对象。所以详细描述的<code>ldc #5</code>执行过程应该是这样的：</p><p>1.取出运行时常量池中的索引为5的<code>Unicode</code>序列</p><p>2.根据此序列，在字符串常量池中寻找是否存在对应的<code>String</code>实例</p><p>3.如果存在，则将其引用入栈</p><p>4.如果不存在，则在字符串中创建一个新的<code>String</code>实例，以<code>Unicode</code>序列为参数，执行初始化，并将新创建的<code>String</code>实例的引用入栈。</p><p>而<code>new</code>关键字，则会在堆（字符串池外）中创建一个新的<code>String</code>实例。如果通过字面量形式赋值，如<code>new String("12")</code>，则会现在字符串池中创建实例，再以字符串池中的实例为参数，调用参数类型为<code>String</code>的初始化函数。执行完后，内存中存在两个一模一样的<code>String</code>实例，一个在堆中，一个在字符串池中。这点可以从字节码指令中看出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bytecode"> 7 new #4 &lt;java/lang/String&gt;<br>10 dup<br>11 ldc #5 &lt;12&gt; //字符串池中不存在，因此会创建一个String`实例<br>13 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt; //调用参数为String的初始化函数<br></code></pre></td></tr></table></figure><p>向字符串池中加入新的<code>String</code>实例通常有两个方法。<code>ldc</code>一个字符串池中不存在的常量，或者调用一个字符串池中不存在的<code>string</code>实例的<code>intern</code>方法。第二中方法相对少见，因为这需要在堆上，不通过字面量的形式创建一个<code>string</code>实例。这通常需要通过字符串操作来做到。</p><p>对于一个字符串池中不存在的<code>string</code>实例，对其调用<code>intern</code>方法会将其引用添加到字符串池中，而不是重新在字符串池中创建一个新的相同的实例。此为<code>JDK8 Hotspot</code>的行为，这个行为可能会因<code>JDK</code>版本和<code>JVM</code>具体实现而异。例如在<code>JDK6</code>就会重新在字符串池中创建一个新的相同的实例。</p><p>因此回答上文提到的两个问题：</p><p>1.<code>s1</code>指向堆中的<code>"1221" String</code>实例，<code>s2</code>根据字符串池中储存的引用，最终也指向了堆中的<code>"1221" String</code>实例。所以在<code>JDK8</code>中，内存中存在两处<code>"1221"</code>序列，一处在常量池中，一处在堆上。字符串池由于存储的是引用，因此没有<code>"1221"</code>序列。</p><p>2.因为<code>s1</code>没有通过字面量，而是字符串拼接的形式创建了<code>"1221" String</code>实例，在这种情况下，字符串池中不存在<code>"1221"</code>，调用<code>intern</code>方法会影响字符串池，从而影响到<code>ldc</code>指令获取到的地址。</p><h2 id="总结">总结</h2><p>避免混淆字符串池、常量池、<code>CONSTANT_String_info</code>的概念和之间的关系。</p><p>字符串池是一个位于堆上的，用于管理<code>String</code>实例的数据结构，可以被视为<code>String</code>类的一个私有成员变量。</p><p>常量池是字节码文件中的存储结构。运行时常量池是在类加载过程中，将常量池加载到方法区/元空间形成的内存区域。</p><p><code>CONSTANT_String_info</code>是常量池/运行时常量池中的存储结构，储存了源代码中用到的字符串字面量的<code>Unicode</code>序列。是常量池的一部分，随类加载而加载。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>String Pool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Design-Principle</title>
    <link href="/2023/06/27/Design-Pattern-Design-Principle/"/>
    <url>/2023/06/27/Design-Pattern-Design-Principle/</url>
    
    <content type="html"><![CDATA[<p>设计模式是一系列优秀的代码构思实践。但从代码的功能性角度来说，很难定义什么是优秀的。<strong>“这不是也能跑吗”</strong>是对这个想法的准确体现。如果两份代码执行表现完全相同，凭什么说，其中一份比另外一份代码要好？设计原则回答了这个问题。</p><p>在日常开发中，看到一份代码变量名规范，注释规范，我们会说代码是好的。这是从可读性上对代码进行的评判。而设计原则从另一个角度进行评价：<strong>代码复用</strong>和<strong>拓展性</strong>。有时候设计原则和可读性是相违背的，一些设计模式为了增加复用性和可扩展性，反而会把类的结构变得更复杂，影响可读性。</p><h2 id="代码优秀特征">代码优秀特征</h2><h3 id="代码复用">代码复用</h3><p>可以通过观察代码中重复或相似的片段的多少，来体现代码复用执行的程度。</p><p>如果一份代码在多处被使用，那么可以抽取成一个方法，并在使用处改写为对方法的调用。方法中可能发生变化的地方，可以抽取成方法的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>...<br>methodC();<br>...<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>...<br>methodC();<br>...<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sharedMethodC</span><span class="hljs-params">()</span> &#123;<br>some shared code<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的好处是，如果这些反复使用的代码要进行改动，那么只需要改动抽取后的方法就可以了。不采取复用的话，需要找到所有使用这些代码的地方进行修改。而且代码复用本身也可以减少开发量，缩短开发周期。</p><p>从小的层面讲，将多处使用到的代码，抽取成一个方法，或者把相关的方法再次打包成一个类，就是代码复用。开发中经常会有一些工具类，提供一些静态方法，可以在多个地方被使用。工具类就是代码复用的一个体现。</p><p>往大了说，框架本身也是代码复用的体现。不同的项目可以根据业务特殊需求，自定义子类，而使用共同的<code>SpringBoot</code>框架。</p><p>而在这两个层次之间，就是设计模式。设计模式通常用来组织少数对象之间的关系和其间的互动行为。在设计模式中，可以将描述的角色替换成不同的具体类，来实现代码复用。</p><h3 id="拓展性">拓展性</h3><p><strong>变化</strong>是程序员生命中唯一不变的事情。</p><p>程序员经常会面对新出现的需求，进行新功能的开发。这些新功能可能和已有的功能有些相似，但也不完全相同。考虑之前提到的代码复用，可能需要对相似的部分进行抽取，或者所有代码都得重写。但这样不可避免就会破坏已有的代码，没有人能保证代码重构后，原功能仍然能正常运行。如果每次添加新功能，都需要将已有的功能重新测试，这无疑增加了工作量。因此在首次开发功能时，就需要对未来可能会出现的新需求进行预测和假设。</p><p>一份代码，在增加新功能时非常方便，并且不会破坏原有代码时，则称其有良好扩展性。</p><h2 id="设计原则">设计原则</h2><p>为了使代码更优秀，也就是使代码拥有更好的复用性和可拓展性，程序员总结出了一系列设计原则。在开发中遵守这些原则，就可以提高代码质量。设计模式中或多或少都体现了对这些原则的遵守。值得一提的是，原则不是必须遵守的，程序员需要根据实际情况，衡量遵守原则的收益和代价。代价通常是前文提到的代码复杂性和可读性。</p><h3 id="封装变化的原则">封装变化的原则</h3><p>找到程序中的变化内容并将其与不变的内容区分开。</p><p>该原则的主要目的是将变更造成的影响最小化。根据未来是否可能会发生变化，将变化部分的代码抽取成一个方法。当进行修改时，只在抽取后的方法中进行修改。这样不会对调用处的原方法造成更多影响。要说影响的话，也就具体返回值可能会发生变化，从而将影响控制到了最小程度。</p><p>在代码中，通常会有根据字符串或者某些标识符，进行<code>switch case</code>判断，来决定执行的逻辑。通常可以认为，未来会有更多的<code>case</code>情况，也就是会发生变化。从而将<code>switch case</code>部分进行方法抽取，将变量或标识符通过参数传递到抽取的方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    ...<br>switchCase(<span class="hljs-keyword">case</span>);<br>    ...<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">switchCase</span><span class="hljs-params">(String <span class="hljs-keyword">case</span>)</span> &#123;<br>    <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">case</span>) &#123;<br>        <span class="hljs-keyword">case</span> case1:<br>            ...<br>            <span class="hljs-keyword">break</span>;<br>...        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将变化部分的代码抽取成方法，这是方法层面的封装。如果将类中常发生变动的成员变量和方法进行抽取成一个新的类，这是类层面的封装。多个变化的类，甚至可以以成员变量的形式共享同一个不变的类，这也是<code>享元</code>设计模式的核心思想。</p><h3 id="面向接口而不是面向实现的原则">面向接口而不是面向实现的原则</h3><p>之前提到，接口可以视为一些具体类的集合。</p><p>在代码中，如果将变量定义为某个具体类（相对于抽象类/接口），那么需要使用新扩展的具体类时，就需要改动使用处的变量类型。这也违反了上一条<code>封装变化</code>的原则。说明原则之间不全是相互独立的，其间也可能存在交叉的关系。</p><p>符合原则的做法是，将可能会扩展的类，和已有的具体类中方法相似的部分，抽取成一个接口，将新扩展和已有的具体类都实现这个接口，并将所有用到这些类的地方的变量类型设置为接口类型，通过多态性调用具体类的实现。接口中定义了允许调用的方法，规范了类和类之间交互的行为。新定义的类只要符合规范（实现接口），就可以无缝扩展到已有代码中。程序员通过查看接口代码，就基本能了解其具体实现类能做的行为。</p><p>在一些<code>SpringBoot</code>项目中，会采用分层模型：<code>Controller</code>、<code>Service</code>、<code>DAO</code>。在<code>Service</code>层中，可以定义一系列的<code>Service接口</code>，并使用<code>ServiceImpl</code>去实现具体类。然后在<code>Controller</code>中使用<code>Service</code>时，通过接口进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeController</span> &#123;<br>    <span class="hljs-comment">// 通过@Resource自动注入或构造器传参</span><br>Service service;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    some method declear<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    concrete method implementation<br>&#125;<br></code></pre></td></tr></table></figure><p>但接口也会使代码更复杂。本来只有两个具体类，现在还多了一个接口。如果项目代码中<code>ServiceImpl</code>和<code>Service</code>是一一对应关系，也就是没有进行扩展，可能也不需要将其拆成一个接口和一个类。具体是否拆成两个的代码习惯得参照公司规范。</p><h3 id="组合优于继承">组合优于继承</h3><p>如果几个类都具有共同的属性和方法，那么可以通过继承，来实现代码复用。这些类通常在概念上是互相相关的，例如丘丘人和史莱姆都属于怪物，体现出<code>is-a</code>关系。</p><p>具体做法是将共同的属性和方法都抽取到一个怪物类中，然后将丘丘人和史莱姆都继承于怪物类。为了使子类必须实现怪物类中定义的方法，通常会将怪物类设置为抽象类。而且怪物本身也是个抽象概念，不应该被实例化。</p><p>但问题在于，无法选择性继承，这意味着对于某些怪物，基类中的某些方法可能不是必须的。例如有些丘丘人萨满无法攻击，那么攻击力属性和攻击方法，可能就是不需要的。风史莱姆会飞，但对于土史莱姆来说，飞行方法可能是不需要的。当然可以从怪物抽象类中，继承出会攻击怪物和不会攻击怪物抽象类，再将会攻击怪物分成会攻击会飞行怪物，和会攻击不会飞行怪物。到这里已经能体会到继承可能存在的问题了。</p><p>因为无法选择性继承，而某些具体类又不需要完全用到被继承类的所有属性和方法时，就需要多加一层继承关系。当在多个独立的维度上同时发生这些问题时，会造成类的组合爆炸。</p><p>更加好的做法是，定义两个接口，<code>Flyable</code>和<code>Attackable</code>。并根据具体类的情况，实现其中对应的接口。而如果多个会飞的怪物，他们的飞行属性和飞行方法中，代码相似度非常高，为了实现代码复用，可以将飞行相关的属性和方法抽取成<code>FlyAbility</code>类，并实现<code>Flyable</code>接口。然后以成员变量的形式将<code>FlyAbility</code>组合/聚合到具体怪物类中。调用具体怪物类的飞行方法时，将调用<code>FlyAbility</code>成员变量的飞行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br>Double hitPoint;<br>...<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">death</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyAbility</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>Double flySpeed;<br>Double flyHeight;<br>    ...<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>    concrete method implementation<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnemoSlime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">private</span> FlyAbility flyAbility;<br>    ...<br>    AnemoSlime()&#123;<br>        <span class="hljs-built_in">this</span>.flyAbility = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyAbility</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        flyAbility.fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中，风史莱姆是通过组合了<code>FlyAbility</code>变量，而不是继承的形式，来获得了飞行相关的属性，实现了代码复用。这就是组合优于继承。</p><p>但原则不是绝对的。从代码可以观察到类的结构确实因为组合而变得复杂了许多。一般来说，如果一些对象，其属性和方法没有在多个维度有区分，继承关系比较简单，那么使用继承也是可以的。当需要对对象进行细粒度拆分，可能组合是更好的选择。</p><h2 id="总结">总结</h2><p>限于篇幅，<code>SOLID原则</code>放到下篇讲。</p><p>在代码能按照设计功能正常运行时，我们通常通过可读性、复用性、可拓展性来衡量一份代码的好坏。</p><p>为了提高代码的复用性和可拓展性，程序员总结了一系列的设计原则，遵守这些原则可以写出更优秀的代码。设计模式是这些原则的优秀实践。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Rebase</title>
    <link href="/2023/06/19/Git-Rebase/"/>
    <url>/2023/06/19/Git-Rebase/</url>
    
    <content type="html"><![CDATA[<p><code>Git</code>是最常用的<code>VCS</code>(<em>version control</em>system，版本控制系统)工具。在<code>Git</code>中，多人协作开发涉及到多分支，而分支管理则必然会涉及<code>新建分支</code>和<code>分支合并</code>。相对于<code>新建分支</code>，<code>分支合并</code>复杂得多，是问题的高发地段。<code>合并分支</code>通常有两种方式，<code>merge</code>和<code>rebase</code>。其中<code>merge</code>是通过新建一个特殊的提交（本文不加区分地使用提交/节点），这个提交指向了两个节点（常规的提交只有一个父节点），这两个节点分别来自不同的分支。</p><figure><img src="/img/merge.png" alt="merge" /><figcaption aria-hidden="true">merge</figcaption></figure><p>如果合并时发生冲突，那么<code>合并提交</code>还会包含了冲突解决的信息。在<code>IDEA</code>中查看提交的文件改动，会发现相较于常规的两个窗口（一个显示提交前的版本，一个显示提交后的版本），<code>合并提交</code>的改动有三个窗口，因为提交前的版本有两个，来自不同分支。</p><h2 id="rebase">rebase</h2><p>相对于<code>merge</code>，<code>rebase</code>就要复杂得多。一个可能的原因是<code>rebase</code>会改动提交历史，并且没有交换律。</p><p>通俗来讲，<code>rebase</code>的工作是找到两个分支的共同的祖先节点，并统计自共同的祖先节点开始的所有提交，在另一条分支上执行一次。此处借用<ahref="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">《GitPro》</a>中的图片。</p><figure><img src="/img/basic-rebase-1.png" alt="初始状态" /><figcaption aria-hidden="true">初始状态</figcaption></figure><figure><img src="/img/basic-rebase-3.png" alt="rebase后" /><figcaption aria-hidden="true">rebase后</figcaption></figure><p>图中，找到<code>experiment</code>分支的<code>C4</code>节点，和<code>master</code>分支的<code>C3</code>节点的共同祖先，也就是<code>C2</code>节点，并将自<code>C2</code>开始的所有发生在一侧的提交，在另一侧重现（图中只有一个<code>C4</code>，如果有更多都会重现）。并将<code>experiment</code>的指针指向<code>C4'</code>。<strong>这里就涉及到谁<code>rebase</code>到谁上的问题</strong>。体现在图中就是到底是新的<code>C4'</code>在<code>C3</code>后，还是新的<code>C3'</code>在<code>C4</code>后。</p><p>在<ahref="https://git-scm.com/docs/git-rebase">官方文档</a>中，<code>git rebase</code>指令可以有很多变体。例如<code>git rebase A</code>、<code>git rebase A B</code>、<code>git rebase --onto A C B</code>。其中A、B、C表示分支的索引或提交。指定A、B、C本质就是在解决谁<code>rebase</code>到谁上的问题。</p><p>在<code>merge</code>时，合并时两个分支的地位是均等的。在<code>A</code>分支输入<code>git merge B</code>和在<code>B</code>分支输入<code>git merge A</code>，最后的结果几乎是一致的。细微的区别是合并后指向<code>合并提交</code>的分支是<code>A</code>或<code>B</code>，但在切换到另一个分支再<code>merge</code>一次后(<code>fast-forward</code>)，状态就完全一致。<code>merge</code>的这种两分支互换对合并后结果几乎没影响，我称之为<strong>交换律</strong>。</p><p>相较于<code>merge</code>，<code>rebase</code>不遵循<strong>交换律</strong>。把<code>A</code>放在<code>B</code>上和把<code>B</code>放在<code>A</code>上，这显然是两个不同的状态。由于指令的复杂，以及A、B、C互相不可交换，地位不均等，导致<code>rebase</code>比<code>merge</code>更容易犯错。</p><p>回到上面提到的三个指令<code>git rebase A</code>、<code>git rebase A B</code>、<code>git rebase --onto A C B</code>。其中<code>A</code>表示<code>新基</code>，<code>B</code>表示被<code>rebase</code>的分支，<code>C</code>表示从<code>C</code>开始计算到<code>B</code>的改动。上述指令的含义表示：<strong>从<code>C</code>开始统计，统计到<code>B</code>分支指向的节点做的所有改动，将这些改动在<code>A</code>上重现一次，并将<code>B</code>的引用指向重现完后的状态</strong>。如果<code>B</code>省略，则<code>B</code>默认为当前所在分支。如果<code>C</code>省略，则默认为<code>A</code>和<code>B</code>的最近的祖先节点。</p><h3 id="常规实践">常规实践</h3><p>在实际开发中，通常有一个共享的主分支，例如<code>master</code>分支。开发人员从<code>master</code>分支上某个节点建立新分支<code>feature</code>，并在此上开发。相对于共享的<code>master</code>分支，<code>feature</code>通常是不共享的。<code>master</code>被多人共同使用，改动会造成较大影响，因此主分支上的提交历史通常不会修改。而<code>feature</code>分支历史的修改只影响个人。因此在涉及谁<code>rebase</code>到谁上的问题时，<strong>通常会将<code>feature</code>分支<code>rebase</code>到<code>master</code>上</strong>。因为<code>rebase</code>操作会修改被<code>rebase</code>的分支的提交历史，对应上图中原本的<code>C4</code>节点将无法通过新指针找到，提交历史从<code>C2</code>-&gt;<code>C4</code>，变成了<code>C2</code>-&gt;<code>C3</code>-&gt;<code>C4'</code>。</p><p>为了将<code>feature</code>分支<code>rebase</code>到<code>master</code>上，当然可以使用<code>git rebase A B</code>指令。但通常在GUI操作中，会先切换到<code>feature</code>，在进行<code>rebase</code>操作，相当于执行了<code>git rebase A</code>，把<code>B</code>和<code>C</code>都省略了。这里有一个助记的方法，做的所有操作，都是在当前所在分支进行修改。根据这个助记，就能分辨<code>签出并变基到A(Checkout and Rebase onto Current)</code>，和<code>将A变基到B(Rebase Current onto Selected)</code>这两个操作的实际行为了。</p><figure><img src="/img/IDEA-rebase2.png" alt="IDEA-rebase-本地分支" /><figcaption aria-hidden="true">IDEA-rebase-本地分支</figcaption></figure><p>在集中式的<code>VCS</code>中，例如<code>SVN</code>，开发人员在提交代码前，需要先拉取，这个行为就像是<code>rebase</code>。因为开发是基于主分支某个历史状态，而主分支会在开发过程中产生新的提交。在开发完成后，就需要把从开发基于的节点（共同的祖先节点），到主分支的最新状态中的修改，重新包括进来。结果就好像是在最新状态进行的开发，而不是某个历史状态。如果将修改引入的过程中遇到了冲突，那还涉及冲突解决。在<code>Git</code>中使用<code>rebase</code>而不是<code>merge</code>，会产生像集中式<code>VCS</code>简单的线性历史记录，使得整个开发历史更直观。</p><h3 id="rebase的撤销">rebase的撤销</h3><p>如果在<code>rebase</code>时发生了冲突，则会在新的提交中包含冲突解决的信息。如上图中的<code>C4</code>和<code>C3</code>发生了冲突，那么需要在新的<code>C4'</code>中解决冲突。冲突解决的结果是<code>C4</code>相对于<code>C2</code>做的修改，将不同于<code>C4'</code>相对于<code>C3</code>做的修改。</p><p>由于提交历史的改动，导致<code>rebase</code>的撤销要麻烦一些。<code>rebase</code>前<code>experiment</code>处于<code>C4</code>节点，<code>rebase</code>后处于<code>C4'</code>节点。撤销<code>rebase</code>应该将<code>experiment</code>指针重新指向<code>C4</code>，通常可以使用<code>git reset --hard</code>指令。但此时<code>C4</code>已不被任何分支跟踪，所以在<code>IDEA</code>的分支可视化界面中，找不到指向<code>C4</code>的指针，也找不到<code>C4</code>的哈希码。此处提供两个解决方案：</p><ol type="1"><li><code>rebase</code>前，在<code>C4</code>状态建立新分支<code>backup</code></li><li>使用<code>git reflog</code>指令，查看指针的历史信息，在其中寻找<code>C4</code>的哈希码</li></ol><p>而在<code>merge</code>中，撤销就简单的多。因为<code>合并提交</code>指向被合并前的状态，可以在GUI中选取。</p><h3 id="idea中的rebase使用">IDEA中的rebase使用</h3><p>在开发完后，需要将代码rebase到主分支中。此时需要位于开发的<code>feature</code>分支，在分支界面中选取<strong>远程</strong>的<code>maseter</code>分支，选<strong>本地</strong>的可能会缺少最新的提交。当然也可以<code>pull</code>一下本地的<code>maseter</code>分支，再<code>rebase</code>到其上，但这样不优雅。选取后出现菜单如下。</p><figure><img src="/img/IDEA-rebase.png" alt="IDEA-rebase-远程分支" /><figcaption aria-hidden="true">IDEA-rebase-远程分支</figcaption></figure><p>其中有两个<code>rebase</code>相关的选项,<code>将A变基到B(Rebase Current onto Selected)</code>和<code>使用变基拉入A(Pull into Current Using Rebase)</code>。那么这两个选项有什么区别，<ahref="https://www.jetbrains.com/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch-onto-another-branch">官方文档</a>。</p><blockquote><ul><li>Rebase Current onto Selected (for both remote and local branches) torebase the branch that is currently checked out on top of theselected.</li><li>Pull into Current Using Rebase (for remote branches) to fetchchanges from the selected branch and rebase the current branch on top ofthese changes.</li></ul></blockquote><p>仔细一看好像没有什么区别。执行每个选项后，可以在<code>Git</code>选项卡的控制台中观察到实际执行的<code>git</code>指令，这两选项唯一的区别就是后者在rebase前会执行一次fetch，确保rebase时远程分支是最新状态。因此在实际开发中更建议使用后者。</p><h3 id="与cherry-pick对比">与cherry-pick对比</h3><p>如果使用了<code>git rebase --onto A C B</code>形式的指令，则其行为与<code>cherry-pick</code>很像。<code>cherry-pick</code>可以把某个或某些提交，在其他分支上进行重现。如果指定<code>rebase</code>指令中<code>C</code>和<code>B</code>是同一个，那行为就等同于选了一个提交的<code>cherry-pick</code>。</p><p>当然还是存在许多区别。简单的区别是<code>git rebase</code>指令中的<code>B</code>必须是<code>分支</code>，而<code>cherry-pick</code>的参数是<code>提交</code>。<code>rebase</code>会选取<code>B</code>和<code>C</code>之间连续的所有提交，而<code>cherry-pick</code>可以只选择其中一部分，且不要求连续。</p><h2 id="总结">总结</h2><p>合并分支常用两种方式<code>merge</code>和<code>rebase</code>。</p><p>相较于<code>merge</code>，<code>rebase</code>的优势在于不会新增<code>合并提交</code>，并且会使得整个<code>提交历史</code>更加简洁。但缺点是会修改<code>提交历史</code>导致撤销麻烦，并且指令相对merge更为复杂，不符合交换律。</p><p>想要撤销rebase恢复到之前的状态，由于修改了提交历史，需要通过<code>git reflog</code>指令找到修改前状态的哈希值，再通过<code>git reset</code>恢复。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Rebase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Relationships-Between-Objects</title>
    <link href="/2023/06/12/Design-Pattern-Relationships-Between-Objects/"/>
    <url>/2023/06/12/Design-Pattern-Relationships-Between-Objects/</url>
    
    <content type="html"><![CDATA[<p>最近半个月，结合视频和书籍，把<code>设计模式</code>反反复复看了好几遍。</p><p>编写<code>设计模式</code>的笔记和分享，确实具有一定难度。首先，<code>设计模式</code>本身是抽象的，是对实践经验的总结。这意味着，对于每个<code>设计模式</code>，并没有完全确定的规范，不同的人有着不同的经验，也会有不同的实现。所以<code>设计模式</code>本质是一种思想，是不同实现中的相同部分，而思想本身很难用文字来完整表述。其次，笔记很容易变成网络上已有资料的复制。因为从头思考每个概念，琢磨其间关系，设计表达，本身事件很麻烦的事情，为了偷懒就会去复制别人的表述。最后，笔者也不一定保证自己的理解是准确的。但在刚刚学习完，一定是印象最深刻的。所以趁此机会做下记录。</p><p><code>设计模式</code>是基于<code>面向对象编程(Object-Oriented Programming, OOP)</code>的。对于面向对象的思想和四大特性在此不赘述，直接从对象之间关系开始聊起。</p><h2 id="对象之间的关系">对象之间的关系</h2><p>对象/类之间（因为大部分类最后都会实例化，因此不加区分地使用类/对象）的关系包括：<code>实现</code>、<code>继承</code>、<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>。</p><p>值得一提的是，不同编程语言对于<code>OOP</code>的支持也不同，例如<code>Python</code>中要定义抽象类/接口，需要继承<code>ABC抽象基类</code>，而<code>Java</code>中可以通过<code>abstract class</code>来定义抽象类，通过<code>interface</code>来定义接口；<code>Java</code>中可以定义内部类，而<code>PHP</code>则不支持内部类。对象之间的关系是脱离于语言的，本文以<code>Java</code>为例，描述对象之间的关系在<code>Java</code>中的体现。</p><h3 id="继承和实现">继承和实现</h3><p><code>继承</code>和<code>实现</code>的特征比较明显，容易区分。</p><p><code>继承</code>通常描述两个类中，其中一个类可以复制另一个类的<code>属性/成员变量</code>和<code>方法</code>。</p><p>通常来说，<code>继承</code>是为了提高代码复用性。如果有A、B两个类，在他们的定义中，都有一些相同的属性和方法，那么可以将这部分属性和方法抽取到C类中，并将A、B类都<code>继承</code>自C，那么A、B就拥有了C中定义的属性和方法。如果修改C类，那么A、B类会相应发生变动。而A/B中，可以在C的基础上新增<code>属性</code>和<code>方法</code>，或者<code>重写</code>C中定义的<code>方法</code>，以此来区分C和A/B。C和A、B类的关系就是<code>继承</code>，称C为<code>父类</code>，A/B为<code>子类</code>。</p><p><code>实现</code>通常描述一个<code>类</code>实现了另一个<code>接口</code>的所有方法的过程。当一个<code>类</code>实现了一个<code>接口</code>时，它必须提供<code>接口</code>中定义的所有方法的具体实现。<code>接口</code>通常是一个特殊的<code>类</code>，不能包含<code>属性</code>、<code>构造方法</code>，且方法只有签名声明。</p><p><code>接口</code>通常定义不同对象间交互的规范，而<code>实现</code>则是提供规范的具体实施过程。如果有两个类A、B，在他们定义中，包含同名且功能类似但不完全相同的方法，则可以将这些同名函数抽取到一个<code>接口</code>C中，且只需声明函数签名即可。为了<code>实现</code>接口C，A/B必须提供C中声明的所有方法的具体代码。</p><p>从此处看，<code>实现</code>本身没有提供额外的功能，也没有降低代码的冗余度。但可以利用多态的动态性，降低代码的耦合度。可以将代码中对A、B类的引用，都改成对接口C的引用。接口C的引用，可以指向所有实现了接口C的一堆类。调用C中声明的方法时，会动态根据对象具体类型，调用对应的实现。通过改成对接口C的引用，使得用到A、B的地方，不仅仅局限于只能使用A/B。有一种接口变量类型是一堆具体类的集合感觉。</p><h3 id="依赖关联聚合组合">依赖、关联、聚合、组合</h3><p><code>依赖</code>也是容易区分的。因为其他所有的关系，都必然是<code>依赖</code>关系。如果修改一个类的定义可能会造成另一个类的变化，那么这两个类之间就存在<code>依赖</code>关系。</p><p>在一个类的代码中，只要见到了另一个类的代码，通常这两个类就是依赖关系。但不包含另一个类的代码，也可能是<code>依赖</code>关系，例如对象A依赖了对象B，而对象B依赖了对象C。根据定义，修改C的代码，可能会导致B的行为变动，从而引起对象A的变化。这样看大部分类之间都包含<code>依赖</code>关系。幸运的是，对于大部分的<code>依赖关系</code>我们不需要刻意关注。</p><p><code>关联</code>可视为一种特殊类型的<code>依赖</code>，即一个对象总是拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。</p><p>在<code>Java</code>中，方法形参、局部变量是存在于栈中，方法返回后，其引用就会随着弹出而销毁。因此这种关系通常是临时的，通常使用<code>依赖</code>描述。而<code>成员变量</code>，在对象整个生命周期、不同方法中，都可以访问，关系是永久性的，因此使用<code>关联</code>描述。</p><p>在<code>关联</code>中，又可以细分为<code>聚合</code>和<code>组合</code>。在许多教材中，<code>组合</code>是一种特殊的<code>聚合</code>，即<code>聚合</code>包含<code>组合</code>。但在实际术语使用中，<code>聚合</code>通常指<code>聚合</code>中不包含<code>组合</code>的那部分，因此通俗地说两者不是包含关系，而是并列互斥的关系。</p><p><code>关联</code>描述了一个对象A，通过成员变量的形式，拥有了另一个对象B的访问权限。在此基础上，如果对象A控制着对象B的生命周期，则A与B是<code>组合</code>关系，否则则是<code>聚合</code>关系。</p><p>常见的控制生命周期的形式，便是在构造函数中对成员变量进行实例化赋值，并且不提供<code>setter</code>方法。如此对象A在实例化时，便会完成对成员变量B的实例化，并且外部无法去替换成员变量的引用。对象A销毁时，由于全局不会再有对B的引用，B也会被销毁。<code>组合</code>体现出A和B“同生共死”的关系。</p><p>如果成员变量可以被外部替换，或者两者的生命周期可以不一致时，通常就是<code>聚合</code>关系。值得一提的是，<code>Spring</code>框架中，通过<code>@Autowired</code>注解自动注入的成员变量，通常是<code>聚合</code>关系，因为其生命周期不一致，被引用对象也可以作为其他对象的成员变量，并且也可以通过某些方式替换这些成员变量。</p><h2 id="总结">总结</h2><p>对象之间的关系包括<code>实现</code>、<code>继承</code>、<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>。</p><p>其中<code>实现</code>、<code>继承</code>容易区分和识别。</p><p><code>依赖</code>是最弱的关系表示，剩下五种关系都是<code>关联</code>关系。</p><p><code>关联</code>在<code>Java</code>中，通常使用成员变量来表示。他包含两种具体情况。如果两个对象同生共死，则为<code>组合关系</code>，否则则是<code>聚合</code>关系。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Lazy-Initialization-PartII</title>
    <link href="/2023/05/26/SpringBoot-Lazy-Initialization-PartII/"/>
    <url>/2023/05/26/SpringBoot-Lazy-Initialization-PartII/</url>
    
    <content type="html"><![CDATA[<p>在<a href="/2023/05/04/SpringBoot-Lazy-Initialization/" title="SpringBoot-Lazy-Initialization">SpringBoot-Lazy-Initialization</a>提到，懒加载可以延迟容器中单实例的创建时机，从容器启动时延迟到实例被使用时。</p><p>在实际设置懒加载时，遇到了一些问题，在此记录并分析。</p><h2 id="静态方法访问">静态方法访问</h2><p>如果试图调用一个类的静态方法，而此方法依赖的静态变量需要通过实例去进行设置，启用全局懒加载就会导致<code>NPE（NullPointerException）</code>报错。</p><p>常见的场景是，编写一个<code>SpringContextUtil</code>工具类，用于从容器中根据条件（名称、类型）获取<code>bean</code>。<code>SpringContextUtil</code>通过实现<code>ApplicationContextAware</code>接口，来设置静态成员变量，并通过公共静态方法来向外暴露。一个典型的<code>SpringContextUtil</code>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringContextUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        applicationContext = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> &#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>SpringContextUtil</code>实例化时，通过<code>ApplicationContextAwareProcessor</code>后置处理器调用<code>setApplicationContext</code>方法，完成属性注入。具体的注入时机引用源代码注释。</p><blockquote><p>Invoked after population of normal bean properties but before an initcallback.</p></blockquote><p>问题在于，静态方法属于类，在懒加载的情况下，调用静态方法并不会引起类实例化，也因此不会对静态成员变量<code>applicationContext</code>进行设置，其值为引用类型的默认值<code>null</code>。此时调用静态方法<code>getBean</code>就会返回<code>NPE</code>。</p><p>解决的办法也很简单，就是将<code>SpringContextUtil</code>单独设置为非懒加载。由于<code>SpringContextUtil</code>是通过<code>@Component</code>注解，被组件扫描载入容器中，一种方法便是在<code>@ComponentScan</code>中设置<code>excludeFilters</code>属性。另一种更为简单优雅的做法是直接在<code>SpringContextUtil</code>类定义上添加<code>@lazy(false)</code>的注解。根据就近原则，会覆盖掉全局设置。</p><p>实际上<code>@lazy</code>有着很灵活的用法，可以添加在很多地方，在此不过多赘述。</p><h2 id="mybatis扫描懒加载">Mybatis扫描懒加载</h2><p>开启懒加载的另一种方式是通过设置<code>@ComponentScan</code>的<code>lazyInit</code>属性，将通过组件扫描载入的<code>bean</code>设置为懒加载。这么做是合理的。对于大型项目来说，通过组件扫描载入的<code>bean</code>数量远大于其他方式，而且是些影响范围较小的<code>bean</code>(相对于框架层)。这么设置可以较大程度加快程序启动，又尽可能避免了bug延迟暴露的问题。</p><p>但如此设置后，发现项目中的<code>Mybatis Mapper</code>并不会开启懒加载。研究后发现，<code>Mapper</code>扫描和组件扫描使用的并不是同一个扫描器。</p><p>查询<code>Mybatis</code>懒加载相关资料后，发现存在歧义。在<code>MyBatis</code>中，懒加载表示按需进行关联查询，这显然与<code>SpringBoot</code>中懒加载的含义不同。因此无法通过在<code>Mybatis</code>配置文件中，开启我们需要的<code>bean</code>懒加载功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>而<code>Mapper</code>扫描使用的是<code>ClassPathMapperScanner</code>。在<code>Mybatis</code>中，可以通过<code>@MapperScan</code>的<code>lazyInitialization</code>属性，设置<code>Mapper Bean</code>的懒加载。</p><p>但公司框架中使用的是<code>通用mapper</code>，<code>maven</code>坐标如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mapper&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>由于公司使用的<code>通用mapper</code>版本较早，仍未添加懒加载功能。新增懒加载的<ahref="https://github.com/abel533/Mapper/pull/874">PR</a>。</p><p>因此无法开启懒加载，只能使用全局懒加载。</p><h2 id="总结">总结</h2><p>在实际开发过程中，总会遇到预料之外的情况。调试、分析、学习的过程中积累的经验，远重要于解决问题本身。经过这次问题解决，对<code>Spring</code>、<code>Mybatis</code>框架的理解又更深入了一步。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Lazy Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven-compilation</title>
    <link href="/2023/05/17/Maven-compilation/"/>
    <url>/2023/05/17/Maven-compilation/</url>
    
    <content type="html"><![CDATA[<p>由于公司<code>Java</code>项目代码量庞大，使用<code>Maven</code>作为构建工具进行编译时，往往会花费较长时间。</p><p>进行代码测试时，修改一行代码，可能会引起整个项目重新编译。这是<code>Maven</code>的默认行为，一旦检测到代码变更，便重新编译改变文件对应的模块。但其实那些没有改动的代码，复用以前的编译结果即可。为此，引入了增量编译。</p><h2 id="增量编译">增量编译</h2><p>增量编译(Incremental Compilation)是指，只重新编译修改的代码文件。</p><p>大部分<code>Java</code>开发人员都使用<code>IDEA</code>作为<code>IDE</code>。<code>IDEA</code>自带的构建工具默认支持增量编译，<ahref="https://www.jetbrains.com/help/idea/compiling-applications.html#compile_module">官方文档</a>。</p><blockquote><p>When you change any class inside the build target and then executethe build action, IntelliJ IDEA performs the incremental build thatcompiles only the changed classes. IntelliJ IDEA also recursively buildsthe classes' dependencies.</p></blockquote><p><code>IDEA</code>还会进行依赖分析，以确定是否需要连带重新编译其他文件。</p><p>而<code>Maven</code>则默认不开启增量编译，<ahref="https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#optional-parameters">官方文档</a>。</p><blockquote><p>to enable/disable incremental compilation feature.</p><p>This leads to two different modes depending on the underlyingcompiler. The default javac compiler does the following:</p><ul><li>true <strong>(default)</strong> in this mode the compiler plugindetermines whether any JAR files the current module depends on havechanged in the current build run; or any source file was added, removedor changed since the last compilation. If this is the case, the compilerplugin recompiles all sources.</li><li>false <strong>(not recommended)</strong> this only compiles sourcefiles which are newer than their corresponding class files, namely whichhave changed since the last compilation. This does not recompile otherclasses which use the changed class, potentially leaving them withreferences to methods that no longer exist, leading to errors atruntime.</li></ul></blockquote><p><code>Maven</code>通过设置<code>&lt;useIncrementalcompilation&gt;</code>标签来控制增量编译行为。比较坑的地方是，选项的实际行为不符合常规理解。设置为<code>true</code>时，关闭增量编译，这是默认行为；设置为<code>false</code>时，开启增量编译。</p><p>根据官方文档，<code>Maven</code>会比较源文件(<code>.java</code>)和编译文件(<code>.class</code>)的时间戳。如果源文件的修改时间晚于编译文件，意味着上次编译后源文件发生了变动，文件需要重新编译。默认不推荐增量编译是因为<code>Maven</code>不会进行依赖检查，因此如果修改的位置删除了一个函数，而这个函数在别的源文件中被引用，会导致运行时出错。</p><h2 id="无文件变动">无文件变动</h2><p>无论是否开启增量编译，当所有源文件都没有发生改动时，编译并不会使任何文件重新编译。</p><p>Maven会有如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Maven">[INFO] Nothing to compile - all classes are up to date<br></code></pre></td></tr></table></figure><p>但在实际使用时，可能会出现一种情况：明明无文件变动，但导致了项目重新编译。这是因为项目代码中存在空文件。</p><p>空文件是指一个<code>.java</code>文件中，没有声明<code>public class</code>，使其并不会生成对应的<code>.class</code>文件。因此在进行时间戳对比时，会提示文件修改，导致项目重新编译。Maven提示如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Maven">[INFO] Changes detected - recompiling the module!<br></code></pre></td></tr></table></figure><p>这种情况一般发生在整个文件都被注释的情况。</p><h2 id="测试编译和跳过测试">测试编译和跳过测试</h2><p>在使用<code>Maven</code>进行<code>clean compile</code>后，运行单元测试，发现IDEA又将项目代码编译了一遍。由于未设置<strong>将IDE构建/运行操作委托给Maven</strong>，重新编译使用了<code>IDEA</code>原生构建工具。</p><p>研究后发现，<code>Maven</code>的<code>compile</code>阶段并不包括测试的编译，这可以从执行<code>mvn clean compile</code>命令后，<code>target</code>文件夹中并不会有<code>test-classes</code>文件夹生成可以看出。</p><p>因此在运行时，<code>IDEA</code>没有找到单元测试的<code>.class</code>文件，会再重新编译。</p><p>因此如果要编译整个项目，包括测试，需要使用<code>clean test</code>。但<code>test</code>阶段还默认绑定了单元测试运行，会将项目测试代码中带有<code>@Test</code>的方法都执行一遍，并生成测试报告。这也是日常开发不需要的，因此需要设置跳过测试运行。</p><p>如果去百度，可以搜到两条有关测试跳过的运行参数。</p><ul><li>-DskipTests</li><li>-Dmaven.test.skip=true</li></ul><p>这两条都可以跳过测试运行，区别是<code>-Dmaven.test.skip=true</code>还会额外跳过测试阶段，而<code>-DskipTests</code>只是跳过了测试阶段中的测试运行目标。</p><p>为了保证<code>Maven</code>编译完后可以直接运行单元测试，应该选择<code>-DskipTests</code>。</p><h2 id="总结">总结</h2><p><code>Maven</code>是最常用的构建工具，为了开启增量编译功能，需要在<code>pom</code>文件中将<code>compile</code>插件的<code>useIncrementalcompilation</code>属性设置为false。</p><p>如果希望<code>Maven</code>编译完后可以直接运行单元测试，需要至少使用<code>test</code>而不是<code>compile</code>。如果只希望编译测试代码，但跳过测试运行，需要设置运行参数<code>-DskipTests</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Incremental Compilation</tag>
      
      <tag>Test Compilation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Commit-Message</title>
    <link href="/2023/05/12/Git-Commit-Message/"/>
    <url>/2023/05/12/Git-Commit-Message/</url>
    
    <content type="html"><![CDATA[<p><code>Git</code>在<code>commit</code>时，必须输入<code>commit message</code>，来表示对提交内容的说明。没有则无法提交。</p><p>理论上，<code>commit message</code>可以输入任意内容。但如果参与多人协作开发和持续开发，就会有相应的规范，帮助程序员快速理解别人写的提交，或者回顾自己以前提交的作用。</p><p>目前应用最为广泛的规范是前端框架<code>Angular</code>提出的<ahref="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#-commit-message-format">Angular提交信息规范</a>（简称规范）。</p><h2 id="angular-commit-message-format">Angular Commit MessageFormat</h2><p>总的来说，规范要求，每次提交信息包含三部分。</p><p>1.信息头(<code>header</code>)</p><p>2.信息体(<code>body</code>)</p><p>3.信息尾(<code>footer</code>)</p><p>三个部分用空行间隔，来区分。其中<code>body</code>和<code>footer</code>为可选部分。</p><figure class="highlight plaintext"><figcaption><span>Message</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Commit">&lt;header&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><h3 id="header">header</h3><p>header是三个部分中最复杂的。包含三个区域<code>&lt;type&gt;</code>、<code>&lt;scope&gt;</code>和<code>&lt;short summary&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs header">&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;<br>  │       │             │<br>  │       │             └─⫸ Summary in present tense. Not capitalized. No period at the end.<br>  │       │<br>  │       └─⫸ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|<br>  │                          elements|forms|http|language-service|localize|platform-browser|<br>  │                          platform-browser-dynamic|platform-server|router|service-worker|<br>  │                          upgrade|zone.js|packaging|changelog|docs-infra|migrations|<br>  │                          devtools<br>  │<br>  └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|test<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;type&gt;</code>为必须项，所有可能的取值和意义如下。</p><blockquote><ul><li><strong>build</strong>: Changes that affect the build system orexternal dependencies (example scopes: gulp, broccoli, npm)</li><li><strong>ci</strong>: Changes to our CI configuration files andscripts (examples: CircleCi, SauceLabs)</li><li><strong>docs</strong>: Documentation only changes</li><li><strong>feat</strong>: A new feature</li><li><strong>fix</strong>: A bug fix</li><li><strong>perf</strong>: A code change that improves performance</li><li><strong>refactor</strong>: A code change that neither fixes a bugnor adds a feature</li><li><strong>test</strong>: Adding missing tests or correcting existingtests</li></ul></blockquote><p>其中用的最多的应该是<code>feat</code>、<code>fix</code>和<code>test</code>。</p><p><code>&lt;scope&gt;</code>为可选项，可能的取值人为规定，一般使用项目的某个模块名或业务名，用来表示提交的修改的影响范围。</p><p><code>&lt;short summary&gt;</code>为必须项。用一句话概括此次提交。此部分的要求如下。</p><blockquote><ul><li>use the imperative, present tense: "change" not "changed" nor"changes"</li><li>don't capitalize the first letter</li><li>no dot (.) at the end</li></ul></blockquote><p>这样子设置header的好处是，在查看<code>commit</code>历史记录时，可以选择只显示第一行内容。可以很快地理解每次提交的性质。</p><figure><img src="/img/commit-log.png" alt="commit-log" /><figcaption aria-hidden="true">commit-log</figcaption></figure><h3 id="body">body</h3><p>这一部分详细描述提交的内容，比如所做修改的动机，所做修改的思路，改动前后程序表现的对比。</p><p>规范相对于<code>header</code>来说很简单，仅仅是使用祈使句和现在时。</p><h3 id="footer">footer</h3><p>这一部分一般是使用Github时才会较多使用，主要用来引用提交所针对得<code>PR</code>或<code>issue</code>，另外也可以用来说明重大更改和弃用说明。</p><p>由于这一部分在公司内使用不多，大部分情况下为空即可，因此不过多介绍，详见<ahref="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#commit-message-footer">官方文档</a>。</p><h2 id="总结">总结</h2><p>使用<code>git commit</code>时需要输入<code>commit message</code>，目前最常用的规范是<code>AngularJS commit message format</code>。</p><p>此规范包含三部分，其中最重要的部分为<code>header</code>。<code>header</code>中需要指明修改的类型、影响的范围和简单的一句话概括。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Commit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Lazy-Initialization</title>
    <link href="/2023/05/04/SpringBoot-Lazy-Initialization/"/>
    <url>/2023/05/04/SpringBoot-Lazy-Initialization/</url>
    
    <content type="html"><![CDATA[<p>在<a href="/2023/04/13/SpringBoot-Testing/" title="SpringBoot-Testing">SpringBoot-Testing</a>提到，使用<code>Junit</code>测试<code>SpringBoot</code>项目时，需要使用<code>@SpringBootTest</code>来创建一个<code>Spring容器</code>。而当<code>@SpringBootTest</code>标注的测试类没有使用内嵌<code>@Configuration</code>注解时，会自动使用<code>@SpringBootConfiguration</code>上的配置。</p><blockquote><p>Automatically searches for a <span class="citation"data-cites="SpringBootConfiguration">@SpringBootConfiguration</span>when nested <span class="citation"data-cites="Configuration">@Configuration</span> is not used, and noexplicit classes are specified.</p></blockquote><h2id="springbootconfiguration"><code>@SpringBootConfiguration</code></h2><p><code>@SpringBootConfiguration</code>本身是一个合成注解，包含三个注解：</p><ol type="1"><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ol><p>其中，<code>@SpringBootConfiguration</code>本身也包含<code>@Configuration</code>，也就是可以在类中通过<code>@bean</code>注解往容器中添加<code>bean</code>。<code>@EnableAutoConfiguration</code>为自动配置功能，可以根据pom文件中的依赖，自动向容器中添加<code>bean</code>。<code>@ComponentScan</code>组件扫描在<a href="/2023/04/17/SpringBoot-Configuration/" title="SpringBoot-Configuration">SpringBoot-Configuration</a>已经阐述过。</p><p>测试往往只针对某个新写的方法，但默认的配置需要将整个应用程序环境都启动，会导致测试程序启动缓慢。一个很直观的解决方法就是使用自定义的配置类，而不是使用默认的主应用的程序环境。</p><h2 id="自定义配置类">自定义配置类</h2><p>前面提到<code>@SpringBootTest</code>标注如果带有内嵌<code>@Configuration</code>注解，则不会使用<code>@SpringBootConfiguration</code>上的配置。因此如果需要使用自定义配置类，需要在测试类上添加<code>@Configuration</code>或通过<code>@SpringBootTest</code>的<code>classes</code>属性指定自定义配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>内嵌自定义配置类需要定义在测试类中，并且使用<code>static</code>关键词修饰。</p><blockquote><p>static, non-private, non-final, nested classes annotated with <spanclass="citation" data-cites="Configuration">@Configuration</span></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = TestConfiguration.class)</span><br></code></pre></td></tr></table></figure><p>在自定义配置类中，可以如<a href="/2023/04/17/SpringBoot-Configuration/" title="SpringBoot-Configuration">SpringBoot-Configuration</a>中往容器中添加<code>bean</code></p><h2 id="懒加载">懒加载</h2><p>虽然Spring可以通过<code>Auto-configured Tests</code>和<code>@ComponentScan</code>来控制自动配置和包扫描规则，来避免不必要的bean导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;SomeExcludeClass.class&#125;)&#125;)</span><br></code></pre></td></tr></table></figure><p>但有时很难分清哪些被使用到，哪些没有被使用到，因为bean之间的依赖关系错综复杂。手动去控制自动配置规则和扫描规则太过繁琐。因此更直觉、简便的解决方法是使用懒加载。<ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.lazy-initialization">官方文档</a></p><blockquote><p><code>SpringApplication</code> allows an application to beinitialized lazily. When lazy initialization is enabled, beans arecreated as they are needed rather than during application startup. As aresult, enabling lazy initialization can reduce the time that it takesyour application to start.</p></blockquote><p>懒加载就是在<code>bean</code>被使用时才去实例化，而不是程序一启动就把所有的<code>bean</code>都实例化。因此可以加快程序的启动时间，但会增加用户使用时的延迟。</p><p>对于生产中的设备来说，启动时间（只启动一次，往往在半夜没用户使用时）、内存消耗是可以忽略的，但用户体验至关重要。因此生产实践中通常不开启懒加载。</p><blockquote><p>Lazy initialization can be enabled programmatically using the<code>lazyInitialization</code> method on<code>SpringApplicationBuilder</code> or the<code>setLazyInitialization</code> method on<code>SpringApplication</code>. Alternatively, it can be enabled usingthe <code>spring.main.lazy-initialization</code> property</p></blockquote><p>由于单元测试中容器是自动创建的，<code>lazyInitialization</code>和<code>setLazyInitialization</code>的方法无法执行，因此使用<code>application.properties</code>配置文件的方式是最简单优雅的。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.main.lazy-initialization</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>如果测试类需要使用独立的配置文件，可以在测试上使用<code>@TestPropertySource</code>注解来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestPropertySource(&quot;classpath:application-test.properties&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p><code>@SpringBootTest</code>标注的测试类，默认情况会使用<code>@SpringBootConfiguration</code>的环境设置。</p><p>如果需要使用自定义配置可以使用内嵌<code>@Configuration</code>或<code>@SpringBootTest</code>的<code>classes</code>属性。</p><p>懒加载是个加速程序启动的简单且有效方法。原理是将<code>bean</code>的实例化过程推迟到使用时才实例化。避免了测试过程中大部分<code>bean</code>都用不到，但会被实例化的问题。</p><p>在单元测试中，简单且优雅的方式是通过<code>application.properties</code>配置文件来开启懒加载。为了避免影响生产，通常采用测试独立的配置文件，并通过<code>@TestPropertySource</code>来指定。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Lazy Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Conflict</title>
    <link href="/2023/04/27/Git-Conflict/"/>
    <url>/2023/04/27/Git-Conflict/</url>
    
    <content type="html"><![CDATA[<p>最近在工作中频繁使用到了<code>Git</code>。虽然之前基本把<ahref="https://git-scm.com/book/en/v2">《ProGit》</a>读完了，但在实际使用中还是遇到不少问题。</p><p>究其原因，这可能因为国内的<code>Git</code>教程普遍基于命令行，并且只教最基础的使用。而大部分的开发人员往往使用集成在<code>IDE</code>中的<code>Git</code>，并且对于<code>Git</code>背后的原理和设计思路并不了解。</p><p>上一篇讲到当未<code>commit</code>的修改和将要进入的分支有<code>conflict</code>时，该怎么保存这些修改。这里将进入的分支可以是<code>checkout</code>到别的分支，或者是将要<code>update</code>、<code>rebase</code>、<code>merge</code>的分支。其中<code>checkout</code>引起的矛盾只有<code>IDE</code>才会发生，原生的命令行<code>Git</code>在那种情况下根本不允许<code>checkout</code>。但未详细说明什么是<code>conflict</code>，以及什么情况下会发生。</p><p>在<code>Git</code><ahref="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#_basic_merge_conflicts">官方文档</a>中，对于冲突只有一句简单的解释。</p><blockquote><p>If you changed the same part of the same file differently in the twobranches you’re merging, Git won’t be able to merge them cleanly.</p></blockquote><p>冲突发生在修改同一个文件同一个位置。同一个文件好理解，但修改是指什么，同一个位置又指什么？由于这部分内容实在未找到详细的文档，只能通过实验测试，来验证这两个到底指的什么意思。</p><h2 id="实验">实验</h2><p>实验设置很简单，初始化一个空的<code>Git</code>库，并在其中建立一个<code>txt</code>文本文件，通过进行不同的位置，不同类型的修改，观察是否触发<code>conflict</code>，来尝试找出其中规律。</p><p>修改的类型，主要是增加和删除两种，修改可以看作是删除和修改同时进行。</p><p>同一个位置，可以是同一光标，同一行，相邻行，或者间隔更大的行。</p><h3 id="修改类型初始化设置">修改类型初始化设置</h3><p>基于此，新建一个<code>ConflictTest.txt</code>文本文件，并初始化为如下。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br></code></pre></td></tr></table></figure><p><code>commit</code>后，新建分支<code>branch1</code>和<code>branch2</code>。</p><h3 id="同时增删">同时增删</h3><p>从直觉上讲，如果两个分支同时对一行代码进行了增加和删除，那么此时必然会发生冲突，因为两个分支上的改动是互相矛盾的，必须决定这些改动的去留。实验也证实了这一点。在实验中，一个分支将<strong>first</strong>删除，另一个分支在行末添加了<strong>.</strong>，并触发了<code>conflict</code>。结果也不会智能地合成<strong>Theline.</strong>。如果在同一行地不同位置进行了增删都会触发<code>conflict</code>，那在同一光标就更无疑问地会触发了。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">The line<br>===============<br>The first line.<br></code></pre></td></tr></table></figure><p>在提到智能地合成<strong>Theline.</strong>，其实默认了一种改动去留的规则，也就是将两个分支的改动都保留。而实际情况，根据对A，B分支改动的去留，共有四种情况。解决冲突的过程本质就是在决定，对于这些发生在同一位置的改动，是都留，都舍弃，还是只保留其中一侧的改动。</p><h3 id="同时删除">同时删除</h3><p>同时删除不同内容会触发<code>conflict</code>，而删除相同内容不会触发<code>conflict</code>，这也很符合直观理解。因为删除相同内容后，两个文件在这个位置地内容是完全相同的，不需要考虑改动的去留。</p><h3 id="同时增加">同时增加</h3><p>同时增加是有些争议的地方。添加相同内容不会触发冲突，这点原理和删除相同内容一样。但同时添加不同内容<code>Git</code>会如何处理就有些无法确定，<code>Git</code>是否会将两部分添加都保留。这种情况非常常见，例如两个人同时在代码文件最末尾添加了新的函数。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br>The second line 1<br>===============<br>The first line<br>The second line 2<br></code></pre></td></tr></table></figure><p>两个分支分别在文件末添加了不同的内容，实验结果触发了<code>conflict</code>。对于多人开发的场景，解决冲突的方式更多是将两个人的修改都保留。</p><h3 id="一侧改动另一侧没改动">一侧改动，另一侧没改动</h3><p>上面实验给人的感觉是，如果两个分支的文件内容不同，则发生冲突。但有一种情况两个文件不同时也会发生<code>conflict</code>。也就是当对一侧（分支）文件没有改动，另一侧没改动时。对此猜测，可能其中一侧的文件快照是另一侧的父/祖节点时（Git底层使用树的结构存储信息），则以更新的子节点为准。</p><p>为了验证这个猜测，对没改动的一侧进行了改动并提交，随后再进行一次改动，恢复初始状态并提交。此时原来没改动的一侧因为两次<code>commit</code>，文件的状态和另一侧不再是父/祖关系。此时合并两个分支，也没触发<code>conflict</code>。所以否定了两个文件不同时，父/祖关系可以避免<code>conflict</code>。</p><p>并且上面的测试，提交修改一次，再提交返回修改前状态，这也和矛盾最原始的定义有矛盾。即发生了同一文件同一位置的修改，但没<code>conflict</code>。</p><p>基于上述实验，本人猜测<code>Git</code>并不是对比了两个分支的文件，而是将两个文件和他们的共同祖先状态进行了对比。通过<code>diff</code>算法，计算了每个分支所做的修改。<code>Git</code>本身带有<code>diff</code>工具，但对其内部原理没有深究。通过对比两个分支的修改，如果修改发生在同一位置，那么则触发<code>conflict</code>。并且<code>IDE</code>提供的解决冲突的界面，三路合并，其中两路是两个分支的最新状态，另外一路是两个分支的共同祖先。这变相地也证明了对比的可能是两者从相同状态后，发生的差异。由于此部分内容没有查到详细资料，可能存在一定误解。</p><h3 id="修改位置初始化">修改位置初始化</h3><p>新建一个<code>ConflictTest.txt</code>文本文件，并初始化为如下。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br>The second line<br>The third line<br></code></pre></td></tr></table></figure><p><code>commit</code>后，新建分支<code>branch1</code>和<code>branch2</code>。</p><h3 id="修改位置">修改位置</h3><p>修改位置的实验相对简单。对其中一侧进行第一行修改，对另一侧进行第二/三行修改时，发生了不同结果（同一行已在之前测试）。第二行触发了<code>conflict</code>而第三行没有。如果简单点说，这样可能就把问题解决了，相同位置指的是相邻行。</p><p>但往复杂了说，怎么样定义相邻行。原本相邻的行，通过插入换行符，使得其不在相邻，再进行修改，这会引起冲突吗？</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line 1<br>The second line<br>The third line<br>===============<br>The first line<br><br><br>The second line 2<br>The third line<br></code></pre></td></tr></table></figure><p>答案是会。这可能因为差异是基于原祖先文件计算。一侧变动修改了第1行，另一侧变动修改了第2行，并且1行和2和之间插入了内容（空行）。这样看改动仍然发生在相邻行。</p><p>另外还有一种情况。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">branch1<br>The first line<br>The second line<br>The third line<br>===============<br>The first line<br>branch2<br>The second line<br>The third line<br></code></pre></td></tr></table></figure><p>此时在原来第1行之前、之后插入了内容。从某种程度上也算是相邻行，但没有触发<code>conflict</code>。所以说相邻行的解释也不够完备。</p><h2 id="总结">总结</h2><p><code>Git</code>在合并不同分支时，如果两个分支的同一文件状态不一致，则会计算其与共同祖先的差异。如果差异发生在相对于祖先文件的同一行或相邻行，则会引起<code>conflict</code>。</p><p>在解决冲突时，需要针对每个位置，决定是否舍弃和保留每个分支的改动。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Conflict</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Stash</title>
    <link href="/2023/04/19/Git-Stash/"/>
    <url>/2023/04/19/Git-Stash/</url>
    
    <content type="html"><![CDATA[<p>为了简化本地测试代码的过程，往往会对一些代码/配置进行修改。例如设置日志级别，开启Bean的懒加载，关闭一些不必要的服务。这些修改只发生在本地<code>工作区(Working Directory)</code>，不会<code>commit</code>到<code>本地仓库(Repository)</code>，更不会<code>push</code>到<code>远程仓库(Remote repositories)</code>。由于在<code>IDEA</code>中，默认没有启用<code>暂存区(Staging Area/Index)</code>，因此主要讨论的是<code>工作区</code>和<code>仓库</code>。</p><p>当<code>工作区</code>存在一些未<code>commit</code>的修改，并需要<code>checkout</code>到别的分支，并且这个分支也对被修改的文件做了其他修改，就会导致<code>冲突(conflict)</code>发生。</p><p>如果在<code>IDEA</code>中，发生了这样的冲突，则会不允许<code>checkout</code>。检查<code>IDEA</code>中的<code>git console</code>，错误信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: Your <span class="hljs-built_in">local</span> changes to the following files would be overwritten by checkout:<br>SomeFile.txt<br>Please commit your changes or stash them before you switch branches.<br>Aborting<br></code></pre></td></tr></table></figure><p>提示也十分明确，解决方法包括<code>commit</code>和<code>stash</code>。接下来就具体说明每一种方式是怎么解决的。</p><h2 id="commit">commit</h2><p>前面提到，这些修改本身是不想<code>commit</code>的，因为下次<code>push</code>时会默认将这个<code>commit</code>推送到远程仓库。实际情况中不会选择这种方案。</p><p>在<code>commit</code>之后，<code>工作区</code>、<code>本地仓库</code>就保持一致了，不存在未保存的信息。此时<code>checkout</code>到别的分支时没有任何报错。从别的分支再返回时，也能恢复这部分<code>工作区</code>修改。</p><p>如果需要在别的分支上也应用这部分修改，那么就需要合并分支，也就是<code>merge</code>和<code>rebase</code>。由于两个分支存在<code>冲突</code>，在合并时会需要先解决<code>冲突</code>。但这样做，在两个分支上都会有这部分修改的commit。</p><h2 id="stash">stash</h2><p><code>stash</code>是一个<code>git</code>命令，通过<code>stash</code>指令，可以将未提交的<code>工作区</code>和<code>暂存区</code>中的修改保存起来，并恢复到上一次<code>commit</code>的状态，像是将工作区<code>reset --hard</code>到了<code>HEAD</code>所指的版本。但修改部分的内容并没有丢失，像是有一个隐藏的临时<code>commit</code>。由于此时<code>工作区</code>和<code>本地仓库</code>保持一致，<code>checkout</code>到别的分支不会有任何问题。</p><p>在下次<code>checkout</code>回此分支时，可以通过<code>git stash pop</code>将<code>工作区</code>还原回之前的状态。像是<code>reset</code>回了之前的隐藏临时<code>commit</code>。如果在别的分支使用<code>git stash pop</code>，那么会发生<code>冲突</code>，但不会因此产生合并的<code>commit</code>。</p><h2 id="idea-shelve">IDEA Shelve</h2><p><code>IDEA</code>提供了一个功能上和<code>stash</code>几乎一样的<code>Shelve</code>。略微有些区别是stash默认操作整个<code>工作区</code>，而<code>Shelve</code>可以通过<code>GUI</code>选择单个文件或<code>Changelist</code>。<code>Changelist</code>是<code>IDEA</code>提供的将未提交修改分组的功能。</p><h2 id="总结">总结</h2><p>只有在<code>工作区</code>，<code>暂存区</code>和<code>版本库</code>一致时，也就是<code>working tree clean</code>时，才能<code>checkout</code>到别的分支。我们使用的<code>IDE</code>可以自动<code>stash</code>或<code>Shelve</code>，使得这三者不一致时也能<code>checkout</code>。但如果发生<code>冲突</code>，就需要手动解决<code>冲突</code>。</p><p>对于一些便于测试的代码/配置修改，相较于<code>commit</code>更推荐<code>stash</code>或<code>Shelve</code>。如果使用的是<code>IDEA</code>，那么更推荐<code>Shelve</code>，因为其提供了<code>GUI</code>，并且可以方便地指定暂存部分修改。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Stash</tag>
      
      <tag>Shelve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Configuration</title>
    <link href="/2023/04/17/SpringBoot-Configuration/"/>
    <url>/2023/04/17/SpringBoot-Configuration/</url>
    
    <content type="html"><![CDATA[<p>前面提到，对于<code>Spring</code>项目来说，项目的功能取决于<code>Spring容器</code>中有哪些<code>bean</code>，每一个<code>bean</code>都是一个功能模块的实例化对象。所以问题就来到了如何向<code>Spring容器</code>中添加<code>bean</code>。</p><h2 id="xml-配置文件">XML 配置文件</h2><p><code>XML配置文件</code>是最原始的添加<code>bean</code>的方式。使用<code>XML配置文件</code>符合了<code>配置文件分离</code>的原则。可以通过修改<code>XML配置文件</code>直接修改程序的功能，而不需要将项目重新编译。</p><p>在<code>XML配置文件</code>中通过<code>&lt;bean&gt;</code>标签来声明一个<code>bean</code>，并指定其类名、属性、依赖关系等信息，将该<code>bean</code>注册到<code>Spring</code>容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;anotherBean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此处定义了一个<code>bean</code>，为<code>com.example.MyBean</code>类的实例对象，其标识符通过<code>id</code>属性指定。通过<code>&lt;property&gt;</code>标签，可以对其成员变量进行属性注入。对于基础数据类型，可以直接使用<code>value</code>属性进行赋值；对于对象数据类型，可以使用<code>ref</code>属性进行引用，属性值为另一个容器中<code>bean</code>的<code>id</code>。也可以通过设置<code>bean</code>的<code>autowire</code>属性来指定是否采用自动注入。例如可以指定<code>autowire="byType"</code>来采用类型匹配自动注入。如果容器中符合成员变量类型的<code>bean</code>只有一个，那么就可以自动赋值。</p><p>启动时，通过指定<code>XML配置文件</code>，即可启动<code>Spring容器</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;configuration.xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>在定义<code>bean</code>时，还有许多可配置属性。但作为便于理解的笔记，这部分内容此处不再深入，可以在需要的时候去查相关文档。</p><ul><li><code>id</code>：指定 bean 的唯一标识符，用于在容器中进行引用。</li><li><code>class</code>：指定 bean 的类名，用于实例化 bean 对象。</li><li><code>scope</code>：指定 bean 的作用域，包括singleton（单例，默认值）、prototype（原型）、request（请求）、session（会话）等。</li><li><code>init-method</code>：指定 bean 初始化时调用的方法。</li><li><code>destroy-method</code>：指定 bean 销毁时调用的方法。</li><li><code>property</code>：用于设置 bean 的属性值。</li></ul><p>其中可以指定<code>bean</code>的初始化<code>init-method</code>和销毁方法<code>destroy-method</code>，这也是上篇提到的管理<code>bean</code>生命周期的功能。</p><h2 id="组件扫描">组件扫描</h2><p>如果需要往容器中添加一百个<code>bean</code>，那么需要在<code>XML配置文件</code>中写一百个<code>&lt;bean&gt;</code>标签，过程十分繁琐。实际项目中，需要添加到容器中的<code>bean</code>往往是自己写的<code>Java类</code>，这些<code>Java类</code>在<code>类路径</code>上通常有特点，例如处于某个包之下。指定某个<code>类路径/包</code>下的所有<code>Java类</code>都加入到<code>Spring容器中</code>这个想法就十分自然。这种批量添加<code>bean</code>的方式叫组件扫描。</p><p><code>XML配置文件</code>中开启组件扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用注解<code>@ComponentScan</code>开启组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages=&quot;com.example&quot;)</span><br></code></pre></td></tr></table></figure><p>组件扫描需要搭配<code>@Component</code>使用，这是一个类注解。只有扫描路径下带有<code>@Component</code>注解的类才会被添加到容器，没有的类则会被忽略。组件扫描<code>@ComponentScan</code>和<code>@Component</code>组合使用可以灵活地控制路径下哪些类会被添加入容器。</p><p>除了<code>@Component</code>，还可以通过设置<code>@ComponentScan</code>的<code>includeFilters</code>和<code>excludeFilters</code>属性，来灵活地自定义扫描路径下的过滤规则。</p><h2 id="配置类configuration">配置类@Configuration</h2><p><code>Java</code>的注解特性太过便捷，<code>Spring</code>项目逐渐从传统<code>XML配置文件</code>方式向注解方式迁移，这种大量依赖注解来配置和管理<code>Spring容器</code>中的<code>Bean</code>的方式叫<code>注解驱动</code>。</p><p>在<code>注解驱动</code>下，一个<code>XML配置文件</code>对应于一个带有<code>@Configuration</code>注解的<code>Java类</code>。<code>XML配置文件</code>中所有的标签，都有对应的定义方式。其中最重要的<code>&lt;bean&gt;</code>标签，在配置类中对应一个方法。这个方法会被添加<code>@bean</code>注解，并且要求返回一个<code>对象实例</code>或对象的<code>工厂bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回Bean的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要一提的是，配置类本身也是一个<code>bean</code>，存在于容器中。</p><p>基于单一职责原则，一般一个配置类往往只负责一类高度相关的功能。要开启某个功能往往就是把这个功能对应的配置类加入到容器中。配置类就会自动把功能相关的bean注册到容器中。</p><h2 id="importresource"><span class="citation"data-cites="ImportResource">@ImportResource</span></h2><p>实际项目开发中，可能会同时运用<code>XML配置文件</code>和<code>@Configuration配置类</code>。<code>配置类</code>作为主流的导入<code>bean</code>方式，那么就需要提供在其中引入<code>XML配置文件</code>的方法。<code>@ImportResource</code>就是这个作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(&quot;classpath:appCtx-dubbo.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在公司项目中，提供的对外Dubbo服务没有采用<code>配置类</code>的方式，而是将其写在了<code>XML配置文件</code>。通过在<code>XML文件</code>引入<code>xmlns:dubbo</code>，在文件内部可以使用dubbo提供的特定标签<code>&lt;dubbo:service&gt;</code>来注册服务。然后通过<code>@ImportResource("classpath:appCtx-dubbo.xml")</code>将生产者和消费者对应的<code>bean</code>加入到容器中。</p><h2 id="import"><span class="citation"data-cites="Import">@Import</span></h2><p>在Java配置类上使用<code>@Import</code>注解，将其他Java配置类引入当前配置类中，从而将这些配置类中定义的<code>Bean</code>一同注册到<code>Spring容器</code>中。<code>@Import</code>也能导入非配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;AnotherConfig.class, YetAnotherConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-comment">// 引入其他配置类中的Bean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相较于<code>@bean</code>的方式，<code>@Import</code>要简单很多。由于<code>@bean</code>注解在方法之上，可以通过编程式对每个<code>bean</code>进行细粒度的配置，而<code>@Import</code>就没法进行细粒度的控制。</p><p><code>@Import</code>通常也用于注解之上，使其变得更容易理解。例如<code>@Import(AspectJAutoProxyRegistrar.class)</code>就是<code>@EnableAspectJAutoProxy</code>上的注解。开启自动代理功能，本质就是导入了<code>AspectJAutoProxyRegistrar.class</code>注册器。注册器中，通过重载了<code>registerBeanDefinitions</code>的回调方法，向容器中动态注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>，从而开了<code>AspectJ</code>代理功能。相较于<code>@Import(AspectJAutoProxyRegistrar.class)</code>，<code>@EnableAspectJAutoProxy</code>更具有语义化。实际上，大部分的<code>@Enablexxx</code>本质都是利用了<code>@Import</code>导入了一些特殊的<code>bean</code>。</p><h2id="实现beanfactorypostprocessor接口">实现BeanFactoryPostProcessor接口</h2><p>这种方式作为用户不常用。一般作为开发者设计第三方库时的选择。</p><p>通过自定义一个实现了<code>BeanFactoryPostProcessor</code>接口的类，在其<code>postProcessBeanFactory()</code>方法中使用<code>BeanDefinitionRegistry</code>接口手动注册Bean到Spring容器中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 使用BeanDefinitionRegistry接口手动注册Bean</span><br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(MyBean.class);<br>        beanFactory.registerBeanDefinition(<span class="hljs-string">&quot;myBean&quot;</span>, beanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上还有<code>ImportBeanDefinitionRegistrar</code>。由于这部分内容找到的资料不多且良莠不齐，在此不深入讨论。</p><p>总的来说，这类方式是通过实现接口中预先定义的回调函数，在<code>Spring容器</code>启动过程的早期阶段会调用这些函数。在这些函数中，可以获取到<code>Spring容器</code>，并通过<code>Spring容器</code>的注册方法向其中注册自定义<code>bean</code>。</p><p>这部分内容令人感到困惑的原因是，<code>Spring容器</code>本身有多个接口和实现类，其中有许多都提供了注册方法。</p><h2 id="总结">总结</h2><p><code>Spring</code>应用的功能取决于其中的<code>bean</code>。向容器中添加/注册<code>bean</code>可以通过许多形式。其中最常用的是通过<code>@Configuration</code>的方式自定义配置类。结合<code>SpringBoot</code>的<code>AutoConfiguration</code>，可以很容易将各种应用集成到<code>Spring</code>中。由于<code>AutoConfiguration</code>内容太复杂，限于篇幅放到下一篇。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Testing</title>
    <link href="/2023/04/13/SpringBoot-Testing/"/>
    <url>/2023/04/13/SpringBoot-Testing/</url>
    
    <content type="html"><![CDATA[<p>在写上一篇<code>IoC</code>和<code>DI</code>之前，本来想记录的是<code>SpringBoot</code>如何完成<code>AutoConfiguration</code>自动配置，但因为篇幅直接分离出来了一篇。这次又把<code>Testing</code>给分离了出来。</p><p>事情的起因是，写项目代码时，常常需要对自己写的部分进行测试和调试。根据自己以往的编程经验，个人习惯于写一点就运行一点，并通过断点调试来确认内存的运行状态，避免犯一些低级的逻辑错误。虽然公司有专门的测试岗位，但从代码提交到GitLab请求合并，到部署到测试服务器，到测试人员设计用例并测试，到反馈到开发人员，整个过程涉及多个人员，太过漫长。而一些代码本身就需要反复调试，例如写了一些数据库操作，需要确认数据库实际执行结果是否符合预期。例如一个循环的跳出是否符合预期。执行结果符合预期本身是个很玄乎的事，很多时候代码看起来没啥问题，跑起来却又满脸问号。询问同事，都回答说让测试去测。而我觉得开发人员有义务确保代码没有低级的逻辑错误。</p><h2 id="junit">JUnit</h2><p>在<code>SpringBoot</code>框架中，常用的测试框架是<code>JUnit</code>。现在最新版本<code>SpringBoot3.0.5</code>对应的<code>Junit5</code>版本，<ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing">官方文档</a>。公司内部使用的是<code>Junit4</code>。</p><p>对于<code>JUnit</code>框架内部原理暂时没深入了解。从使用角度，常常会对需要测试的类，新生成一个对应的测试类，命名规范通常为<code>新测试类命 = 旧类命 + "Test"</code>。例如有一个<code>Calculator</code>类，那会新定义一个<code>CalculatorTest</code>测试类，并在测试类中定义成员测试方法，对应于被测试类中的方法。在每个成员方法中添加注解<code>@Test</code>，通过IDE或者构建工具就可以自动执行测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Addition方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtraction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Subtraction方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还可以编写其他测试方法...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在测试中，可以通过构建测试用例，并使用断言，将方法输出和预期输出进行对比。还可以使用代码覆盖率工具，来分析测试覆盖率。这些是<code>JUnit</code>核心功能，其他功能暂时还未深入了解。</p><h2 id="testing-in-springboot">Testing in SpringBoot</h2><p>在<code>SpringBoot</code>中，一个应用有什么功能，取决于在容器中有哪些<code>Bean</code>实例。例如我需要访问数据库，容器中必须要有<code>JDBC</code>相关的<code>Bean</code>，我需要处理<code>web</code>请求，容器中必须有<code>Tomcat</code>和<code>Sevlet</code>相关的<code>Bean</code>。</p><p>如果采用上文的方式去测试<code>Spring</code>项目中某个模块，那必然会报错。因为<code>JUnit</code>并不会像<code>Spring</code>一样启动，并将这些功能<code>Bean</code>添加到容器中。也就无法完成例如依赖注入等功能。</p><p>为了让<code>JUnit</code>能启动容器环境，<code>Spring</code>提供了<code>@SpringBootTest</code>注解。只需要在测试类前添加<code>@SpringBootTest</code>，就可以在测试时启动<code>Spring</code>容器。如果不指定注解的<code>classes</code>属性，也就是启动的配置类，那么会将主应用程序类，也就带有<code>@SpringBootApplication</code>注解的类作为配置类。</p><p>另外，如果使用的是<code>JUnit4</code>，还需要在测试类上额外添加<code>@RunWith(SpringRunner.class)</code>。需要这么做的原因涉及<code>JUnit</code>框架原理，在此不深究。</p><p>但问题是，使用<code>@SpringBootTest</code>注解时，会创建一个真实的<code>SpringBoot</code>上下文，并加载所有的<code>Bean</code>，这会导致测试的运行速度较慢。测试可能往往只是想测一个刚写完的某个方法，但却需要将许多不相关的<code>Bean</code>都加载进来，这会造成严重性能浪费。较长的测试启动时间也会大大降低测试时的主观感受。</p><p>要解决这个问题，就需要知道容器里的<code>Bean</code>是怎么样的方式被加载进去的，已经如何自定义加载需要的<code>Bean</code>，这也是下一篇要讨论的内容。</p><h2 id="总结">总结</h2><p><code>JUnit</code>是<code>Java</code>中最公认的测试框架。使用时只需要在测试类的测试方法上加<code>@Test</code>注解，即可对目标方法进行测试。在测试类中，可以使用许多功能并生成测试报告，来判断目标方法是否按照预期执行。</p><p>由于<code>JUnit</code>框架默认不会启动<code>Spring</code>容器，而<code>Spring</code>应用的功能依赖于<code>Spring</code>容器。因此直接使用<code>JUnit</code>测试<code>Spring</code>项目中的类会发生错误。可以使用<code>@SpringBootTest</code>在测试类中启动<code>Spring</code>容器环境。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-IoC-DI</title>
    <link href="/2023/04/13/SpringBoot-IoC-DI/"/>
    <url>/2023/04/13/SpringBoot-IoC-DI/</url>
    
    <content type="html"><![CDATA[<p>在讨论<code>Spring</code>框架时，其中最核心的组件莫过于<code>Spring Core</code>。而<code>Spring Core</code>完成了两个关键概念：<code>IoC</code>（Inversionof Control，控制反转）和<code>DI</code>（DependencyInjection，依赖注入）。</p><h2 id="ioc">IoC</h2><p><code>IoC</code>是一种设计模式，它将对象的创建和管理的控制从应用程序代码转移到了容器中。在Java当中，为了提高代码的复用率和可维护性，我们采用模块化编程，将功能相关的代码抽取成一个类/模块。在本文中，模块专指提供方法，被其他类调用的类，本身也是一个类；而模块的调用类就称为类。</p><p>如果不采用<code>IoC</code>，使用某个模块的方法时，需要通过<code>new</code>关键字创造对象，再调用其中的方法，或者通过模块类直接调用其中的静态方法。这样在代码中需要显示地创建对象。并且如果一个模块在多个类中被使用时，会被重复创建多次，造成性能浪费。如果采用单实例，则需要通过构造函数显示地将实例传递进来。这在一个模块被多个类使用，一个类会使用多个模块的情况下变得十分繁琐。</p><p>而在<code>IoC</code>模式下，所有类的实例都会由容器统一创建并管理。容器本身很像<code>HashMap</code>，可以通过类名/类型等作为<code>key</code>，从容器中获取到<code>value</code>实例对象。当需要在某个类中使用某个模块的方法，不再需要手动创建，而是直接从容器中获取已经创建好的实例对象。这就是<code>IoC</code>创建对象实例的功能。实际上<code>IoC</code>常还被用来解决对象之间的依赖关系、处理对象的生命周期等，在此不赘述。</p><p>从描述中可以发现，每个模块的实例化时机也发生了变化。本来是在每次将被访问时，<code>new</code>一个实例；而<code>IoC</code>一般是在程序启动时就将所有模块进行实例化并放入容器。但这本身也可以通过配置项进行修改。</p><h2 id="di">DI</h2><p>在上文介绍中，<code>IoC</code>管理了实例的创建，并将所创实例统一用一个容器进行管理访问。那么每当需要使用某个模块时，操作变成了从容器中获取实例，再调用实例的方法。当一个类中有多个方法都使用同一个实例，这个实例会在每个方法中都需要获取一次。因为方法内定义的是局部变量，方法运行结束就会出栈。为了简化开发，可以将用到的实例都设置为成员变量，这样实例的作用域扩大到整个类，所有成员方法都能使用。额外一提，将实例设置为成员变量，只会记录实例的指针/引用，并不会新建一个实例，因此其开销是可接受的。这种将某个实例赋值给成员变量的过程，叫依赖注入。</p><p>但问题还存在，每个成员变量的初始化该怎么操作。可以通过直接在声明时赋值、使用代码块初始化，或者通过构造函数初始化。但无论使用哪种方式，为每个成员变量显示地从容器中根据类名/类型获取实例的代码不可避免。实际情况中，大部分实例在容器中都是单实例模式的，这意味着根据成员变量的类型，在容器中有且仅能获取到一个。</p><p>为了简化开发，<code>Spring</code>提供了<code>@Autowire</code>注解。只需要在每个实例成员变量上添加这个注解，<code>Spring</code>就会在创建对象时，自动从容器中找到每个成员变量对应的单实例并赋值。这里也引出了新的问题，如果被引用的实例还没创建该怎么办，循环引用了该怎么办。这些问题可以单独再写一篇，在此略过。</p><h2 id="总结">总结</h2><p>通过<code>IoC</code>和<code>DI</code>，程序员的开发过程变成了：</p><ol type="1"><li>开发每个模块，并通过<code>IoC</code>将模块实例化并放到容器中。</li><li>在需要引用模块的地方，声明模块实例的成员变量，并通过<code>@Autowire</code>关键字实现<code>DI</code>。</li></ol><p>如果不使用<code>IoC</code>，那么程序员将难以知晓创建了多少实例，每个实例的状态，每个实例的生命周期。而<code>IoC</code>将创建的实例统一放在了容器当中，相当于提供了一个控制台，可以很容易的获取每个实例的信息。如果不使用<code>DI</code>，那么在每个类中调用某个模块的方法会十分繁琐。而通过<code>成员变量</code>+<code>DI</code>的模式，可以清楚地读到每个类依赖了哪些模块，并简化开发流程。</p><p>通过<code>IoC</code>和<code>DI</code>，整个过程的耦合度大大降低，基于这种模式的开发也成为了最佳实践。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-ConfigurationProperties</title>
    <link href="/2023/04/07/SpringBoot-ConfigurationProperties/"/>
    <url>/2023/04/07/SpringBoot-ConfigurationProperties/</url>
    
    <content type="html"><![CDATA[<p>写代码时，常会在代码中使用配置相关的常量。</p><p>对于这些配置常量，最佳实践是配置文件分离，即将这些配置常量写入一个配置文件中。常见的配置文件包括如properties、XML文件、JSON文件、YAML文件。这样每次修改配置时，不需要改动源文件并重新编译，也不需要通过命令行传参，只需改动配置文件中对应属性即可。而且把配置信息放在一起会使代码可读性，可维护性更好。</p><h2 id="java中的配置文件">Java中的配置文件</h2><p>Java的常用配置文件为properties文件。可以通过<code>FileInputStream</code>或<code>ClassLoader</code>来读取配置文件。并通过包装成<code>Properties</code>对象，来解析文件中的属性。由于Java的配置文件通常位于类路径下，因此使用<code>ClassLoader</code>来读取有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-comment">// 使用ClassLoader获取配置文件的输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getClassLoader().getResourceAsStream(fileName);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to find &quot;</span> + fileName + <span class="hljs-string">&quot; in classpath&quot;</span>);<br>    &#125;<br>    properties.load(inputStream);<br>    inputStream.close();<br>    <span class="hljs-keyword">return</span> properties;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后需要将配置文件中的属性赋值到Java类的字段上。这种配置文件和类字段映射的思想叫做<code>配置文件驱动开发</code>。</p><p>但在实际开发中，一整个项目的配置信息是十分多的。如果对于每一个配置属性都显式地赋值给一个类字段，那整个赋值过程会十分繁琐。因此需要一种方式，能将配置文件自动映射到类字段上。</p><h2 id="configurationproperties">ConfigurationProperties</h2><p>谈到Java开发就离不开Spring（SpringBoot）。Spring提供了许多常见且通用的功能和工具来简化Java 应用程序的开发，例如上文提到的配置文件的自动映射。</p><p>在Spring当中，如果需要将配置文件映射到某个类上，那么只需要在这个类上添加<code>@ConfigurationProperties</code>注解，并将这个类在Spring容器中实例化，Spring就会自动完成配置属性注入的功能。</p><p>具体实现时，通常有两种方式。</p><ol type="1"><li><p><code>@ConfigurationProperties</code> +<code>@Component</code></p></li><li><p><code>@ConfigurationProperties</code> +<code>@EnableConfigurationProperties</code></p></li></ol><p>其中<code>@ConfigurationProperties</code>加在需要配置属性注入的类上，并在注解中指定配置属性的前缀。并通过<code>@Component</code>将类加入到容器中。需要注意的是，通过这种方式需要确保在主配置类中开启了<code>@ComponentScan</code>，并且能扫描到此类。</p><p>而Spring的默认配置文件名为<code>application.properties</code>，且位于类路径的根目录下。这是Spring的<code>默认大于配置</code>软件设计原则。也就是如果没特殊情况，大家都遵守这样的约定。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">abc.name</span>=Tom<br><span class="hljs-attr">abc.version</span>=V1.<span class="hljs-number">1</span><br><span class="hljs-attr">logging.level.root</span>=info<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处定义了<code>MyConfiguration</code>类，并且包含两个字段<code>name</code>，<code>version</code>，字段名与配置文件中的属性键去掉前缀对应。并通过<code>@ConfigurationProperties(prefix = "abc")</code>注解指定了配置文件中的前缀，这样就可以在配置文件中通过前缀组织不同配置的属性。</p><p>或者，可以使用<code>@EnableConfigurationProperties</code>，添加在主配置类上，此时可以将属性注入的类上的<code>@Component</code>去掉，否则容器中会有两个<code>MyConfiguration</code>的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyConfig.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>@EnableConfigurationProperties</code>中指定需要开启属性注入功能的类。</p><p>但在实际过程中，出现了一些问题。</p><h2 id="遇到的问题">遇到的问题</h2><p>在实际学习过程中，属性注入一直失败。最后排查发现，对于属性注入的类，还需要配置Setter方法。这是因为配置属性注入，是通过Java反射，调用了对应的Setter方法。可以自行显示地定义Setter方法，或者使用<code>@Data</code>注解，自动生成类的Getter、Setter方法。</p><p>但在定义完Setter方法后，使用<code>@ConfigurationProperties</code> +<code>@Component</code>的方式配置属性注入依旧无法完成。通过对类属性打上断点，并查看调用栈，发现要使用这种方式完成配置属性注入，容器内必须要有<code>ConfigurationPropertiesBindingPostProcessor</code>。这是一个<code>BeanPostProcessor</code>，本质也是一个Bean，但和普通Bean的不同在于它可以参与Bean的实例化过程，以对其他Bean进行属性修改或功能增强。而在不使用<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>的最小配置启动下，默认没有向容器中导入这个<code>BeanPostProcessor</code>。</p><figure><img src="/img/ConfigurationPropertiesBindingPostProcessor.png"alt="ConfigurationPropertiesBindingPostProcessor" /><figcaptionaria-hidden="true">ConfigurationPropertiesBindingPostProcessor</figcaption></figure><p>并且在调用栈中，可以观察到最后是通过反射的方式，调用Setter方法来完成了配置属性注入。</p><figure><img src="/img/SetName.png" alt="SetName" /><figcaption aria-hidden="true">SetName</figcaption></figure><p>而使用<code>@ConfigurationProperties</code> +<code>@EnableConfigurationProperties</code>的方式则不需要<code>@EnableAutoConfiguration</code>配置项。通过调试发现，<code>@EnableConfigurationProperties</code>带有<code>@Import(EnableConfigurationPropertiesRegistrar.class)</code>注解，而<code>EnableConfigurationPropertiesRegistrar</code>在方法<code>registerBeanDefinitions</code>中，向容器中注册了<code>ConfigurationPropertiesBindingPostProcessor</code>，而后被实例化以提供配置属性注入的功能。</p><p>这一部分内容很涉及框架层面的内容，暂时不准备挖的更深。总之，<code>@EnableConfigurationProperties</code>本身就会向容器内导入<code>ConfigurationPropertiesBindingPostProcessor</code>，因此不需要<code>@EnableAutoConfiguration</code>也能完成配置属性注入工作。</p><h2 id="总结">总结</h2><p>配置文件分离是软件部署的最佳实践，熟悉其过程和原理也是每个程序员的必修课。在Spring框架中，使用<code>@ConfigurationProperties</code>来完成配置文件与类的绑定，在使用时需要指定每个类对应配置文件键的前缀。并把这个类放入容器中，以被<code>ConfigurationPropertiesBindingPostProcessor</code>完成属性注入的功能。而<code>ConfigurationPropertiesBindingPostProcessor</code>可以通过<code>@EnableAutoConfiguration</code>或<code>@EnableConfigurationProperties</code>导入。<code>ConfigurationPropertiesBindingPostProcessor</code>最终是通过Java反射完成属性注入，需要调用对应的Setter方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>ConfigurationProperties</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除/高亮页面元素的JS脚本</title>
    <link href="/2023/04/06/remove-highlight-javascript/"/>
    <url>/2023/04/06/remove-highlight-javascript/</url>
    
    <content type="html"><![CDATA[<p>最近开发了一个基于TamperMonkey的JS脚本，其主要功能为去除特定页面中的广告、Header等无效信息元素，并根据逻辑高亮其中重要信息元素。</p><p><a href="https://github.com/DracoYus/lolalytics-light">Github</a></p><p>从解决需求角度出发，常见的去除页面中的广告可以通过CSS植入，并利用样式选择器将广告元素的display属性设置为none。但需要根据逻辑高亮元素（如经过元素内文本排序后，对前n位进行高亮），简单的CSS植入无法满足这个需求。因此最后采用了TamperMonkey执行JS脚本的方案，利用JS操纵DOM元素来达到去除/高亮元素的目的。</p><p>目标页面采用了懒加载处理，可见范围外的元素不会提前加载。而TamperMonkey的内置执行时机，只能在页面开始加载或加载完成后执行一次。对于页面加载完成后，动态新加载的元素，无法完成功能。</p><table><thead><tr class="header"><th><span class="citation" data-cites="run-at">@run-at</span></th><th>Timing</th></tr></thead><tbody><tr class="odd"><td>document-start</td><td>as fast as possible</td></tr><tr class="even"><td>document-body</td><td>body element exists</td></tr><tr class="odd"><td>document-end</td><td>when or after the DOMContentLoaded event was dispatched</td></tr><tr class="even"><td>document-idle</td><td>after the DOMContentLoaded event was dispatched</td></tr><tr class="odd"><td>context-menu</td><td>it is clicked at the browser context menu</td></tr></tbody></table><p>由于页面的动态加载，需要多次执行目标函数。一种做法是，通过<code>setInterval</code>函数来指定目标函数每隔一段时间执行。这样的优点是编码简单，缺点是消耗系统资源，不太优雅。页面动态加载会导致DOM元素的增加或减少，因此更为优雅的做法是注册事件，当页面元素发生变化时，重新执行目标函数，这就用到了<code>MutationObserver</code>。</p><h2 id="mutationobserver">MutationObserver</h2><p><code>MutationObserver</code>可以检测页面元素属性变化、子节点的添加或删除、文本内容的变化等。</p><p><code>MutationObserver</code> 的使用步骤如下：</p><ol type="1"><li><p>创建一个 MutationObserver对象，传入一个回调函数作为参数，该回调函数将在 DOM树变化时被调用。在此问题中，callback就是去除/高亮页面元素的函数。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br></code></pre></td></tr></table></figure></p></li><li><p>使用 <code>observe</code> 方法开始监视 DOM元素的变化，传入要观察的 DOM 元素以及要观察的变化类型的配置对象。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">observer.<span class="hljs-title function_">observe</span>(target, options);<br></code></pre></td></tr></table></figure></p><p><code>target</code> 是要观察的 DOM元素，一般为<code>document.documentElement</code>，表示监视整个页面文档的元素变化。<code>options</code>是一个配置对象，用于指定要观察的变化类型。此处为<code>&#123;childList: true, subtree: true&#125;</code>，表示检测target以及其子节点的元素变化。如果不设置，默认只监测<code>target</code>本身，子节点的添加和减少不会被监测到。</p></li><li><p>在回调函数中处理 DOM 变化的情况。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">mutationsList, observer</span>) &#123;<br>  <span class="hljs-comment">// mutationsList 是一个 MutationRecord 对象的数组，包含了发生的 DOM 变化</span><br>  <span class="hljs-comment">// observer 是当前的 MutationObserver 对象</span><br><br>  <span class="hljs-comment">// 在这里处理 DOM 变化的情况</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>回调函数可以接收到发生变化的元素的信息。可以通过判断改变的是哪个元素，来具体执行去除/高亮的动作。在本项目中，为了偷懒并没有在此进行判断。</p></li></ol><h2 id="引发的问题">引发的问题</h2><p>在采用<code>MutationObserver</code>之后，页面出现了无法加载的情况。通过调试器查看到，目标函数被反复调用，整个页面陷入卡死的状态。猜测是页面元素发生变动，调用了目标函数后，目标函数也改变了页面元素（但是我的代码里没有啊？），反复触发了<code>MutationObserver</code>的目标函数，形成了递归死循环。为了解决这个问题，了解了函数防抖和函数节流。</p><h2 id="函数防抖和函数节流">函数防抖和函数节流</h2><p>函数防抖和函数节流都是用于限制某个函数的执行频率。如果函数调用的频率小于设定的阈值，那么是否采用函数防抖和函数节流对程序执行没有任何区别。</p><p>防抖的基本思想是在一定的时间间隔内，只执行最后一次触发事件的处理函数，忽略在此时间间隔内的其他触发事件。与函数防抖不同，函数节流是在一定的时间间隔内，定期执行事件处理函数。</p><p>函数防抖就像拍卖，拍卖成功（目标函数执行）会在敲三锤（一定间隔后）执行，一旦在敲三锤前进行了竞拍（再次调用用防抖包裹的目标函数），那么间隔会被重置。</p><p>函数节流就像大学抢浴室。一个人进了浴室（调用用节流包裹的目标函数），其他人再想进去（再次调用用节流包裹的目标函数）就不行，必须等这个人洗完（一定间隔），一旦他洗完（目标函数执行），所有人都可以再次抢浴室（调用用节流包裹的目标函数）。从某种角度，这和锁机制很像，被上锁的对象为计时器。只有获得计时器的调用才会被真正执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId; <span class="hljs-comment">// 记录定时器的ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 如果已存在定时器，则先清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timerId) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    <span class="hljs-comment">// 创建新的定时器，延迟执行 func 函数</span><br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行 func 函数</span><br>      timerId = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空定时器ID</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123; <span class="hljs-comment">// 判断当前时间与上次执行的时间间隔是否超过指定的等待时间</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>      lastTime = now; <span class="hljs-comment">// 更新上次执行的时间戳</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖和节流都能限制函数被调用的频率，区别是什么时候能再次被调用，防抖是从多次小于设定间隔的连续调用的最后一次开始计算，而节流是从第一次调用开始计算，因此相同条件下，节流可以更快地进行第二次有效调用。</p><p>总的来说，函数防抖适合在需要等待一段时间后再执行函数的场景。如果目标函数不需要等待可以立即执行，则使用节流即可。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TamperMonKey</tag>
      
      <tag>MutationObserver</tag>
      
      <tag>函数防抖</tag>
      
      <tag>函数节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
