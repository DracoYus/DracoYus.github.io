<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Design-Pattern-Proxy</title>
    <link href="/2025/02/27/Design-Pattern-Proxy/"/>
    <url>/2025/02/27/Design-Pattern-Proxy/</url>
    
    <content type="html"><![CDATA[<p><strong>代理模式是一种结构型设计模式，通过引入代理对象来控制对原始对象的访问，常用于功能扩展、访问控制或性能优化。</strong></p><h2 id="场景">场景</h2><p>在编写代码时，经常会出现需要在方法开始或结尾，编写固定格式代码的情况。例如在接口层方法中，需要对入参和出参进行日志打印；又或者是在业务逻辑方法中，执行前需要开启事务，结束时需要提交/回滚事务。</p><p>我们当然可以在这些方法中显式编码日志输出，也能正确执行。但当日志输出需要调整时，需要对所有编码的位置改动。日志输出本身也不属于业务的一部分，写在一起会导致两个不相关功能耦合。</p><p>理想状态是，能把这些通用日志代码写在统一位置，然后在每个需要的地方，通过某种标记，使得程序能完成两部分代码功能的组合。这个场景和之前提到的<strong>装饰模式</strong>十分类似。在装饰模式中通过包装，允许在不修改现有对象结构的前提下向对象添加新的功能。<strong>而代理模式，也是在原始对象外部，通过包装来实现在调用原始对象的方法前，新增额外的逻辑</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxService</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> doService &#123;<br>    ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyXxxService</span> &#123;<br>    <span class="hljs-keyword">private</span> XxxService xxxService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> doService &#123;<br>    beforeFunction();<br>        xxxService.doService();<br>        afterFunction();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中通过包装，<code>ProxyXxxService</code>通过重写了<code>doService</code>同名方法，在<code>XxxService</code>的<code>doService</code>方法执行前后增加了额外逻辑。但还是存在问题，为了使代理生效，我们需要将所有用到被代理对象的地方，替换为代理对象。<code>java</code>是强类型语言，上例中代理对象和被代理对象属于不同类型，直接替换会因为类型不匹配无法编译。为了使代理对象能够赋值给原先被代理对象的变量，<strong>需要两者实现共同接口，并且定义变量类型为接口，或者代理类是被代理类的子类</strong>。<strong>客户端不知道也无需关心，其持有的对象是否被代理</strong>，好一招狸猫换太子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyXxxService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AInterface</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YyyService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyYyyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">YyyService</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">client</span> &#123;<br>    <span class="hljs-keyword">private</span> AInterface xxxService;<br>    <span class="hljs-keyword">private</span> YyyService yyyService;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理模式">代理模式</h2><p><strong>在<code>GoF</code>书中，代理模式专指通过接口实现的模式</strong>。根据书中定义，代理模式共有四个角色：</p><ul><li><strong>服务接口</strong> （Service Interface） 声明了服务接口。代理必须遵循该接口才能伪装成服务对象。</li><li><strong>服务</strong> （Service） 类提供了一些实用的业务逻辑。</li><li><strong>代理</strong> （Proxy）类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。</li><li><strong>客户端</strong> （Client）能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理。</li></ul><pre><code class=" mermaid">classDiagram    direction LR    class Client        class ServiceInterface &#123;        &lt;&lt; interface &gt;&gt;    +methodA() ResultA    &#125;Client --&gt; ServiceInterfaceclass Service &#123;+methodA() ResultA&#125;    Service ..|&gt; ServiceInterfaceclass Proxy &#123;- ServiceInterface serviceInterface+methodA() ResultA&#125;Proxy ..|&gt; ServiceInterfaceProxy o-- Service    </code></pre><h2 id="动态代理">动态代理</h2><p>但任有问题。如果需要将日志的功能，通过代理加入到多个类中，会额外产生和被代理类数量相等的代理类。这些代理类关于日志的代码仍然高度重合，代理模式没有降低代码的重复程度。为了解决这个问题，不同语言有不同做法。在<code>java</code>中，通常使用动态代理技术来完成前文提到的<strong>“两部分代码功能的组合”</strong>。动态代理模式下，代理对象是程序在运行时动态生成字节码，将日志功能增强方法和被代理对象，组合成的临时类对象。也就是说这动态代理中，这个代理类并没有在代码中显式编码，而只需要编写增强目标方法的核心方法（简称增强方法）。程序员可以独立地编写增强方法和被代理类，然后在任何需要被代理的对象上绑定增强方法，最后由动态代理完成两者的组合。</p><p><strong><code>java</code>常用的动态代理技术有两种，<code>JDK</code>和<code>CGLIB</code></strong>。对此两种具体实现和使用本文不过多介绍。值得一提的是，<code>JDK</code>要求被代理类实现了某个接口，<code>CGLIB</code>要求被代理类/方法不能是<code>final</code>，结合上文也是好理解的。只有被代理类实现了某个接口，客户端才可以无缝替换被代理对象。而通过继承实现的代理，要求父类不能是<code>final</code>，方法也不能是<code>final</code>，不然无法继承或重写父类定义的方法。</p><h2 id="spring-aop">Spring AOP</h2><p>现代基于<code>Java</code>开发，本质上已经是基于<code>Spring</code>开发。而<code>Spring AOP</code>又对动态代理进行了封装，使得程序员能够更轻松地使用代理模式。</p><p>在没有<code>Spring AOP</code>时，动态代理仍需要手动显示编写将代理方法和被代理对象绑定到一起。每次代理新类时，需重复编写类似的绑定代码。</p><p>而<code>Spring AOP</code>提供了更为简单的绑定方式。在<code>Spring AOP</code>术语中，结合上文不严谨地说，<strong>通知（<code>Advice</code>）就是增强方法，连接点（<code>Joint Point</code>）/切点（<code>Point Cut</code>）就是需要被代理的方法/类，把增强方法和被代理类组合到一起的过程称为织入（<code>Weaving</code>）</strong>。可以通过注解（如<code>@Aspect</code>）或配置<strong>声明式定义切面逻辑</strong>，Spring自动完成代理对象的创建和绑定，开发者无需手动组合增强方法与被代理对象。</p><p>所以在<code>Spring IoC</code>容器中，会同时存在<strong>原始对象</strong>和<strong>增强后的代理对象</strong>。依赖注入会替代原始对象，将代理对象注入到依赖的地方。<strong>所有依赖处的调用，实际是调用了代理对象增强后的方法</strong>。这也解释了为什么在被代理类中，如果通过<code>this.method()</code>的方式调用同类中被增强的方法会失效。因为此时的<code>this</code>指的是原始对象，而只有通过代理对象调用方法，才会执行增强逻辑。</p><h2 id="一些想法">一些想法</h2><p>在学习完代理模式的结构后，会发现代理模式是一种非常简单的设计模式。本质就是通过包装，在被代理方法执行前后/抛异常时增加一些额外逻辑。而每次阅读到其他代理模式的文章，都会使用“控制对原始对象的访问”这类难理解的定义。在笔者理解中这是容易产生歧义的地方。控制访问容易被理解为，客户端要调用某些方法，需要进行权限校验。这类鉴权的逻辑和后续执行的业务逻辑通常是独立的，十分适合通过代理模式进行解耦。但从上下文推断，笔者认为可能更想表达，客户端无法直接接触原方法，欲访问原方法，必先通过代理方法，这一层控制的含义。</p><p>提到代理就涉及三方角色，原业务的双方和代理人。在现实中我们讨论代理，是指代理人可以以被代理人名义，在授权范围内与第三方实施民事法律行为，法律后果由被代理人承担，被代理人通常是业务发起方。而在上文中，被代理的角色是服务，是被调用方，是业务应答方。沿用计算机网络中的概念，现实中讨论的代理更多是正向代理，而代理模式则是反向代理。这导致代理模式某些地方可能和直观不符。</p><p>## 和其他包装的区别</p><p>在前些节提到，<strong>适配器模式</strong>、<strong>代理模式</strong>、<strong>桥接模式</strong>、<strong>装饰模式</strong>均属于<strong>包装</strong>。</p><p>适配器模式会改变包装前后实现的接口，桥接模式中抽象和实现没有实现相同接口，不可互相替代，因此容易区分。</p><p>而装饰模式中，具体部件和具体装饰都实现了部件接口，装饰的嵌套也动态增强了部件的功能。对比代理模式中，代理类实现了被代理类的接口，也通过增强方法动态增强了被代理对象的功能。代理本身也可以嵌套，即代理对象被再次代理，形成“代理链”。<strong>从结构和形式来看，代理模式和装饰模式几乎没有区别</strong>。</p><p>翻阅了一些网上文章，给出的区别并不能很好地说服笔者。例如，有些人认为代理模式对于被包装的对象，有时负责其创建，而装饰模式的被包装对象，则更多是外部传入。但代理模式也不是必须管理被代理对象的生命周期，这显然不是区别两个模式的核心特征。也有人认为，两种模式的主要区别是目的动机不同，认为代理模式强调<strong>控制访问</strong>，装饰模式强调<strong>动态增强功能</strong>。笔者仍然不认可，螺丝刀可以用来拧螺丝，也可以拿来开快递。我们不能说用来开快递的时候，它就不是螺丝刀。也有说装饰模式是运行时行为，代理模式是编译时就能确定的。但如果代理模式是通过运行时读取配置，在决定是否生成代理对象，如此也成为了运行时行为。</p><p>笔者认为两者的主要区别，是代理模式的增强方法，和原方法的业务关联性不高。而装饰模式的装饰方法，则和被装饰的类高度相关。正是因为代理模式的增强方法更通用，代理模式才可以发展成只要编写增强方法，然后绑定到各种需要的地方。而装饰模式设计初衷是针对某一具体功能，没有通用性。</p><h2 id="总结">总结</h2><p>代理模式通过实现和被代理对象相同接口，或继承自被代理类，使得可以在客户端中替换被代理对象。具体是通过包装，并重写被代理对象的同名方法，在委派调用被代理对象方法前后增加额外逻辑来实现。</p><p><code>GoF</code>书中的代理模式特指通过实现共同接口的模式。此代理模式包含四个角色：服务接口、服务、代理、客户端。</p><p>为了解决代理模式中代理和服务一一对应的关系导致的代码重复，<code>java</code>使用动态代理技术，进一步降低增强方法和被代理方法之间的耦合。</p><p><code>Spring AOP</code>在动态代理基础上又进行了封装，使得程序员可以声明式定义切面逻辑，无需重复编写绑定代码。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Flyweight</title>
    <link href="/2025/02/20/Design-Pattern-Flyweight/"/>
    <url>/2025/02/20/Design-Pattern-Flyweight/</url>
    
    <content type="html"><![CDATA[<p><strong>享元模式（<code>Flyweight</code>）</strong>是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，旨在通过共享对象来减少内存使用和提高性能。</p><h2 id="场景">场景</h2><p>在一些2D平面游戏中，玩家可以控制一个角色，在地图中移动，和不同单位交互。对于这类游戏，内存中存在一个数组，表示游戏的地图数据，包含例如某个地格的地形、位置、障碍物、是否有道具/角色可交互对象等数据。游戏的图像引擎，通过遍历每个地格的数据，渲染成游戏界面。玩家看到的游戏画面，实际由多个图像组合而成，每个图像都对应某个具体的贴图文件。贴图文件会在游戏启动时被加载进内存，存放在地格中。在地图上，很多地格都是同一个地形，因此这些地格会拥有相同的贴图数据。如果在每个地格的中都储存贴图数据，会导致重复的数据在内存中存放了多份，造成内存浪费。这些地格在初始化时，每个地格都需要创建新的贴图数据对象，导致游戏加载缓慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 地格类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tile</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-keyword">private</span> String terrain;<br>    <span class="hljs-keyword">private</span> String resource;<br>    <span class="hljs-comment">// 贴图数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] texture;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span> &#123;<br>    <span class="hljs-comment">// 通常使用一个List管理所有地格对象</span><br>    <span class="hljs-keyword">private</span> List&lt;tile&gt; tiles;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="享元模式">享元模式</h2><p>笔者认为享元模式的解决方案是显而易见，顺其自然的。如果同样的贴图在地图上会出现多次，每个地格完全没必要独立存储一份贴图数据，<strong>大家共用同一份就行了</strong>。这在代码中也是容易处理的：每个地格储存了贴图对象的引用，这些引用最后都指向同一个贴图对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 地格类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tile</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br>    <span class="hljs-keyword">private</span> String terrain;<br>    <span class="hljs-keyword">private</span> String resource;<br>    <span class="hljs-comment">// 贴图享元对象</span><br>    <span class="hljs-keyword">private</span> Texture texture;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Texture</span> &#123;<br>    <span class="hljs-comment">// 贴图路径/名称，用于区分不同的贴图对象</span><br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-comment">// 具体的贴图数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] texture;<br>&#125;<br></code></pre></td></tr></table></figure><p>再抽象一层，什么样的场景适合享元模式？享元模式核心是共享对象，那这些对象本身需要在很多地方被使用，在代码中通常体现存在一个数组持有许多对象。这些对象有一部分属性是相同的，有一部分属性是不同的。用<code>Gof</code>书中的概念，这些相同，重复的属性，称为<strong>内部状态</strong>，其他的属性被称为<strong>外部状态</strong>。</p><p>在上例中，不同地格的位置、地形、资源不同，因此属于外部状态。而贴图会复用同一段贴图数据，因此属于内部状态。把一个类改造成享元模式也十分直观：把需要被共享属性抽取到享元类中，然后在类中引用这个享元类。上例中，<code>Texture</code>类就是享元类，<code>Tile</code>类中通过成员变量引用了享元类。</p><p>回到<code>Gof</code>书中的定义。包含原始对象中部分能在多个对象中共享的状态的类称为<strong>享元<code>Flyweight</code></strong>。包含了外部状态，并通过引用享元类，组合成了原始对象全部状态的类称为<strong>情景<code>Context</code></strong>。依赖<code>Context</code>的类被称为<strong>客户端<code>Client</code></strong>。</p><pre><code class=" mermaid">classDiagram    direction LR    class Client &#123;    - List~Context~    &#125;        class Context &#123;        - UniqueState    - Flyweight    &#125;Client *-- Contextclass Flyweight &#123;- RepeatingState&#125;    Context --&gt; Flyweight        class FlyweightFactory &#123;    - Map~Flyweight~ cache    + getFlyweight(RepeatingState) Flyweight    &#125;        Context --&gt; FlyweightFactory    FlyweightFactory o-- Flyweight</code></pre><h2 id="享元工厂">享元工厂</h2><p>在上图中，额外新增了一个角色<strong>享元工厂<code>FlyweightFactory</code></strong>。前文提到，享元是被共享的对象，但还没有说清楚，这个对象由谁创建，以及如何保证不同<code>Context</code>可以共享同一个享元对象。</p><p>那就需要一个方法，可以通过内部状态获取到对应的享元对象。这个方法可以定义在享元类中，但更多是定义在专门的享元工厂中。新建一个工厂类，专门负责所有享元对象的创建和管理的想法是自然的。如果对应的享元对象之前已经创建过，那么工厂方法应该返回之前已有的对象，而不是新建一个。这也被称为缓存机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;RepeatingState, Flyweight&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweright</span><span class="hljs-params">(RepeatingState repeatingState)</span>  &#123;<br>        <span class="hljs-keyword">if</span> (!flyweights.containsKey(repeatingState)) &#123;<br>            flyweights.put(repeatingState, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Flyweight</span>(repeatingState));<br>        &#125;<br>        <span class="hljs-keyword">return</span> flyweights.get(repeatingState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个享元对象会被多个<code>Context</code>同时引用，可能会引发线程不安全。因此通常将享元类设计为不可变类，具体的采取措施是将所有字段设置为<code>private final</code>，不提供<code>setter</code>方法，并且要求在构造函数能够初始化所有字段。</p><h2 id="内部状态和外部状态">内部状态和外部状态</h2><p>关于内部状态和外部状态的定义，笔者是十分疑惑的。这里说的内部和外部，是相对什么的内外？一种解释是，内指对象本身，而外指对象所处的环境。具体来说，<strong>内</strong>指的是<strong>对象本身固有的属性</strong>，即对象内部存储的、不依赖于外部环境的状态。<strong>外</strong>指的是<strong>对象所处的环境或上下文</strong>，即依赖于外部环境的状态。这些状态不是对象本身的一部分，而是由对象的使用者（客户端）维护，并在需要时传递给对象。</p><p>按照此定义，上例中游戏地格的各种属性，属于内部还是外部状态是模棱两可的。例如每个地格的位置，在创建时就固定了，通常不会被客户端修改，按理说属于内部状态。但每个地格的位置都不同，因此位置数据无法在多个地格之间共享。也有很多文章拿文本编辑器作为例子，提到每个字符具有字体、颜色、大小等属性。有些案例会把字符内容作为内部状态，理由是字符种类数量是固定的，例如26个小写英文字母。也有案例将颜色、字体作为内部状态，理由是同一个文档中通常不会包含太多颜色、字体。</p><p>抛开这些概念不谈，笔者认为，享元模式归根结底是为了通过共享对象来节省内存，与其纠结内外状态的概念，不如采用更简单粗暴的定义方法。如果一个属性，包含的属性值在多个对象中重复，并且这个属性本身的存储成本相对于其他属性较高，那这就是一个内部状态。从量化的角度来讲，可以使用信息熵来衡量某个字段的重复程度。这种思路和在数据库中，查找区分率高的字段作为索引的想法是一致的。只不过享元模式是找重复的属性，而索引是要寻找不重复的属性。而储存成本，则与对象数量、属性长度、重复率有关。上面的地格例子中，贴图数据是<code>byte[]</code>类型，这远大于引用(指针)的长度。总体来说，对象越多，属性越长，重复率越高，则越应该设计为内部状态。</p><p>就算不理解内部状态和外部状态，也能很好的应用享元模式。</p><h2 id="总结">总结</h2><p>享元模式通过在不同对象间，共享一部分重复率高的数据，达到节省内存和提高性能的目的。</p><p>享元模式将占用大，重复率高的属性抽取到享元类中，并在情景类中引用享元类，来共享享元对象。</p><p>通常会使用享元工厂类来提供工厂方法，通过该方法获取与内部状态对应的享元对象。同时利用缓存机制，确保对于相同的内部状态，直接返回已创建的享元对象，避免重复创建。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Facade</title>
    <link href="/2025/01/15/Design-Pattern-Facade/"/>
    <url>/2025/01/15/Design-Pattern-Facade/</url>
    
    <content type="html"><![CDATA[<p><strong>外观/门面模式(Facade)</strong>是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p><h2 id="场景">场景</h2><p>为了通用性，第三方库/子系统会把功能设计得完备，但客户端通常只使用其中非常少的功能。客户端直接使用第三方库类，会引入过多不必要的功能与方法细节，也会导致客户端会与第三方类的实现细节紧密耦合。当想尝试替换其他功能相似的第三方库时，客户端需要调整所有调用第三方库方法的位置。如果客户端需要同时与多个第三方库交互，类的创建，库之间的依赖，交互流程的顺序，对于客户端来说都是过于复杂的。</p><h2 id="门面模式">门面模式</h2><p><strong>简单来说，门面模式就是为了让客户端更方便地使用子系统。</strong></p><p>门面模式为子系统中的一组接口提供一个统一的高层接口。它就像是一个门面，将子系统的复杂性封装起来，让外部调用者只需要与这个门面进行交互，而不需要了解子系统内部的具体实现细节。就像通过电话给商店下达订单时，接线员就是该商店的所有服务和部门的门面。接线员为你提供了一个同购物系统、支付网关和各种送货服务进行互动的简单语音接口。</p><p><strong>门面模式的结构比较简单，包含两个角色，门面和子系统</strong>。其中子系统通常是第三方库，而门面则负责封装所需功能并隐藏其他代码，从而无需使全部代码直接与数十个第三方类进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    +<br>    <span class="hljs-keyword">private</span> Subsystem1 subsystem1;<br>    <span class="hljs-keyword">private</span> Subsystem2 subsystem2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Facade</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 通常负责子系统对象的创建与初始化</span><br>        subsystem1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subsystem1</span>();<br>        subsystem2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subsystem2</span>();<br>        ....<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 客户端直接需要的功能，通常包含对子系统的一系列调用</span><br>        subsystem1.function();<br>        subsystem2.function();<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="门面模式变体">门面模式变体</h2><p>上例中，将门面设计成了类。如果要替换第三方库实现时，则需要修改门面类，一定程度上不符合开闭原则。</p><p>如果对门面再抽象一层，可以将门面设计成接口。在门面接口中定义客户端需要的方法，客户端也只与门面交互。如此一来，替换第三方库实现，可以通过新增门面接口的实现类来完成。</p><p>大名鼎鼎的<code>SLF4J（Simple Logging Facade forJava）</code>就是门面模式的典型实现，其中的<code>F</code>指的就是<code>Facade</code>门面。<code>java</code>中，可以完成日志功能的第三方库有许多，例如<code>log4j</code>、<code>logback</code>、<code>java.util.logging</code>，不同的日志实现提供的接口也不同。当需要将项目中的日志实现从一个替换成另一个，或者日志实现发生了代码变动，所有引用的地方都需要进行改动。而<code>SLF4J</code>则为这些不同的日志实现，统一规定了交互接口。客户端仅通过<code>SLF4J</code>的接口，与各种不同的日志实现交互。当需要替换日志实现时，只需要替换<code>SLF4J</code>门面的具体实现，这通常也被包含在第三方库中，因此客户端代码无需进行任何调整。</p><p>此外，如果门面接口包含的功能太多，不符合单一职责原则，可以通过将接口拆分成多个接口，并通过继承来组织接口之间的关系。</p><h2 id="总结">总结</h2><p>门面模式的动机就是让客户端更简单地使用第三方库。类似把课本中关注的重点抄到笔记本上，后续不翻书本，只翻笔记了。</p><p>门面模式可以降低客户端与第三方库之间的耦合。使得替换第三方库时，可以最小程度改动客户端代码。</p><p>简单的门面可以设计成类，并在其中实现对子系统的创建与交互。复杂的门面可以设计成接口，并通过不同实现类，完成对不同子系统的交互，以符合开闭原则。<code>SLF4J</code>就是典型例子。</p><p>门面被设计成接口时，可以通过接口拆分和继承，来组织接口的关系。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Architecture-Microservices</title>
    <link href="/2024/11/11/Architecture-Microservices/"/>
    <url>/2024/11/11/Architecture-Microservices/</url>
    
    <content type="html"><![CDATA[<p>由于工作的主要内容还是CRUD，对于软件架构设计鲜有接触，对相关概念的理解是欠缺的。这些欠缺在最近一次面试中暴露出来。虽然内心也在为面试造火箭，实际拧螺丝愤愤不平。很多架构的设计，对开发人员编码的影响是透明或极小的，因为这部分内容通常被框架完成或者进行了很好的封装，以让开发人员可以将注意力集中到业务逻辑上。但冷静后还是觉得，有必要去学习和实践，就算这些新玩意不一定用得到。这是一个拥抱进步的程序员该有的态度，也能帮助自己站在更高一层维度审视程序软件设计。</p><p>所以准备在闲暇时间学一学现代高并发、高性能、高可用程序开发。这些特征通常和一些关键词和技术绑定，例如微服务、分布式、<code>SOA</code>、<code>DDD</code>、<code>SpringCloud</code>等。对于这一堆概念，网上有各种介绍资料，质量也层次不齐。在似懂非懂看了一些后，总感觉大部分资料都在互相抄袭，引入一些列新的概念但又没有讲清楚。</p><p>因此转为阅读国外资料。虽然语言会影响阅读速度，但很多国外材料会回答得“更像人话”，反而更容易理解。因此开展一个系列，对国外一些好的文章进行解读或思考，作为阅读笔记。通常我会将文章先读1~2遍，然后再逐字写阅读笔记。阅读笔记的形式，更多是对原文内容的翻译和解读，不会像设计模式系列那样进行扩展和引起思考。</p><p>本次阅读的文章，是来自<a href="https://martinfowler.com/">MartinFowler</a>关于微服务（本文不加区分使用微服务、微服务架构、微服务应用）的文章<ahref="https://martinfowler.com/articles/microservices.html">Microservices</a>。接下来文本安排参照原文结构，对每一部分的关键内容总结并做一些解读。建议对照原文阅读本篇内容。</p><h2 id="引言">引言</h2><p>作者在介绍微服务前，先叠了一层甲，提到微服务架构（<code>Microservice Architecture</code>）这个概念新起没多久。也没有十分明确的定义描述微服务，或指导如何实现。但作者仍尝试从各个方面，总结这些微服务应用的共同特点。总的来说，在</p><blockquote><p>organization around business capability, automated deployment,intelligence in the endpoints, and decentralized control of languagesand data.</p></blockquote><p><strong>围绕业务能力、自动部署、智能端点、语言和数据的分散控制这些方面有着共同特征</strong>。文章接下来的章节便是对这几方面做详细说明。</p><p>这篇文章发布于2014年3月25日。软件开发理论，更多是对于开发经验或规律的总结。这导致这个领域的理论发展，可能是先出现了某类事物，才会产生对这类事物的归纳总结。放眼现在，微服务概念在十年内变得更清晰，也有了一些最佳实践（<code>best practice</code>）指导。</p><p><strong>简而言之，微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个服务都在自己的进程中运行，并使用轻量级机制（如<code>HTTP</code>）进行通信。这些服务围绕业务功能构建，可通过完全自动化的部署机制独立部署</strong>。这些服务的集中管理最低限度，可以用不同的编程语言编写，并使用不同的数据存储技术。</p><p>在介绍微服务之前，先介绍在微服务诞生之前的应用，主要采取的是<strong>单体风格（monolithicstyle）</strong>。在单体风格中，所有的功能都是一个整体，会被打包成<strong>一个</strong>应用程序。当单体中的任意一个部分发生改动时，都需要对整个应用重新构建部署。当需要对应用进行扩展时，需要对整个应用进行横向扩展。这些特点在现在越来越流行的云服务开发中，逐渐显现出不利。</p><h2 id="微服务架构的特点">微服务架构的特点</h2><p>由于没有相对正式的定义，微服务架构的讨论更多为对其特点进行总结。</p><p>总的来说，微服务架构是将软件系统<strong>组件化(<code>Componentization</code>)</strong>。</p><p><ahref="https://martinfowler.com/bliki/SoftwareComponent.html">组件(<code>component</code>)</a>也是个难以定义的概念。<code>Martin Fowler</code>把组件定义为可独立更换和升级的软件单元。</p><blockquote><p><strong>component</strong> is a unit of software that isindependently replaceable and upgradeable.</p></blockquote><p>在<code>java</code>中，不同组件可以被打成不同的<code>jar</code>包。组件之间的通讯可以有多种方式，例如可以通过在内存中调用。<strong>采用这种通讯方式交互的组件也被称为库<code>(libraries)</code></strong>。<strong>而微服务的主要特点就是将组件从库，转变为服务<code>(service)</code></strong>。服务是通过如<code>HTTP</code>请求、<code>RPC</code>等方式进行通讯的组件。</p><p>服务的一个优点是可以独立部署。通常来说，如果一个应用是由一个主进程和多个库构成。当任意一部分发生变动时，需要将整个应用重新部署。而服务大部分情况下可以只部署发生变化的那些服务。只有当服务间的接口发生变动时，才需要重新部署涉及的多个服务。</p><p>使用服务的另一个优点是强制显示定义接口。通过接口定义可以更好地划分职责。服务间的调用只需遵循接口定义，而不需要了解其具体细节，促进了代码的解耦。</p><p>使用服务也有缺点，服务间的远程调用通常比内存中的调用更昂贵。因此在接口设计时，为了减少调用次数，会尽可能将接口设计得更通用。这也导致客户端使用接口会更复杂，可能需要额外的逻辑来解析或处理不必要的数据。</p><p>这一章最后，作者表述了服务和进程不一定是一一对应关系。例如服务可以包含一个应用进程，和一个仅被该服务使用的数据库进程。如果两者总是同时开发和部署，则可以被视为一个服务。</p><h2 id="围绕业务能力组织">围绕业务能力组织</h2><p>上一章提到，微服务架构的特点，是将一个大型软件系统，拆分成多个服务。那必然涉及到拆分的原则。</p><p>一种传统的拆分方式是根据技术层进行划分。例如 UI团队、服务器端逻辑团队和数据库团队。这种划分方式会导致一些简单的改动，也会演变成跨团队的项目。每次更改都需要协调多个团队，增加沟通成本和项目复杂性。一个偷懒的解决方法，是将业务逻辑写在自己团队负责的代码中。例如UI团队直接在前端实现了一部分业务逻辑。这种方式虽然减少了短期内的沟通成本，但从全局来看会导致逻辑分散，系统变得难以维护。发生问题时，需要排查的范围变得更大。这就是康威定律（<ahref="https://martinfowler.com/bliki/ConwaysLaw.html">Conway's Law</a>）的一个实际例子。系统的设计结构会反映其组织的沟通结构。</p><blockquote><p>Any organization that designs a system (defined broadly) will producea design whose structure is a copy of the organization's communicationstructure.</p></blockquote><p><strong>微服务提倡的拆分原则，是按照业务能力进行划分</strong>。一个团队涵盖软件的全栈实现，包括用户界面、持久存储和外部协作。团队是跨职能的，具备用户体验、数据库和项目管理等全方位技能。</p><h2 id="围绕产品而不是项目">围绕产品而不是项目</h2><p><strong>微服务强调从传统项目思维向产品思维转变</strong>。</p><p>传统的项目往往有明确的开始和结束时间，以完成特定的任务或达到特定的目标为导向，比如开发一个特定版本的软件系统并交付。当软件开发完成后，项目团队可能会解散，并将其维护工作移交给维护团队。</p><p>微服务则强调产品思维。产品思维注重的是为用户提供长期的价值和持续的服务。开发团队需要维护产品的整个生命周期。</p><p>单体应用当然也能采取这种产品思维，但微服务的<strong>小型自治团队</strong>，<strong>清晰的职责划分</strong>，更便于开发人员关注其产品。</p><h2 id="智能端点-傻瓜管道">智能端点 傻瓜管道</h2><p>在跨进程间通讯时，请求从发起方到处理方，可能会经过其他系统的处理。例如发起方通过<code>Enterprise Service Bus (ESB)</code>调用服务时，<code>ESB</code>可以根据请求内容，对内容进行路由、转换，以及执行一些简单的业务规则。其中服务调用方和处理方称为端点，<code>ESB</code>在过程中是管道的角色。</p><p>微服务提倡<strong>智能端点，傻瓜管道</strong>。智能端点意味着端点有自己独立的业务逻辑和功能，能提供完整的服务。端点可以对数据进行处理和转换，使其符合自身业务需求以及与其他微服务交互的要求，而不需要在管道中进行。傻瓜管道则表示管道只负责在微服务之间传输数据，不具备任何业务逻辑处理能力。</p><p>基于这个原则，微服务通常采取简单的通讯协议。最常见的是使用<code>HTTP</code>请求和轻量级的<code>MQ</code>。</p><p>由于单体应用不同组件间，在内存中通过方法/函数互相调用，在将单体应用转为微服务时，需要更改通讯模式。直接将组件间的接口改为<code>HTTP</code>请求接口，会导致性能不佳。因此在调整接口时，还需要将接口调整为更粗粒度，泛用性更强的方法。通过减少调用次数以降低调用开销。</p><h2 id="去中心化治理">去中心化治理</h2><p>围绕项目的单体应用倾向于集中化治理。在集中化治理模式下，应用通常会局限于某一技术平台/编程语言。但并非所有情况都能靠一种技术平台解决。<strong>微服务提倡去中心化治理，对于每一个场景都使用最合适的技术平台</strong>。当应用被拆分成多个服务，服务之间仅通过简单接口进行交互，每个服务可以自己决定其技术方案，只需保证可以实现相同的接口协议。虽然单体应用一定程度也可以使用不同语言，但这并不常见。</p><p>但去中心化治理不意味着所有类似的问题，都需要在每个微服务中重新解决一遍。对于制定标准，相对于使用文档这种<strong>传统书面</strong>方式去约束，微服务提倡开发<strong>实用工具</strong>，去解决相似问题，并通过<strong>开源</strong>在不同微服务之间共享这些工具。这段内容似乎和本章主题有些矛盾。去中心化治理，但又使用相同的工具。其实不然。去中心化强调的是，<strong>每个服务有自主选择方案的权力，不代表必须使用不同的方案</strong>。</p><p><strong>服务契约（<code>Service Contract</code>）</strong>是定义服务提供者与服务消费者之间交互规则的一种约定，它包含了一系列规范，确保双方能够正确、高效地进行通信与协作。通常来说，服务契约包括接口定义、数据格式、协议规范、服务质量等。由于微服务中存在更多服务契约，因此会对其更加重视。微服务中常见的服务契约模式包括<strong>“宽容读取者”</strong>、<strong>“消费者驱动契约”</strong>等。消费者驱动契约指，由服务消费者根据自身的实际需求来定义期望从服务提供者那里获得的接口和数据格式等内容，即契约是由消费者“驱动”产生的。这与传统的服务提供者定义契约是相反的。这样的契约模式，减少服务之间的时间耦合，降低了对中央契约管理的需求。</p><h2 id="去中心化数据管理">去中心化数据管理</h2><p>数据管理去中心化有多种形式。<strong>在最抽象层面，不同系统之间的数据概念模型是不同的</strong>。在对实体进行建模时，不同的系统会侧重不同的方面。例如销售部门对客户的看法与客服部门对客户的看法会有所不同。在销售视角中被称为“客户”的某些对象，在客服视角中可能根本不会出现。即便那些在两个视角中都存在的对象，也可能具有不同的属性。</p><p>微服务提倡采取使用<strong>领域驱动设计（<code>Domain - Driven Design，DDD</code>）</strong>中<strong>限界上下文（<code>Bounded Context</code>）</strong>的概念。在复杂的业务系统中，一个领域可能包含多个不同的子领域，每个子领域都有其独特的业务规则、术语和工作方式。限界上下文就是将这些不同的子领域隔离开来，形成一个个相对独立的“上下文”，每个上下文有自己明确的边界，避免不同子领域之间的概念和规则相互混淆。<code>DDD</code>将一个复杂的领域划分为多个限界上下文，并梳理出它们之间的关系。这个过程对于单体架构和微服务架构都很有用，不过在服务边界和上下文边界之间存在一种天然的关联，这有助于明确边界划分。</p><p><strong>微服务还提倡数据存储去中心化</strong>。单体应用通常倾向于使用单个逻辑数据库来存储持久化数据。也就是说，整个单体应用的所有数据，不管是用户信息、订单信息还是商品信息等，都存储在同一个数据库中。在企业级应用场景中，甚至多个不同的单体应用也常常共用一个数据库。而微服务架构更倾向于让每个服务管理自己的数据库。每个微服务可以根据自身的业务需求和数据特点，选择合适的数据库技术。这些数据库可以是同一数据库技术的不同实例，也可以是完全不同的数据库系统，这种方法被称为多语言持久化。例如同时使用关系型数据库<code>(MySQL、Oracle)</code>和非关系型数据库<code>(MongoDB、Redis)</code>。</p><p>但是数据存储去中心化也会引入新的问题。对于数据的更新操作，以往处理更新操作的常用方法是在更新多个资源时使用事务来确保数据的一致性，这种方法在单体应用中经常被采用。但在微服务中使用事务时，会造成严重的时间耦合问题。分布式事务的实现难度是出了名的大。因此，<strong>微服务架构强调服务之间进行无事务协调，同时明确认识到一致性可能只能是最终一致性，并且通过补偿操作来处理出现的问题</strong>。</p><h2 id="基础设施自动化">基础设施自动化</h2><p>微服务提倡采取基础设施自动化技术。在这里，基础设施自动化技术是指<strong>持续交付（<code>Continuous Delivery，CD</code>）及持续集成（<code>Continuous Integration，CI</code>）</strong>。持续集成是指开发团队成员频繁地将代码集成到共享代码库中，并通过自动化构建和测试来验证代码的正确性；持续交付则是在持续集成的基础上，进一步实现软件的自动化部署，确保软件能够随时部署到生产环境。容器技术的良好发展也很好地支持了这项技术。</p><h2 id="服务故障容忍设计">服务故障容忍设计</h2><p><strong>将服务用作组件会带来一个结果，应用程序需要被设计成能够容忍服务故障</strong>。由于服务提供者可能不可用，任何服务调用都有可能失败，客户端必须尽可能优雅地应对这种情况。与单体架构设计相比，处理服务故障会引入额外的复杂性。</p><p><strong>由于服务随时都可能出现故障，因此能够快速检测到故障，并在可能的情况下自动恢复服务就显得至关重要</strong>。微服务应用十分注重对应用程序进行实时监控，既会检查架构层面的指标（例如数据库每秒接收多少个请求），也会关注与业务相关的指标（比如每分钟接收多少个订单）。语义监控能够在出现问题时提供早期预警，促使开发团队跟进并展开调查。</p><h2 id="进化设计">进化设计</h2><p>不重要，略。</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architecture</tag>
      
      <tag>Microservices</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Decorator</title>
    <link href="/2024/10/28/Design-Pattern-Decorator/"/>
    <url>/2024/10/28/Design-Pattern-Decorator/</url>
    
    <content type="html"><![CDATA[<p><strong>装饰模式（DecoratorPattern）</strong>是一种结构型设计模式，允许在不修改现有对象结构的前提下向对象添加新的功能。</p><h2 id="场景">场景</h2><p>假设我们正在开发一款爬虫软件，并准备将爬取到的数据写入<code>csv</code>文件中。按照模块化编程的思想，会把<code>csv</code>相关的代码保存到一个独立的类<code>CsvWriter</code>中。而后可能又需要把同样的数据写入<code>txt</code>、<code>json</code>、数据库中，也会诞生相应的<code>TxtWriter</code>、<code>JsonWriter</code>、<code>SqlWriter</code>。基于每个<code>XxWriter</code>做的事情相似，可以把通用行为抽取成接口<code>DataWriter</code>中的方法。例如文件初始化，或者接收数据并写入文件的方法。客户端通过接口与不同实现类交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataWriter</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;Data&gt; dataList)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TxtWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;...&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Crawler</span> &#123;<br>    <span class="hljs-keyword">private</span> DataWriter dataWriter;<br>    ...<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        dataWriter.initialization();<br>        ...<br>        dataWriter.write(dataList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但我们并不会局限于某一特定格式，而是根据场景组合多个格式，例如把数据同时写入<code>csv</code>和<code>txt</code>中。如果不改变客户端代码，那么需要提供一个可以同时写入两种格式的<code>CsvTxtWriter</code>。而这个类的实现代码，与<code>CsvWriter</code>和<code>TxtWriter</code>的代码高度重合，通常是依次调用<code>CsvWriter</code>和<code>TxtWriter</code>中的代码。因此相对于重写一个<code>CsvTxtWriter</code>，更多会选择扩展已有代码。</p><p>扩展已有代码有两种方式，继承或组合。由于<code>java</code>不支持多继承，只能选择继承其中一个类，然后把另一各类的代码重新写一遍。这怎么看都不优雅。使用组合则是在类中引入两个类的成员变量，在实现接口的方法时，把方法调用委派给对两个成员变量的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvTxtWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CsvWriter</span> &#123;<br>    <span class="hljs-comment">// 继承的方式扩展CsvWriter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.initialization();<br>        ...<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;Data&gt; dataList)</span> &#123;<br>    <span class="hljs-built_in">super</span>.write(dataList);<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvTxtWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;<br>    <span class="hljs-comment">// 组合的方式扩展CsvWriter、TxtWriter</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">CsvWriter</span> <span class="hljs-variable">csvWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CsvWriter</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">TxtWriter</span> <span class="hljs-variable">txtWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TxtWriter</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span> &#123;<br>        csvWriter.initialization();<br>        txtWriter.initialization();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;Data&gt; dataList)</span> &#123;<br>csvWriter.write(dataList);<br>txtWriter.write(dataList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这样做的问题也很明显，如果有 <span class="math inline">\(n\)</span>个独立的<code>XxWriter</code>，一共会有 <span class="math inline">\(2^n- 1\)</span>种可能的组合。也就是需要定义的类数量很快会发生指数爆炸。所有组合中，只有<span class="math inline">\(n\)</span>个基础的<code>XxWriter</code>执行了实际代码，其他类只是委派调用这些基础类的方法。</p><p>从需求出发，我们希望编程语言提供这样的机制，能在运行时根据场景（例如通过读取配置文件，或者解析命令行参数），组合不同功能，动态生成所需的多功能类。这样就可以避免定义所有的可能组合，只需定义最基础的<span class="math inline">\(n\)</span>个类即可。这就是装饰模式将完成的功能。</p><h2 id="装饰模式">装饰模式</h2><p>在上文中，通过组合的方式扩展<code>CsvWriter</code>、<code>TxtWriter</code>，在<code>CsvTxtWriter</code>定义了两个被封装的具体类成员变量，<strong>封装/包装/组合/装饰（本文不加区分使用这些相似概念）的对象和被封装的对象是一对多的关系</strong>。装饰模式也是通过组合定义装饰类，但区别是只定义了<strong>一个</strong>抽象接口的成员变量。由于装饰类本身也实现了接口，因此实例可以再次作为其他装饰类的被封装对象，<strong>封装的对象和被封装的对象是一对一的关系</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;<br><span class="hljs-keyword">private</span> DataWriter wrappee;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CsvDecorator</span><span class="hljs-params">(DataWriter wrappee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wrappee = wrappee;<br>    &#125;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用被装饰类</span><br>    wrappee.initialization();<br>        <span class="hljs-comment">// 装饰类额外新增的功能，如写入csv格式文件</span><br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体上，<strong>装饰模式的多个装饰类封装后像是一个链表或者一叉树</strong>。调用装饰后对象的方法，则是通过持有链，进行先序遍历或后续遍历。换句话说就是先调用自身方法逻辑，还是先委派调用被装饰类的方法。</p><p>对于上例，基于装饰模式，则可以将 <spanclass="math inline">\(n\)</span> 个基础类，重构成 <spanclass="math inline">\(n\)</span> 个装饰类。这 <spanclass="math inline">\(n\)</span>个装饰类，代码仍有重复的部分，可以将这部分重复代码再进行一次抽象。将持有的被装饰类成员变量，以及委派调用被装饰对象方法的代码，都封装到抽取抽象基类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDataWriterDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;<br><span class="hljs-keyword">private</span> DataWriter wrappee;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseDataWriterDecorator</span><span class="hljs-params">(DataWriter wrappee)</span>&#123;<br>        <span class="hljs-built_in">this</span>.wrappee = wrappee;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span> &#123;<br>    wrappee.initialization();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;Data&gt; dataList)</span> &#123;<br>    wrappee.write(dataList);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDataWriterDecorator</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CsvDecorator</span><span class="hljs-params">(DataWriter wrappee)</span>&#123;<br>        <span class="hljs-built_in">super</span>(wrappee);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 装饰类额外新增的功能，如写入csv格式文件，根据需求也可以在被包装类方法执行前执行</span><br>        ...<br>    <span class="hljs-built_in">super</span>.initialization();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;Data&gt; dataList)</span> &#123;<br>    <span class="hljs-built_in">super</span>.write(dataList);<br>        <span class="hljs-comment">// 也可以在被包装类方法执行后执行</span><br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个装饰类来说，都需要在构造函数中传入一个被装饰类的对象。如果没有传入，则会导致在调用被装饰类的方法时，抛出<code>NPE</code>。这不是我们想要的。所以额外需要一种不持有被封装对象，不会进行委派调用，同样实现了接口的类。这个类可以被视作用来表示装饰链的终止，树的叶子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDataWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataWriter</span> &#123;<br>    <span class="hljs-comment">// 简单定义两个空方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialization</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;String&gt; dataList)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DataWriter</span> <span class="hljs-variable">dataWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseDataWriter</span>();<br>        <span class="hljs-comment">// 动态向对象添加新的功能</span><br>        <span class="hljs-keyword">if</span> (config.isWriteCsv) dataWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CsvDecorator</span>(dataWriter);<br>        <span class="hljs-keyword">if</span> (config.isWriteTxt) dataWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TxtDecorator</span>(dataWriter);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，已经把装饰模式所有结构都提及了。如果使用<code>GoF</code>书中的命名：</p><ul><li><p>接口<code>DataWriter</code>被称为<strong>部件</strong>（Component），用以声明装饰器和被装饰对象的公用接口。</p></li><li><p>不封装其他接口对象，在装饰链处于末端的，部件实现类<code>BaseDataWriter</code>称为<strong>具体部件</strong>（ConcreteComponent），定义了基础行为， 但装饰类可以改变这些行为。</p></li><li><p>抽象的装饰器基类<code>BaseDataWriterDecorator</code>称为<strong>基础装饰</strong>（BaseDecorator），拥有一个被封装对象的成员变量。该成员变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象。</p></li><li><p>具体的装饰器类<code>CsvDecorator</code>称为<strong>具体装饰类</strong>（ConcreteDecorators），定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为。</p></li></ul><pre><code class=" mermaid">classDiagram    direction TB    class Client        class Component &#123;        &lt;&lt; interface &gt;&gt;    +methodA() ResultA    &#125;Client --&gt; Componentclass ConcreteComponent &#123;+methodA() ResultA&#125;    ConcreteComponent ..|&gt; Componentclass BaseDecorator &#123;- Component component+BaseDecorator(Component)+methodA() ResultA&#125;BaseDecorator ..|&gt; Componentclass ConcreteDecorator &#123;+methodA() ResultA&#125;ConcreteDecorator --|&gt; BaseDecorator    </code></pre><p>由于装饰类都实现了部件接口，对于客户端来说，仍是通过部件接口与装饰后的对象交互，无需在意其是否是被装饰。</p><h2 id="具体部件与具体装饰类">具体部件与具体装饰类</h2><p>上例中，<code>BaseDataWriter</code>只是为了作为装饰链的终点，定义了两个空方法。而各种实际功能都定义在了<code>XxDecorator</code>中。这容易引起疑惑，<strong>具体部件和具体装饰类有什么区别，某个功能应该写成具体部件还是具体装饰类</strong>。</p><p>会发生这个问题，其实是因为最开头的例子并不合适。这都是笔者为了引出这个话题的良苦用心。</p><p>从结构分析，具体部件没有持有部件的成员变量，<strong>因此它一定是装饰链的末端</strong>。而且具体部件在创建对象时，不需要传入其他部件对象，而具体装饰类均需要一个已经存在的部件对象，<strong>因此具体部件通常先于具体装饰类实例化</strong>。基于这两个特征，可以认为对于特定装饰链，<strong>具体部件对象有且只有一个，而具体装饰对象可以有零个或多个，且创建具体装饰对象前需要先创建具体部件对象，具体装饰对象的存在依赖于具体部件对象</strong>。这意味着地位上，具体部件和具体装饰类不是等价的，具体部件相对更重要。</p><p>而上例中，各种<code>XxWriter</code>之间都是相互独立，地位均等的。没有说某个<code>XxWriter</code>一定依赖于另一个<code>XxWriter</code>。换句话说，无法找出一个必须存在的具体部件。因此定义了一个没有意义的空实现具体部件。</p><p>当所有功能相互独立，且可以单独存在的情况下，解决类组合爆炸的另一种优雅的解决方案是客户端引用的不是单个<code>DataWriter</code>，而是<code>List&lt;DataWirter&gt;</code>。对于所有<code>DataWriter</code>的方法调用，不是通过装饰链，而是遍历列表依次调用，调用顺序由加入<code>List</code>的顺序决定。</p><p>为了使例子更适合装饰模式，需要某个具体部件必须存在的场景。因此将例子调整为，需要将数据写入<code>txt</code>，并需要根据配置，选择是否进行加密或压缩。在这个场景中，写入负责<code>txt</code>的<code>txtWriter</code>必须存在，是具体部件；而加密或压缩，需要依赖于具体部件，根据运行时动态装饰对象添加功能，是具体装饰器。</p><h2 id="装饰模式与其他模式的异同">装饰模式与其他模式的异同</h2><p>结构上，装饰模式也是包装/封装（<code>Wrapper</code>）。这与前篇介绍的多种设计模式是相同的。</p><p>适配器模式会改变被封装对象的接口，而装饰模式不会改变封装前后对象的接口。此外，装饰模式可以递归封装，而适配器模式通常只会封装一次。</p><p>组合模式也可以递归封装，且不会改变接口，和装饰模式相似。区别是组合模式中，每个容器可以拥有多个子节点，而每个装饰类只能拥有一个被装饰对象。这个结构也导致递归调用，组合模式强调每个容器对子节点进行汇总，而装饰模式强调添加额外功能。</p><p>实际在上例中，要将数据写入多种格式，可以使用组合模式。通过在容器中持有多个接口对象，然后把容器传递给客户端，也可以避免客户端调整代码，不必修改为<code>List&lt;DataWirter&gt;</code>。</p><h2 id="总结">总结</h2><p>装饰模式允许在不修改现有对象结构的前提下向对象添加新的功能。</p><p>装饰模式通常用于解决多个功能根据场景开启，需要定义所有可能的组合引起的类爆炸问题。</p><p>装饰模式由部件、具体部件、基础装饰和具体装饰类组成。</p><p>具体部件、基础装饰、具体装饰都需要实现部件接口，因此这些类的实例对象可以被装饰类再次封装，形成装饰链。</p><p>调用装饰类对象的方法， 会根据装饰链依次进行委派调用。</p><p>运行时，具体部件类通常是必须实例化的，具体装饰器可以不实例化。</p><p>组合模式和前篇提到的适配器模式、组合模式相似，均属于包装。但在结构、功能和动机上略有区别。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Composite</title>
    <link href="/2024/09/29/Design-Pattern-Composite/"/>
    <url>/2024/09/29/Design-Pattern-Composite/</url>
    
    <content type="html"><![CDATA[<p><strong>组合模式(composite)</strong>是一种结构型设计模式，可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。</p><h2 id="场景">场景</h2><p>在开发中会遇到需要处理/统计的对象们，属于层级或者包含关系。学过数据结构的同学肯定知道，通常用<strong>树</strong>来组织这些对象。</p><p>树由节点和边构成。其中节点用于存储数据，而边构建了节点之间的关系。一个节点通过持有另一些节点的引用，来构建边。一段典型树结构代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义树的节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    List&lt;TreeNode&gt; children;<br><br>    <span class="hljs-comment">// 构造函数，初始化节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 添加子节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addChild</span><span class="hljs-params">(TreeNode child)</span> &#123;<br>        <span class="hljs-built_in">this</span>.children.add(child);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此基础上进行一些拓展。上例中，<strong>所有节点都属于同一类<code>TreeNode</code></strong>。而在实际建模时，不同维度节点需要储存和表示的信息不同，<strong>通常会使用不同类</strong>。例如想统计国内经济指标，节点可以是省、市、区、县类。当节点属于不同类时，我们没法在所有节点类中都使用<code>List&lt;TreeNode&gt; children</code>去定义所有可能的子节点。一种朴素的解决方法是，每种类仅持有其子类的节点。例如可以在定义<code>省</code>时，持有<code>市</code>的节点，<code>市</code>中再持有<code>区</code>的节点。但也存在例外，例如直辖市不属于任一省，某些市没有设置区。为了兼容这些特殊情况，需要定义多种类型子节点变量，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Country</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 国家特有的属性</span><br>    <span class="hljs-keyword">private</span> String president;<br>    <span class="hljs-comment">// 省子节点</span><br>    <span class="hljs-keyword">private</span> List&lt;Province&gt; childrenProvinces;<br>    <span class="hljs-comment">// 直辖市子节点</span><br>    <span class="hljs-keyword">private</span> List&lt;City&gt; childrenCities;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Province</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">City</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>而在客户端代码中，当需要统计某个省或者某个市的经济时，可能会定义如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Bigdecimal <span class="hljs-title function_">calculateGdpProvince</span><span class="hljs-params">(Province province)</span>;<br><span class="hljs-keyword">public</span> Bigdecimal <span class="hljs-title function_">calculateGdpCity</span><span class="hljs-params">(City city)</span>;<br></code></pre></td></tr></table></figure><p><strong>可以发现节点种类越多，定义节点的代码和客户端引用节点的代码就会越复杂。</strong></p><p>此外也会设计容器节点。<strong>容器节点指只提供结构和组织，而不直接存储数据的节点。</strong>例如上例中，想要统计一个省加一个市加一个区的数据，可以在容器节点中持有这三个不同类节点的引用。客户端只与容器节点交互，而不关心容器内具体包含什么。所以容器节点类需要依赖其他所有节点类。容器节点类内通常也会定义递归遍历其子节点的方法，<strong>当子节点种类越多时，容器节点类的代码也会越复杂。</strong></p><p>参考数据结构中经典的树结构，我们期望对所有节点类型一视同仁。如此节点内定义子节点和客户端引用的代码会更简洁。又期望保持每种节点类的特色。这显然要利用到<code>java</code>多态的特性。</p><h2 id="组合模式">组合模式</h2><p>组合模式中，所有节点类型都实现一个<code>Component</code>接口，用来表示是树结构中的一个节点。客户端通过接口与不同的节点类交互，并不关心其具体类型，移除了对具体节点类的依赖。<code>Component</code>接口中定义节点类需要向外暴露的共同特性，例如上例中统计GDP指标的方法。对于非叶子节点类，这些方法实现通常为调用其子节点的同方法，并汇总返回；而在叶子节点中，实际进行属性查询并计算。这种调用方式也被称为树的递归。</p><p>根据组合模式，我们可以重构上例中的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Component</span> &#123;<br>BigDecimal <span class="hljs-title function_">calculateGdp</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Country</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 国家特有的属性</span><br>    <span class="hljs-keyword">private</span> String president;<br>    <span class="hljs-comment">// 任意类型子节点</span><br>    <span class="hljs-keyword">private</span> List&lt;Component&gt; children;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculateGdp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> children.parallelStream()<br>                .map(Component::calculateGdp)<br>                .reduce(BigDecimal.ZERO, BigDecimal::add);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合模式的类图相对比较简单，核心便是代表节点的接口<code>Component</code>。对于节点类，通常还会分为叶子节点<code>Leaf</code>和非叶子节点（也称组合或容器）<code>Composite</code>。叶子节点由于不包含子节点，因此无需定义子节点的成员变量，也不需要提供添加/删除子节点的方法。</p><pre><code class=" mermaid">classDiagram    direction TB    class Client        class Component &#123;        &lt;&lt; interface &gt;&gt;    +methodA() ResultA    &#125;Client --&gt; Componentclass Leaf &#123;+methodA() ResultA&#125;class Composite &#123;-List~Composite~ children+methodA() ResultA+addChild(Component) void+removeChild(Component) Component&#125;    Leaf ..|&gt; Component    Composite ..|&gt; Component</code></pre><h2 id="添加和删除子节点的方法">添加和删除子节点的方法</h2><p>由于客户端与接口进行交互，而上例中接口中并不包含添加或删除子节点的方法。因此当客户端需要进行这类操作时，不可避免会依赖具体容器节点类。如果想移除这种依赖，可以将这些方法同样定义在接口中。但注意，这违反了单一职责原则，因为对于叶子节点来说，添加和删除子节点的方法是无意义，且不该被支持的。</p><p>不论是否在接口中声明这类方法，都是合理的选择。通常根据客户端使用这类方法的频率，来决定是否在接口中添加。这是对耦合性和接口隔离性的权衡与取舍。</p><h2 id="总结">总结</h2><p>组合模式通常使用于，需要处理统计的对象属于层级关系或包含关系。</p><p>组合模式通过定义一个<code>Component</code>接口来表示树上的一个节点，以此对所有具体节点类一视同仁，移除了对具体节点类的依赖，简化了具体节点类和客户端的代码。</p><p><code>Component</code>接口内需要声明对所有节点类都有意义的方法。</p><p>实现接口声明的方法时，容器应该将大部分工作交给其子元素来完成，也就是递归。</p><p>也可以在接口中定义添加或删除子节点的方法。这样允许客户端通过接口对容器元素进行操作，但也会违反单一职责原则。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-IoC-DI-PartII</title>
    <link href="/2024/08/16/SpringBoot-IoC-DI-PartII/"/>
    <url>/2024/08/16/SpringBoot-IoC-DI-PartII/</url>
    
    <content type="html"><![CDATA[<p>最近读了<code>Martin Fowler</code>关于<code>IoC</code>和<code>DI</code>的<ahref="https://www.martinfowler.com/articles/injection.html">文章</a>，觉得之前<a href="/2023/04/13/SpringBoot-IoC-DI/" title="SpringBoot-IoC-DI">SpringBoot-IoC-DI</a>写的还是太过狭隘。因此本篇对这个话题进行补充。</p><h2 id="ioc-和-di-的关系">IoC 和 DI 的关系</h2><p>在上一篇文章中，首段的描述似乎把<code>DI</code>定义为与<code>IoC</code>同级的概念，这种暗示是错误的。</p><blockquote><p>而<code>Spring Core</code>完成了两个关键概念：<code>IoC</code>（Inversionof Control，控制反转）和<code>DI</code>（DependencyInjection，依赖注入）。</p></blockquote><p>实际上，<code>IoC</code>是一种设计原则或者说设计理念，而<code>DI</code>是实现这种设计原则的一种具体方式。除<code>DI</code>以外，还有其他实现<code>IoC</code>的方式。<code>IoC</code>在不同语境下，也存在着不同的解释。</p><p>通俗地说，<code>DI</code>是<code>IoC</code>的一种特例，是<strong>在将不同组件/模块组合成一个大型程序的语境下，实现控制反转</strong>的一类方法。</p><h2 id="ioc">IoC</h2><p><code>IoC</code>（Inversion ofControl，控制反转），在上篇中默认了<strong>将不同组件/模块组合成一个大型程序的语境</strong>，给出了狭隘的定义。</p><blockquote><p><code>IoC</code>是一种设计模式，它将对象的创建和管理的控制从应用程序代码转移到了容器中。</p></blockquote><p>广义的<code>IoC</code>不限于此。要搞清什么是控制反转，那么就得清楚，<strong>被控制的是什么，被反转的又是什么</strong>。</p><p>程序员学习编程语言，通常会从命令行程序开始。在命令行中输出提示语句，等待用户输入。程序将用户输入保存在变量中，然后输出下一个提示语句并等待。在这个过程中，用户无法改变输入顺序。比如程序要求先输入姓名，然后输入性别，最后输入年龄，用户没法先输入年龄，后输入姓名。这是因为程序的运行顺序已经在编码时确定，编码（内部）顺序控制着程序的执行顺序。这也是面向过程编程的特点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Pseudocode">print &quot;enter your name&quot;<br>read name<br>print &quot;enter your age&quot;<br>read age<br>etc...<br>store in database<br></code></pre></td></tr></table></figure><p>更进一步，一些命令行程序允许用户输入操作指令，来控制程序的执行顺序。例如输入<code>name</code>后，程序等待用户输入姓名，而输入<code>q</code>后程序则终止。这样用户可以按照任意顺序进行输入，甚至修改已输入的内容。此时，程序的执行顺序在编码时是不确定的，而是在运行时，根据用户（外部）行为随机应变的。从代码上看，录入姓名功能的代码，并不知道自己何时将被调用。外部可能包含一个循环和<code>if</code>语句，根据用户输入的<code>name</code>和<code>q</code>，来调用对应功能的代码。这实现了<strong>控制反转</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Pseudocode">loop<br>    print &quot;enter your operator, &#x27;name&#x27; for set name, &#x27;q&#x27; for quit&quot;<br>    read operator<br>    if operator == name<br>        call setName<br>    else if operator == q<br>        call quit<br>    etc...<br>end loop<br><br>function setName:<br>    print &quot;enter your name&quot;<br>    read name<br></code></pre></td></tr></table></figure><p>再进一步，不再是命令行，而是具有<code>GUI</code>的程序。用户通过选中文本框输入，在任意时刻点击提交或取消按钮，来控制程序的执行顺序。用户控制程序的执行顺序变得更加自由。这更加实现了<strong>控制反转</strong>。</p><p><strong>总结上述例子，当程序功能的执行顺序/时机由外部控制，而不是内部定义，就实现了控制反转</strong>。这回答了本节开头的问题，<strong>被控制的是程序功能的执行顺序/时机，被反转的是控制方由内部转为外部</strong>。</p><p>实现了控制反转时，体现在代码中的特点，通常是<strong>定义了回调函数(callback)</strong>。在上例中，设置名称和退出方法，都是回调函数。这两个方法的执行时机，在编译时无法知晓。条件满足时，会由外部控制器调用具体方法。在编写方法时，不用关心方法会何时被执行。这意味着<code>what to do</code>和<code>when to do</code>的代码是分开的。</p><h2 id="spring中的ioc">Spring中的IoC</h2><p>上一节提到控制反转，<code>IoC</code>是将程序功能的执行控制由内部转移到外部，实现<code>IoC</code>的特点是定义了回调函数。那么在提到<strong><code>Spring</code>实现了<code>IoC</code>时</strong>，内部和外部指什么，又是定义了哪个回调函数。</p><p>在回答上面问题之前，先聊聊使用<code>Spring</code>的动机。</p><p>程序员都是从某个单一功能的程序开始学习编程，后续也少有功能的扩展。而企业中运行的应用程序（通常称为<strong>系统</strong>）随着版本更迭，通常由多个不同的开发人员合作完成各个功能的扩展。为了避免多人开发时，开发人员相互影响，提出了<strong>模块化编程</strong>的思想。主旨就是将功能拆分成多个模块/文件，每个模块负责实现特定的功能或逻辑。模块化编程可以提高代码的可维护性、可读性、复用性。安排开发人员开发不同模块，也能减少相互影响的程度。企业应用常见的<code>MVC</code>(Model-View-Controller，模型-视图-控制器)模型也正是模块化编程的体现。</p><p>模块化编程下，原本复杂的功能，被拆分成多个功能模块/组件。在实际使用应用程序时，就涉及<strong>将多个功能各异的模块，组装成一个应用程序</strong>。具体来说，模块之间存在着依赖（模块存在的意义就是被其他模块调用），例如<code>A</code>模块通过成员变量持有<code>B</code>模块的引用，并在A的方法定义中，调用了<code>B</code>模块中的方法。这就引起了一个问题，<strong>如何处理模块间的依赖关系，将各个模块链接在一起</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 对B模块的依赖</span><br><span class="hljs-keyword">private</span> B b;<br>&#125;<br></code></pre></td></tr></table></figure><p>最直观简单的方式，就是<code>new</code>一个<code>B</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 对B模块的依赖</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的确能把<code>A</code>和<code>B</code>联系起来。但如果还有其他模块也需要依赖模块<code>B</code>，并且也是通过这种形式创建再链接，那么在内存空间会存在<code>B</code>的多个实例。每个模块中对<code>B</code>的依赖都是一个独立的实例。如果模块<code>B</code>包含一些状态，多个实例的状态不一致会引起问题。因此我们更希望多个模块依赖<code>B</code>，引用的是同一个<code>B</code>实例。</p><p>此外，为了写出通用代码，我们会将<code>B</code>模块设置成一个接口，使得A模块的功能可以独立于<code>B</code>模块的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 对B模块的依赖</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">BInterface</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BImplement</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>语法上代码可以通过编译。但这种写法使得<code>A</code>模块不仅依赖了<code>B</code>接口，同时也通过<code>new</code>关键字依赖了<code>B</code>接口的具体实现。</p><p><code>B</code>接口有多个实现，具体需要哪个实现，可能在运行时才能确定，例如根据配置文件或用户输入。直接在模块中创建任意一个<code>B</code>接口实例，会使得定义<code>B</code>接口变得没有意义，仍然不是一个通用的代码。</p><p>所以对于<code>A</code>来说，要写出通用的代码，不应该依赖<code>B</code>接口具体实现。换句话说，在<code>A</code>的内部代码中，无法完成对成员变量<code>B</code>接口赋值。那么就需要一个额外的组装器类，专负责把<code>A</code>和<code>B</code>拼接在一起。</p><pre><code class=" mermaid">classDiagramdirection TBclass A &#123;- BInterface+ Amethod()&#125;    class BInterface &#123;        &lt;&lt; interface &gt;&gt;        + Bmethod()&#125;A --o BInterfaceclass BImplementation &#123;+ Bmethod()&#125;BImplementation ..|&gt; BInterfaceclass Assembler &#123;+ assembleAAndB（）&#125;Assembler ..&gt; A    Assembler ..&gt; BImplementation    Assembler ..&gt; BInterface</code></pre><p>具体来说，组装类需要找到符合条件的对象，通过某种方式把对象赋值到需要的地方。<code>DI</code>就是其中一种方式，指模块通过定义注入方法，等待外部组装器调用，进行依赖链接。<strong>从描述来看，对模块间链接的过程，由模块内部，转移到了外部专门的组装器类，实现了<code>IoC</code>。定义的回调函数，通常是构造函数或setter函数，而外部的组装类，控制了回调函数的执行</strong>。</p><p>对于多个模块来说，每个模块都需要一个组装类。但实际上不同模块的组装类在功能上是高度相似的。抽象地说，就是找到等待注入的回调函数，使用合适的参数调用这些注入方法。因此通常可以将多个模块的组装器类整合到一个通用的组装器类中，我们称之为<strong>容器</strong>。通常容器不仅完成了模块间的链接，还负责了每个模块的创建工作。</p><h2 id="di">DI</h2><p>依赖注入有多种形式，按照<code>Martin Fowler</code>的定义包括：构造器注入、setter注入、接口注入。实际上在现代<code>Spring</code>开发中，使用更多的是基于注解与反射的字段注入，因此对于上述三种注入形式，只是简单了解学习。</p><p>构造器注入，<code>setter</code>注入是较为常见的注入方式。指在模块中，对其依赖的模块，提供对应的构造方法或<code>setter</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 对B模块的依赖</span><br><span class="hljs-keyword">private</span> BInterface b;<br>    <span class="hljs-comment">// 构造器注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(BInterface b)</span> &#123;<br>    <span class="hljs-built_in">this</span>.b = b;<br>    &#125;<br>    <span class="hljs-comment">// setter注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setB</span><span class="hljs-params">(BInterface b)</span> &#123;<br>        <span class="hljs-built_in">this</span>.b = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写的注入方法无需考虑具体的调用时机，因此某种程度这些方法也属于回调函数。定义的方法会由容器进行调用。容器会判断，需要注入的类是否含有构造方法或<code>setter</code>方法，找到符合条件的对象，实际调用这些注入方法。</p><p>接口注入是指，定义一个注入某个模块的接口，通常只声明一个注入指定模块方法。然后由依赖这个模块的类实现这个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InjectB</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">injectB</span><span class="hljs-params">(BInterface b)</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InjectB</span> &#123;<br><span class="hljs-keyword">private</span> BInterface b;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">injectB</span><span class="hljs-params">(BInterface b)</span> &#123;<br>    <span class="hljs-built_in">this</span>.b = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式和<code>setter</code>注入很像，都是定义了一个回调函数。区别是容器可以通过<code>instanceof</code>关键字判断某个类是否实现了注入接口，来确定是否存在需要注入的依赖。如果一个模块依赖着多个模块，会需要实现非常多的接口，显得繁琐，因此实际上接口注入使用不多。<code>Spring</code>中最常见的接口注入形式，是各种<code>xxxAware</code>，例如<code>ApplicationContextAwareProcessor</code>。在此不再赘述。</p><p>上文仅描述了定义这些回调方法。我们仍需要某种方式告知容器，需要对哪些模块进行组装。可以通过多种形式，例如在代码中对需要组装的模块进行注册，或者在<code>XML</code>文件中对<code>bean</code>和其依赖进行描述性定义。容器创建对象和进行组装的时机，取决于具体容器实现。这部分不是本文重点，不再赘述。</p><h2 id="service-locator">Service Locator</h2><p>DI的主要动机是，移除了模块对某些接口具体实现的依赖。DI不是达成这个目的的唯一途径，服务定位（servicelocator）是另一种模式。</p><p>在服务定位模式中，存在一个全局单例对象，掌握着所有接口对应的实现类对象。每个模块可以通过这个服务定位器对象，获取指定接口类型/名称的实例。</p><pre><code class=" mermaid">classDiagramdirection TBclass A &#123;- BInterface+ Amethod()&#125;    class BInterface &#123;        &lt;&lt; interface &gt;&gt;        + Bmethod()&#125;A --o BInterfaceclass BImplementation &#123;+ Bmethod()&#125;BImplementation ..|&gt; BInterfaceclass Assembler    Assembler ..&gt; BImplementation    Assembler ..&gt; BInterface        class ServiceLocator&#123;+ getB()&#125;    A ..&gt; ServiceLocatorAssembler ..&gt; ServiceLocatorServiceLocator ..&gt; BInterface</code></pre><p>在类图中，<code>Assembler</code>和<code>ServiceLocator</code>，通常前者完成对象的创建，后者完成将某个实例与某个接口/名称绑定。两者也可以合并成一个类。</p><p>之后，只需要在需要依赖的模块中，例如构造函数、字段初始化或函数定义中，访问服务定位器的方法，就可完成依赖的链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceLocator</span> &#123;<br>    <span class="hljs-comment">// 指定方法获取某个接口对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BInterface <span class="hljs-title function_">getB</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    &#125;<br>    <span class="hljs-comment">// 通过接口类型获取对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> &#123;<br>        ...<br>    &#125;<br>    <br>    <span class="hljs-comment">// 通过名称获取对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 字段初始化时访问服务定位器</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">BInterface</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ServiceLocator.getB();<br>    <span class="hljs-comment">// 默认构造函数中访问服务定位器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.b = ServiceLocator.getBean(BInterface.class);<br>    &#125;<br>    <span class="hljs-comment">// 函数中访问服务定位器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Amethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.b = (BInterface)ServiceLocator.getBean(<span class="hljs-string">&quot;OneOfBImplementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里看，服务定位也消除了模块<code>A</code>对<code>B</code>接口具体实现的依赖。模块<code>A</code>对于依赖链接的时机是了解的，是在模块<code>A</code>内部显示定义的。模块<code>A</code>也没有提供相应的回调函数，等待被外部调用。但对于<code>B</code>接口具体实现的实例化过程，是不了解的。因此笔者认为服务定位模式不完全实现了<code>IoC</code>。</p><p>对比<code>DI</code>和服务定位，在<code>DI</code>中，模块对于外部的认知是最少的，甚至不知道容器的存在；而在服务定位中，所有模块都需要依赖服务定位器。服务定位器是一个全局单例，有着全局变量的缺点，例如可能会掩盖模块间的依赖关系。</p><p>在<code>Spring</code>中，<code>BeanFactory</code>容器，同时完成了<code>DI</code>和服务定位两种功能。服务定位对应的就是<code>BeanFactory</code>中的<code>getBean</code>方法。<strong>在源码的注释中，更推荐使用<code>DI</code>来完成依赖链接的功能。</strong></p><blockquote><p>Note that it is generally better to rely on Dependency Injection("push" configuration) to configure application objects through settersor constructors, rather than use any form of "pull" configuration like aBeanFactory lookup. Spring's Dependency Injection functionality isimplemented using this BeanFactory interface and its subinterfaces.</p></blockquote><h2 id="总结">总结</h2><p>广义的<code>IoC</code>，是指某段程序的执行由外部行为控制，而不是内部定义，则称实现了<code>IoC</code>。</p><p>实现<code>IoC</code>体现在代码中的特征通常是定义了回调函数，将<code>what to do</code>和<code>when to do</code>的代码分开。</p><p>现代大型企业应用程序为了代码可维护性、可读性、复用性，采取了模块化编程的形式。</p><p>在模块化编程中，模块之间存在着依赖，具体体现在一个模块通过成员变量持有另一个模块的引用。因此需要将多个模块组装成应用的过程。</p><p>在将不同组件/模块组合成一个大型程序的语境下，<code>DI</code>实现<code>IoC</code>的一种方式，通常用容器完成这个过程。</p><p><code>DI</code>通常包括构造器注入，<code>setter</code>注入，接口注入。现代更常用的是通过注解和反射的字段注入的方式。</p><p>服务定位也可以消除模块对接口实现类的依赖。通过访问一个全局单例的服务定位器，来获取需要的依赖。</p><p>服务定位没有完全实现<code>IoC</code>。</p><p><code>Spring</code>同时实现了<code>DI</code>和服务定位，但更推荐使用<code>DI</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Bridge</title>
    <link href="/2024/07/26/Design-Pattern-Bridge/"/>
    <url>/2024/07/26/Design-Pattern-Bridge/</url>
    
    <content type="html"><![CDATA[<p><strong>桥接模式</strong><code>(Bridge Pattern)</code>是一种<strong>结构型模式</strong>。它的主要作用是将<strong>抽象</strong>部分与<strong>实现</strong>部分分离，使它们可以独立变化。</p><h2 id="场景">场景</h2><p>有一个形状<code>Shape</code>类，从它扩展出两个子类：长方形<code>Rectangle</code>和圆形<code>Circle</code>。假设需要在另一个维度颜色<code>Color</code>上，对<code>Shape</code>再进行扩展细分。如果只有红色<code>Red</code>和蓝色<code>Blue</code>两种颜色，那么一共需要四个类覆盖所有的组合。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">                   ----Shape---<br>                  /            \<br>         Rectangle              Circle<br>        /         \            /      \<br>BlueRectangle  RedRectangle BlueCircle RedCircle<br></code></pre></td></tr></table></figure><p>在形状和颜色种类不多时，上述的继承关系并没有太大问题。但如果有一百种形状，那么想新加一种颜色，就需要新增一百个新增颜色和已有形状组合的类。更不用说需要在更多维度进行扩展，例如材质<code>Material</code>、尺寸<code>Size</code>等等。具体来说，类需要在<spanclass="math inline">\(n\)</span>个维度拓展，第<spanclass="math inline">\(i\)</span>个维度的种类为<spanclass="math inline">\(m_i\)</span>，那么类的组合数量为<spanclass="math inline">\(\prod \limits_{i=1}^nm_i\)</span>。这种类的数量随着维度的扩展剧烈增长，造成系统复杂性过高、难以维护的情况，称为<strong>类爆炸</strong>。</p><p><code>BlueRectangle</code>和<code>BlueCircle</code>关于颜色方面的代码中，是高度重复的。当需要对<code>Blue</code>的代码内容进行改动时，需要改动所有和<code>Blue</code>有关的类。从另一个角度说，形状和颜色是两种不相关的维度。如果把两个维度写在同一个类中，违反了<strong>单一职责原则</strong>。这可能导致改动颜色代码时，会破坏形状中的功能。</p><h2 id="桥接模式">桥接模式</h2><p>解决方法也很直观。对于重复出现的<code>Bule</code>和<code>Red</code>代码，抽取到单独的类中。并在形状中，组合对颜色的引用。当形状需要访问颜色相关的特性时，委派给具体颜色对象的方法。<strong>形状中对颜色的引用，像一座桥梁，将两者的功能组合到一起，因此称其为桥接模式</strong>。此时类关系降维成了下图。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">          ----Shape---                        Color<br>         /            \                       /   \<br>Rectangle(Color)   Circle(Color)           Blue   Red<br></code></pre></td></tr></table></figure><p>重构完后，类的数量变成了<span class="math inline">\(\sum\limits_{i=1}^nm_i\)</span>，代码重复率下降，形状和颜色的代码也不再耦合。</p><pre><code class=" mermaid">classDiagram    direction TB    class Client        class Abstraction &#123;    - Implementation i    +featureA()    &#125;Client --&gt; Abstraction    class RefinedAbstraction &#123;    +featureB()    &#125;    RefinedAbstraction --|&gt; Abstractionclass Implementation &#123;&lt;&lt; interface &gt;&gt;+method()&#125;Abstraction --o Implementationclass ConcreteImplementation &#123;+method()&#125;ConcreteImplementation ..|&gt; Implementation</code></pre><p>在类图中，上例<code>Shape</code>对应<strong>抽象</strong><code>Abstraction</code>，<code>Color</code>对应<strong>实现</strong><code>Implementation</code>，<code>Rectangle</code>和<code>Cirle</code>对应<strong>精确抽象</strong><code>RefinedAbstraction</code>，<code>Blue</code>和<code>Red</code>对应<strong>具体实现</strong><code>ConcreteImplementation</code>。核心结构是，<strong>抽象</strong>通过组合，持有了<strong>实现</strong>的对象。为了获得了<strong>实现</strong>相关的特性，当<strong>抽象</strong>中方法调用，需要委派给实际<strong>实现</strong>对象。客户端只与<strong>抽象</strong>交互。</p><p>实际上，桥接模式在前文中已经出现过。<a href="/2023/06/27/Design-Pattern-Design-Principle/" title="Design-Pattern-Design-Principle">Design-Pattern-Design-Principle</a>中，在讨论<strong>组合优于继承</strong>的话题时，举例了<strong>抽象</strong>怪物类中，组合了<strong>实现</strong>飞行和攻击的能力。这里通过桥接模式，避免了“会攻击不会飞行的怪物类”、“不会攻击会飞行的怪物类”的产生。</p><h2 id="抽象与实现">抽象与实现</h2><p>在描述桥接模式时，使用了<code>GoF</code>书籍中定义的概念，<strong>抽象</strong>与<strong>实现</strong>。</p><p>由于这两个概念，和面向对象中的<strong>抽象类</strong>和<strong>接口实现</strong>概念形式上相似，容易引起歧义。让人觉得<strong>抽象</strong>是接口定义，而<strong>实现</strong>是对接口的具体实现。然而两者没有必然联系，虽然语义上存在相似之处。</p><p>具体来说，桥接模式中的<strong>抽象</strong>，不一定是<strong>抽象类</strong>，可以是<strong>具体类</strong>。<strong>实现</strong>也不一定<strong>接口实现类</strong>，一般是<strong>接口</strong>本身。<strong>抽象</strong>和<strong>实现</strong>也不是<a href="/2023/06/12/Design-Pattern-Relationships-Between-Objects/" title="Design-Pattern-Relationships-Between-Objects">Design-Pattern-Relationships-Between-Objects</a>中的继承或实现关系，而是组合关系。所以这里的抽象和实现，和编程语言中说的不是同一个事。</p><p>桥接模式中的<strong>抽象</strong>，一般是高阶控制层，负责定义对象的行为和属性，使得客户端可以通过它与实现部分进行交互，而不必关心实现的细节；而<strong>实现</strong>定义了抽象部分所描述的操作的具体实现，关注的是如何执行操作。从这个角度看，宏观上<strong>抽象</strong>与<strong>实现</strong>之间的关系和编程语言中的<strong>接口</strong>和<strong>接口实现</strong>概念相近，都是一个负责定义行为，另一个负责具体实现，强调将接口与其实现分离，以提高灵活性和可扩展性。区别是<strong>接口</strong>与<strong>接口实现</strong>通常只涉及一个层次，而<strong>抽象</strong>与<strong>实现</strong>涉及多个层次。<strong>抽象</strong>与<strong>每个实现</strong>都对应着一组<strong>接口</strong>与<strong>接口实现</strong>。例如上例中，抽象对应着<code>Shape</code>抽象类和<code>Rectangle</code>和<code>Cirle</code>具体类，实现对应着<code>Color</code>接口和<code>Blue</code>和<code>Red</code>实现类。并且在<strong>抽象</strong>中，包含着对实现的引用，和核心业务逻辑和行为；而在<strong>接口</strong>中，无法定义成员变量，通常也不会包含实际业务代码（虽然<code>java8</code>接口也可以有默认方法）。</p><p>桥接模式适用于类在多个维度上进行拓展的场景。在上例中，我们天然地认为了<strong>形状</strong>是<strong>抽象</strong>，<strong>颜色</strong>是<strong>实现</strong>，是<strong>形状</strong>持有了<strong>颜色</strong>的引用。<strong>抽象</strong>和<strong>实现</strong>无法相互替换，意味着多个维度并不是一视同仁，地位均等的。哪个为抽象，哪个为实现，主要是根据这些维度在系统中的角色，和它们对系统的设计影响来决定的。一个有颜色的形状，会比有形状的颜色要来的更符合客户端的需求。</p><p>此外桥接模式中，通过抽象和实现进行分离，再通过组合，形成<spanclass="math inline">\(AB = A +B\)</span>的效果，需要两者功能相互独立。如果具体抽象会影响到具体实现的行为，则不适用于桥接模式。</p><h2 id="与适配器模式的区别">与适配器模式的区别</h2><p>桥接模式中，抽象组合了实现，通过成员变量持有被包装类的对象，也是一种<strong>包装</strong>。</p><p>适配器模式与桥接模式的主要区别如下：</p><ol type="1"><li>适配器模式中，被包装类的代码通常来自第三方库或陈年代码，没有改动权限；而在桥接模式中，实现（被包装的对象）的代码通常需要开发人员自己编写。</li><li>从动机上来说，适配器模式则是将被适配接口，转换为了客户端需要的目标接口，扩展了代码的兼容性；桥接模式把相互独立的抽象和实现抽取到了两个类中，避免类爆炸。</li><li>适配器模式的目标接口与被适配接口，通常是功能相近但不同的接口；桥接模式的抽象与实现中的接口，通常是两个不同维度，接口完全不同。</li></ol><h2 id="与策略模式的区别">与策略模式的区别</h2><p>在行为型模式中有一种策略模式。策略模式中通常是一个<strong>上下文</strong>组合一个<strong>策略</strong>的引用，也是一种<strong>包装</strong>。<strong>策略</strong>通常是一个接口，在运行时能够更换其不同实现类。从这来看，策略模式的类结构图和桥接模式几乎相同。网上很多回答会强调，桥接模式是<strong>结构型模式</strong>，策略模式是<strong>行为型模式</strong>，所以他们俩不一样。这是在玩概念游戏，是在用定义去解释特征。对于我们区分两者也没有帮助。</p><blockquote><p>如果它看起来像鸭子、游泳像鸭子、叫声像鸭子，那么它可能就是只鸭子。</p></blockquote><p>我们应更多从本质上进行区分。实际上很多策略模式的例子，在桥接模式的概念中解释也没有太多违和感。<strong>上下文</strong>通常作为高阶控制层，在实际执行时委派给了具体<strong>策略</strong>实现。<strong>上下文</strong>通常独立于<strong>具体策略</strong>，因此可以相互独立地改动两部分代码。这些正是上文中对桥接模式的描述，在策略模式上同样成立。最显著的区别，是桥接模式中，<strong>抽象</strong>可以进行拓展，而策略模式中的<strong>上下文</strong>通常不拓展，除此外没有区别。因此笔者认为<strong>策略模式是桥接模式的一种特例</strong>。实际编写代码时，通常也不加区分，不会指定要使用其中一种。</p><h2 id="总结">总结</h2><p>如果一个类，需要在多个维度上进行拓展，可能会导致类爆炸问题，可以通过桥接模式进行解耦。</p><p>选定其中相对用于控制的维度作为<strong>抽象</strong>，将其他维度抽取成<strong>实现</strong>。通过组合的形式在抽象中持有实现的引用。在客户端访问抽象时，把实际执行委派给<strong>实现</strong>对象。</p><p>桥接模式与适配器模式、策略模式均为包装。结构相似，但又有所不同。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Adapter</title>
    <link href="/2024/07/03/Design-Pattern-Adapter/"/>
    <url>/2024/07/03/Design-Pattern-Adapter/</url>
    
    <content type="html"><![CDATA[<p><strong>创建型模式</strong>已经全部介绍完，接下来是<strong>结构型模式</strong>。</p><p>在以往的文中提过，<strong>结构型模式</strong>和<strong>行为型模式</strong>边界比较模糊。根据定义，<strong>结构型模式</strong>侧重于类和对象的组合以构建灵活且高效的结构，而<strong>行为型模式</strong>侧重于类和对象之间的通信和职责分配。但<strong>结构</strong>和<strong>行为</strong>本身就会相互影响，因此会存在模棱两可的分类。例如<strong>代理</strong>语义上是个行为，但是<strong>代理模式</strong>是<strong>结构模式</strong>；<strong>中介者</strong>组织了<strong>组件</strong>间的结构关系，但是<strong>中介者模式</strong>是<strong>行为模式</strong>。</p><p><strong>结构模式</strong>和<strong>行为模式</strong>都涉及多个类或对象。通常来说，<strong>结构模式</strong>中的单个类通常是不完整的，需要通过特定结构，来组成完整的功能。而<strong>行为模式</strong>中的单个类通常是独立的，模式定义了这些类之间的交互。</p><p>此定义能提供一些解释，但也不严谨，存在反例。笔者认为对于设计模式分类过度纠结是钻牛角尖，在实际使用时也不会纠结如何辨别两者。</p><h2 id="场景">场景</h2><p>假设现在有一段<strong>客户端</strong>代码，其中和<code>A</code>类对象进行交互。根据业务需求，在代码中需要新增与<code>B</code>类对象进行交互的需求。为了更形象，可以想象客户端代码是一个进行数据分析的功能，<code>A</code>和<code>B</code>类是某种特定格式的数据。客户端代码需要读取数据，对数据进行处理并展示结果。</p><p>由于<code>B</code>类的交互方式与<code>A</code>类不同，因此无法在不修改客户端代码的情况下对<code>B</code>进行适配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端代码，与A类对象交互</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">client</span><span class="hljs-params">(A a)</span> &#123;<br>    ...<br>    a.methodA();<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <span class="hljs-type">Result</span> <span class="hljs-variable">resultA</span> <span class="hljs-operator">=</span> client(a);<br>    <span class="hljs-comment">// B b = new B();</span><br>    <span class="hljs-comment">// Result resultB = client(a); 类型不匹配，无法通过编译</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不想改变客户端代码，要使得代码能运行。直观的想法，可以<strong>在调用客户端方法前，把<code>B</code>类对象转化为<code>A</code>对象</strong>。这个方法通常定义在客户端所在的类中。如果代码中不止此客户端，还有很多位置都会用到这个方法，可以把这个转化方法设置为静态公共方法。后续如果还要兼容其他<code>C</code>、<code>D</code>类等，可以把这些转换方法都抽取到一个工具类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> convertBToA(b);<br>    <span class="hljs-type">Result</span> <span class="hljs-variable">resultB</span> <span class="hljs-operator">=</span> client(a); <br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换方法，将B类对象转化为A类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">convertBToA</span><span class="hljs-params">(B b)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <span class="hljs-comment">// 一些初始化代码</span><br>    ...<br>    B.methodB();<br>    ...<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>从<strong>面向接口编程</strong>的思想出发，客户端代码如果需要兼容功能相似的多个类，应该定义统一的接口，并将多个类都实现这个接口。在客户端代码中，通过接口定义的方法与这些类进行交互，实现代码通用性。所以另一种修改思路就是定义共同接口，并<code>A</code>和<code>B</code>中都实现这个接口，并将客户端改为使用接口作为参数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端代码，与A接口交互</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">client</span><span class="hljs-params">(InterfaceA a)</span> &#123;<br>    ...<br>    a.methodA();<br>    ...<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;...&#125;;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;...&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的写法通常是最佳实践。但此处存在一个前提，对于<code>B</code>类，我们有修改其代码的权限。具体来说我们修改<code>B</code>类实现了<code>InterfaceA</code>接口。但这个前提不是一定成立的。例如<code>B</code>类代码在别处还有引用，修改可能会破坏其它功能；例如<code>B</code>类来自某个第三方库。在这种场景下，就需要用到适配器模式了。</p><h2 id="适配器模式">适配器模式</h2><p>适配器模式中，新增了一个<strong>适配器（Adapter）类</strong>。适配器类实现了<strong>目标（Target）接口</strong>，并通过组合形式持有一个<strong>被适配对象（Adaptee）类/接口</strong>。</p><p>对于上文例子来说，目标接口就是<code>InterfaceA</code>，被适配对象就是类<code>B</code>。由此可以得出以下类关系图和适配器代码。</p><pre><code class=" mermaid">classDiagram    direction TB    class Client        class InterfaceA &#123;        &lt;&lt; interface &gt;&gt;    +methodA() ResultA    &#125;        Client --&gt; InterfaceAclass BAdapter &#123;-B b+methodA() ResultA&#125;class B &#123;+methodB() ResultB&#125;    BAdapter ..|&gt; InterfaceA    BAdapter --&gt; B</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Client 和 InterfaceA的定义同上</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-comment">// 通过成员变量持有一个B类对象</span><br>    <span class="hljs-keyword">private</span> B b;<br>    <br>    <span class="hljs-comment">// 构造函数中传入一个B类对象</span><br>    BAdapter(B b) &#123;<br>    <span class="hljs-built_in">this</span>.b = b;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    ResultA <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        ...<br>        <span class="hljs-comment">// 在调用B的方法前，进行一些类型转换等适配</span><br>        <span class="hljs-comment">// 并将实际调用委派给被适配类</span><br>        <span class="hljs-type">ResultB</span> <span class="hljs-variable">resultB</span> <span class="hljs-operator">=</span> b.methodB();<br>        <span class="hljs-comment">// 根据B的方法返回值，将结果转换成接口需要的类型</span><br>        ...<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，<code>Client</code>中需要<code>InterfaceA</code>接口的实现类，而我们希望支持<code>B</code>类对象时，可以在传入前创建一个从<code>B</code>类对象到<code>InterfaceA</code>的适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">InterfaceA</span> <span class="hljs-variable">bAdapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BAdapter</span>(b); <span class="hljs-comment">// BAdapter 实现了 InterfaceA，编译通过</span><br>    <span class="hljs-type">Result</span> <span class="hljs-variable">resultB</span> <span class="hljs-operator">=</span> client(bAdapter); <br>&#125;<br></code></pre></td></tr></table></figure><p>从代码形式看，使用适配器的方式，和上文中的调用前先转换的方式<code>convertBToA</code>很像。区别是<code>convertBToA</code>中返回的是具体的<code>A</code>类对象，而客户端需要的也是<code>A</code>类。但当客户端接受的是某个接口类型<code>InterfaceA</code>，此时再把所有对象转换成<code>A</code>类（实现了<code>InterfaceA</code>），虽然也能满足功能，但总觉得像饶了原路，不符合面向接口编程的思想。</p><p>或者可以在转换方法中新建一个<code>InterfaceA</code>的匿名实现类对象（匿名实现类通常用于较为简单的接口实现）。将这个行为提取到一个类中，就是适配器模式本身，只是原来的匿名实现类，变成了适配器类。</p><h2 id="类适配器">类适配器</h2><p><strong>适配器模式</strong>，都会将对于<strong>目标类/接口</strong>的调用，转化为对<strong>被适配类/接口</strong>的调用。</p><p>上文中，<strong>适配器类</strong>通过成员变量持有一个<strong>被适配对象</strong>。当适配器类被调用时，会最终委派给被适配对象的调用。这种通过持有一个<strong>被适配对象</strong>的适配器模式，称为<strong>对象适配器</strong>。另一种实现形式是<strong>类适配器</strong>。</p><p><strong>类适配器</strong>通过<strong>继承</strong>来获得<strong>被适配类</strong>的功能。在继承后，<strong>类适配器</strong>中，可以直接调用被适配类的方法。</p><p>如果<strong>目标</strong>是一个类，那么<strong>类适配器</strong>就是<strong>目标类</strong>的子类，在代码中可以通过多态的形式，将<strong>适配器类</strong>传给<strong>目标类</strong>的引用。如果目标是一个接口，那么<strong>类适配器</strong>需要通过实现的形式，称为目标接口的一个实现类。</p><p>因此区分<strong>对象适配器</strong>和<strong>类适配器</strong>的关键，在于<strong>适配器</strong>是通过何种形式获取<strong>被适配类</strong>的功能。如果是<strong>组合</strong>一个<strong>被适配类的对象</strong>，则是<strong>对象适配器</strong>，如果是通过继承<strong>被适配类</strong>，则是<strong>类适配器</strong>。</p><p>由于在设计模式中，通常认为<strong>组合优于继承</strong>，并且对于一些语言来说，例如<code>java</code>，不支持多继承，无法同时继承被适配类和目标类。因此更多使用的是<strong>对象适配器</strong>。后续均以<strong>对象适配器</strong>代表<strong>适配器模式</strong>。</p><h2 id="特点">特点</h2><p>用通俗的话来说，适配器模式就是，需要某个特定类/接口，但是提供的类和需要不符。通过新建一个适配器类，这个适配器类符合了需要，并在适配器类中完成提供的类和需要的类之间的转化。</p><p><strong>适配器类</strong>可以理解为，把<strong>被适配类</strong>，当作<strong>目标类/接口</strong>的一种视角。</p><p>识别<strong>目标类</strong>和<strong>被适配类</strong>是关键的。很多文章中用到了插头和插座的例子。在这个例子中，不同国家的插座是<strong>被适配类</strong>，插头是<strong>目标类</strong>，插座不满足插头的要求。电源适配器完成了从不满足要求的插座，到满足要求的插座转化的过程。</p><p>适配器模式通常使用于，客户端和被适配类不兼容，且都无法修改的场景。</p><h2 id="包装">包装</h2><p>适配器模式也被称为包装（<code>Wrapper</code>）。广义的包装是指对一个已有对象，进行包裹，从而改变或扩展它们的行为，而无需修改原始对象的代码。典型的特征是用于包装的类通常通过成员变量持有被包装类的对象。就这个定义来说，后续会介绍的<strong>代理模式</strong>、<strong>桥接模式</strong>、<strong>装饰模式</strong>均属于包装。这四者在很多地方都很相似，难以区分，具体区别在每个模式文章中再单独阐述。</p><p>就适配器模式来说，他在包装中的特点是，<strong>被包装后的对象，和包装前的对象接口是不同的</strong>。</p><h2 id="总结">总结</h2><p>适配器模式通常使用于，客户端和被适配类不兼容，且都无法修改的场景。</p><p>适配器模式中，通过适配器类，实现了目标类/接口，并通过组合的形式，将对于目标接口的调用，委派给被适配类，自身通常只负责接口或数据格式的转换。</p><p>客户端可以通过目标接口，使用适配器类。适配器类可以被视为被适配类在目标类上的切面。</p><p><strong>适配器模式</strong>、<strong>代理模式</strong>、<strong>桥接模式</strong>、<strong>装饰模式</strong>均属于<strong>包装</strong>，特点是<strong>包装类中通过组合持有被包装类的对象</strong>。十分相似又有区别。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Singleton</title>
    <link href="/2024/05/15/Design-Pattern-Singleton/"/>
    <url>/2024/05/15/Design-Pattern-Singleton/</url>
    
    <content type="html"><![CDATA[<p><strong>单例模式<code>(Singleton)</code></strong>是一种创建型模式。目的是，<strong>确保类只有一个实例</strong>，并提供一个<strong>访问该实例的全局节点</strong>。</p><p>会产生这样的需求，理由也十分自然：在全局范围内使用同一个对象或资源，方便统一配置与管理。典型的场景如：配置类、日志类、资源管理类（数据库连接池）等。</p><p>在<code>SpringBoot</code>常见的分层架构中，<code>Controller</code>层、<code>Service</code>层通常不需要多个实例，因其成员变量通常为对其他<code>Service</code>的引用，几乎不包含状态信息。如果有多个实例，实例间也无法体现差异。因此在<code>Spring</code>框架中，容器中的各种<code>bean</code>默认是单实例的。并通过<code>IoC</code>和<code>DI</code>，去组织不同单实例间的依赖关系。需要注意单实例不一定是单例模式，因为其并不是全局范围都能访问，而是通过<code>DI</code>组织了依赖关系。但如果是通过<code>BeanFactory.getBean()</code>来获取单实例，则和单例模式十分相似。</p><p>不同实例间的差异体现在其成员变量上。如果创建的多个实例成员变量都相同，并且实例在全局范围内有比较多使用的地方，则可以考虑使用单例模式。</p><h2 id="单例模式vs静态公共方法">单例模式VS静态公共方法</h2><p>如果为了提供一些方法和变量的全局访问权限，在<code>java</code>中可以将这些方法和变量设置为<code>public static</code>，可以得到类似的效果。静态公共方法可以在任意位置通过<strong>类名.方法名</strong>调用。类的加载机制又保证了，在不同位置调用的方法，引用的都是相同的静态成员变量，模拟了只有一个实例的效果。</p><p>但这么做也多了很多限制：静态方法中只能引用静态变量；静态变量属于类而不是实例，无法被继承，也无法实现接口；无法通过多态来进行动态调用；无法控制其生命周期；无法进行垃圾回收；无法实现延迟初始化等等。</p><p>由于单例模式比静态公共方法灵活得多，因此更多使用单例模式来达成全局访问的效果。</p><h2 id="单例模式vs全局变量">单例模式VS全局变量</h2><p>在一些面向对象语言中，如<code>C++</code>、<code>Python</code>，可以通过全局变量的方式来建立全局访问的效果。通常我们认为全局变量是需要避免的。而单例模式，很多人认为其是对全局变量的一种包装，因此也反对使用单例模式。例如<code>C++ Core Guidelines</code>中就不建议使用<ahref="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-singleton">单例模式</a>。</p><p>使用全局变量的缺点同样也是单例模式的缺点。例如全局范围内的访问和修改可能会导致全局变量的状态无法估计；需要考虑并发访问，线程安全性；使得模块之间的依赖关系变得隐匿（如两个模块共同与全局变量进行了交互），造成了模块间的耦合；使得单元测试变得更困难，无法<code>mock</code>替换；<code>C++</code>中无法保证全局变量初始化的顺序。</p><p>可以看出，这些缺点很多都与全局的写权限有关。因此单例模式如果不提供写的权限，或者不包含状态类型的变量（状态通常会在程序运行中改变），或者本身就是不可变对象，那么可以很好地规避上述缺点。此时单例模式的使用通常是合适且优雅的。</p><p>网上关于设计模式、反设计模式的讨论还有很多。程序员需要根据实际情况，来决定是否使用，而不是一昧支持或反对。</p><h2 id="单例模式的通用实现">单例模式的通用实现</h2><p>单例模式在不同语言中，根据每种语言的特性，有着不同的实现。在不同实现中，有一些共同之处。综合这些共同之处，便是一个通用实现。</p><p>为了符合单例模式<strong>确保类只有一个实例</strong>的特性，需要限制程序员在其他地方主动<code>new</code>实例的权限，把类的构造函数设置为<code>private</code>。而<strong>全局访问</strong>的特性，通常会在类内定义一个<code>public static</code>静态方法，返回一个类对象。</p><p>这个单例对象需要被某个变量引用。基于其全局唯一的特性，通常会定义为类的静态变量。并在静态方法中作为方法返回值。</p><p>基于上述描述，可以给出如下<code>java</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 私有构造方法防止外部实例化</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，静态变量<code>INSTANCE</code>通过直接赋值来进行初始化。对于静态变量，初始化会在类被加载时执行。而<strong>类的加载机制</strong>保证了线程安全性，<code>new Singleton()</code>只会被执行一次，确保全局只会存在一个实例。</p><p>由于上述过程中，类被加载时就会完成实例的初始化，初始化的时机比较早，此方法被称作“<strong>饿汉式</strong>"。</p><p>与之相对的是，在<code>getInstance()</code>被首次调用时才完成初始化，初始化时机更晚，被称作“<strong>懒汉式</strong>”。在懒汉式中。由于静态方法可能被多线程同时调用，多个线程只能有一个完成对象的创建和初始化，需要在方法中通过锁机制，来保证线程安全性。关于如何实现线程安全太过细节，为了避免掩盖单例模式的特点，在此不再赘述。</p><h2 id="总结">总结</h2><p>单例模式是一种创建型模式，旨在确保一个类只有一个实例，并提供一个全局访问点。</p><p>由于单例模式的全局性，通常会把其与全局变量比较。全局变量的缺点，可能在单例模式上也存在。通常可以通过在单例中不包含状态或提供改变状态的方法来避免这些缺点。程序员需要根据实际情况判断场景是否适合单例模式。</p><p>单例模式的通用实现的特点是，把构造函数私有化，以及提供一个公开静态函数。前者支持<strong>唯一性</strong>，后者提供<strong>全局访问性</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Term-Definaition-BeanFactory</title>
    <link href="/2024/04/23/SpringBoot-Term-Definaition-BeanFactory/"/>
    <url>/2024/04/23/SpringBoot-Term-Definaition-BeanFactory/</url>
    
    <content type="html"><![CDATA[<h2 id="beanfactory">BeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>The root interface for accessing a Spring bean container.</p></blockquote><p>今天讲到Spring中最关键的概念<code>BeanFactory</code>。从注释中可以得到，<code>beanFactory</code>就是平常说的<strong>容器</strong>，后文会不加区分使用<code>beanFactory</code>和容器。</p><blockquote><p>This is the basic client view of a bean container; further interfacessuch as ListableBeanFactory andorg.springframework.beans.factory.config.ConfigurableBeanFactory areavailable for specific purposes.</p></blockquote><p>其子接口<code>ListableBeanFactory</code>与<code>ConfigurableBeanFactory</code>，对功能进行了拓展，具体有哪些拓展等后续介绍完<code>BeanFactory</code>再说。</p><blockquote><p>This interface is implemented by objects that hold a number of beandefinitions, each uniquely identified by a String name. Depending on thebean definition, the factory will return either an independent instanceof a contained object (the Prototype design pattern), or a single sharedinstance (a superior alternative to the Singleton design pattern, inwhich the instance is a singleton in the scope of the factory). Whichtype of instance will be returned depends on the bean factoryconfiguration: the API is the same. Since Spring 2.0, further scopes areavailable depending on the concrete application context (e.g. "request"and "session" scopes in a web environment).</p></blockquote><p><code>BeanFactory</code>的最主要的功能，就是储存了一系列<code>BeanDefinition</code>，并且每个都使用了一个唯一的字符串来标识。我们可以通过这个唯一字符串，检索到<code>BeanDefinition</code>，并根据此来决定是使用已有的对象(<code>Singleton</code>)，还是新建一个对象(<code>Prototype</code>)。</p><p>容器中大部分<code>BeanDefinition</code>，都是<code>Singleton</code>类型，因此<code>BeanDefinition</code>和大部分对象也是一一对应的关系，从而字符串到大部分对象也是一一对应的关系。所以常规中，我们会认为容器完成了字符串到对象的映射。</p><blockquote><p>The point of this approach is that the BeanFactory is a centralregistry of application components, and centralizes configuration ofapplication components (no more do individual objects need to readproperties files, for example). See chapters 4 and 11 of "ExpertOne-on-One J2EE Design and Development" for a discussion of the benefitsof this approach.</p></blockquote><p>容器是一种把应用中用到的所有组件，中心化配置的一种设计理念。并引用了一本书中的内容来说明这么做的好处。在此不多赘述。</p><blockquote><p>Note that it is generally better to rely on Dependency Injection("push" configuration) to configure application objects through settersor constructors, rather than use any form of "pull" configuration like aBeanFactory lookup. Spring's Dependency Injection functionality isimplemented using this BeanFactory interface and its subinterfaces.</p></blockquote><p>在<code>spring</code>应用中，可以在对象初始化时，或在对象创建完后，通过构造函数或<code>setter</code>方法完成依赖注入，把依赖注册为成员变量。这是更推荐的“推式”注入。与之对应的是在方法内需要用到时，通过<code>BeanFactory</code>的查询方法获取对象，此为不推荐的“拉式”注入。无论是“推式”还是“拉式”，都会使用到<code>BeanFactory</code>来完成功能，因此两者的最大区别是注入的时机。广泛使用的<code>@Resource</code>或<code>@Autowired</code>就是“推式”注入。</p><blockquote><p>Normally a BeanFactory will load bean definitions stored in aconfiguration source (such as an XML document), and use theorg.springframework.beans package to configure the beans. However, animplementation could simply return Java objects it creates as necessarydirectly in Java code. There are no constraints on how the definitionscould be stored: LDAP, RDBMS, XML, properties file, etc. Implementationsare encouraged to support references amongst beans (DependencyInjection).</p></blockquote><p><code>BeanFactory</code>获取对象，先加载<code>BeanDefinition</code>，并使用<code>SpringBean</code>包来创建具体对象并返回，这不是绝对的。在某些情况<code>BeanDefinition</code>来源特殊，可以越过上述过程，直接获取对象。</p><blockquote><p>In contrast to the methods in ListableBeanFactory, all of theoperations in this interface will also check parent factories if this isa HierarchicalBeanFactory. If a bean is not found in this factoryinstance, the immediate parent factory will be asked. Beans in thisfactory instance are supposed to override beans of the same name in anyparent factory.</p></blockquote><p><code>HierarchicalBeanFactory</code>会同时检查父容器，而<code>ListableBeanFactory</code>不会。当存在多级容器时，会遵循“就近原则”，子容器的同名<code>BeanDefination</code>会覆盖父容器。</p><p>以上是<code>BeanFactory</code>的注释内容。查看<code>BeanFactory</code>中定义的方法，基本就是根据名称/类型获取对象，根据名称检查<code>BeanDefination</code>是否存在和其属性值。总的来说，容器的功能就是储存名称和<code>BeanDefination</code>，并可以通过名称获取<code>BeanDefination</code>对应的对象。</p><h2 id="listablebeanfactory">ListableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.beans.factory;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>Extension of the BeanFactory interface to be implemented by beanfactories that can enumerate all their bean instances, rather thanattempting bean lookup by name one by one as requested by clients.BeanFactory implementations that preload all their bean definitions(such as XML-based factories) may implement this interface.</p></blockquote><p><code>ListableBeanFactory</code>是<code>BeanFactory</code>的扩展。在原有基础上新增了获取枚举容器中<code>BeanDefinition</code>数量、名称的功能。</p><blockquote><p>If this is a HierarchicalBeanFactory, the return values will not takeany BeanFactory hierarchy into account, but will relate only to thebeans defined in the current factory. Use the BeanFactoryUtils helperclass to consider beans in ancestor factories too.</p></blockquote><p>与<code>BeanFactory</code>不同的是，<code>ListableBeanFactory</code>扩展的功能，不会考虑层级结构，也就是不会搜索父容器中定义的<code>BeanDefinition</code>。</p><blockquote><p>The methods in this interface will just respect bean definitions ofthis factory. They will ignore any singleton beans that have beenregistered by other means likeorg.springframework.beans.factory.config.ConfigurableBeanFactory'sregisterSingleton method, with the exception of getBeanNamesForType andgetBeansOfType which will check such manually registered singletons too.Of course, BeanFactory's getBean does allow transparent access to suchspecial beans as well. However, in typical scenarios, all beans will bedefined by external bean definitions anyway, so most applications don'tneed to worry about this differentiation.</p></blockquote><p><code>ListableBeanFactory</code>扩展的功能基本只考虑根据<code>BeanDefinition</code>创建的<code>bean</code>。通过其他方法例如<code>registerSingleton</code>注册进容器的<code>bean</code>，不予考虑。</p><p>总的来说，<code>ListableBeanFactory</code>的扩展就在于<code>Listable</code>上，使得容器增加了枚举所有<code>BeanDefinition</code>的功能。</p><h2 id="hierarchicalbeanfactory">HierarchicalBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HierarchicalBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>Sub-interface implemented by bean factories that can be part of ahierarchy.</p><p>The corresponding setParentBeanFactory method for bean factories thatallow setting the parent in a configurable fashion can be found in theConfigurableBeanFactory interface.</p></blockquote><p><code>HierarchicalBeanFactory</code>接口非常简单，在<code>BeanFactory</code>上扩展了层级功能。容器可以指定其父容器。为了区分是否搜索父容器的场景，新增了<code>containsLocalBean</code>方法。见名知意，这个方法不搜索父容器，而<code>BeanFactory</code>中声明的<code>containsBean</code>则会搜索父容器。</p><h2 id="singletonbeanregistry">SingletonBeanRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SingletonBeanRegistry</span><br></code></pre></td></tr></table></figure><blockquote><p>Interface that defines a registry for shared bean instances. Can beimplemented by org.springframework.beans.factory.BeanFactoryimplementations in order to expose their singleton management facilityin a uniform manner.</p></blockquote><p><code>SingletonBeanRegistry</code>看似和<code>BeanFactory</code>没有直接关系，但通常被<code>BeanFactory</code>的实现类同时实现，以提供把某个<code>bean</code>实例注册进容器中。</p><p>注册<code>bean</code>实例和上文提到的大部分注册<code>beanDefinition</code>的主要区别是，注册的实例默认为单实例模式，并且默认已完成初始化。已完成初始化意味着，<code>BeanFactory</code>不会对其进行生命周期控制，不会执行初始化、销毁函数的回调。</p><p><code>SingletonBeanRegistry</code>还提供了查看容器内已初始化的<code>Singleton</code>，由于不是很重要，在此不再赘述。</p><h2 id="configurablebeanfactory">ConfigurableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigurableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HierarchicalBeanFactory</span>, SingletonBeanRegistry<br></code></pre></td></tr></table></figure><blockquote><p>Configuration interface to be implemented by most bean factories.Provides facilities to configure a bean factory, in addition to the beanfactory client methods in the BeanFactory interface.</p><p>This bean factory interface is not meant to be used in normalapplication code: Stick to BeanFactory ororg.springframework.beans.factory.ListableBeanFactory for typical needs.This extended interface is just meant to allow for framework-internalplug'n'play and for special access to bean factory configurationmethods.</p></blockquote><p><code>ConfigurableBeanFactory</code>是<code>HierarchicalBeanFactory</code>和<code>SingletonBeanRegistry</code>的扩展，额外拓展了对<code>BeanFactory</code>进行配置的功能。</p><p>那么这个配置指什么，查看<code>ConfigurableBeanFactory</code>新增的方法声明，<code>parentBeanFactory</code>、<code>beanClassLoader</code>、<code>tempClassLoader</code>、<code>cacheBeanMetadata</code>...</p><p>这里出现了很多新的细节与概念，暂且搁置。而且通常用户层面更多使用<code>BeanFactory</code>和<code>ListableBeanFactory</code>访问容器，很少会有对容器进行配置的需求，因此此部分内容只是简单描述。</p><h2 id="autowirecapablebeanfactory">AutowireCapableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AutowireCapableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span><br></code></pre></td></tr></table></figure><blockquote><p>Extension of the BeanFactory interface to be implemented by beanfactories that are capable of autowiring, provided that they want toexpose this functionality for existing bean instances.</p><p>This subinterface of BeanFactory is not meant to be used in normalapplication code: stick to BeanFactory ororg.springframework.beans.factory.ListableBeanFactory for typical usecases.</p></blockquote><p><code>AutowireCapableBeanFactory</code>关注自动装配相关的功能。通常是对那些在容器外部创建<code>bean</code>实例执行自动装配功能，内部的<code>bean</code>可以通过<code>@AutoWired</code>和<code>@Resource</code>来配置需要使用自动装配功能的地方。</p><p>虽然名称叫<code>AutowireCapableBeanFactory</code>，接口还提供了自动装配以外的功能，例如执行容器的回调<code>setBeanName</code>、<code>setBeanFactory</code>，或者执行<code>BeanPostProcessors</code>。</p><h2id="configurablelistablebeanfactory">ConfigurableListableBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigurableListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ListableBeanFactory</span>, AutowireCapableBeanFactory, ConfigurableBeanFactory<br></code></pre></td></tr></table></figure><blockquote><p>Configuration interface to be implemented by most listable beanfactories. In addition to ConfigurableBeanFactory, it providesfacilities to analyze and modify bean definitions, and topre-instantiate singletons.</p></blockquote><p>从继承关系来看，<code>ConfigurableListableBeanFactory</code>就是上文提到三个的合体版。此外，提供了分析修改<code>BeanDefinition</code>和预实例化单实例的功能。由于此接口提供的方法相对简单，不多赘述。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>TermDefinition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Term-Definition</title>
    <link href="/2024/04/22/SpringBoot-Term-Definition/"/>
    <url>/2024/04/22/SpringBoot-Term-Definition/</url>
    
    <content type="html"><![CDATA[<p>近期，在<code>Github</code>上读到了关于源码学习的<ahref="https://github.com/doocs/source-code-hunter">仓库</a>，并跟着学习了<code>Spring</code>全家桶源码。这对设计模式的学习和程序设计是十分有帮助的，因为<code>Spring</code>源码中存在大量设计模式的优秀实践。但设计模式的广泛运用也导致<code>Spring</code>类之间关系复杂，源码阅读费力。</p><p>在学习过程中，发现自己对<code>Spring</code>中许多概念是模糊的。这可能是因为学习<code>Spring</code>时，都是从使用侧考虑，忽略了非常多底层细节。对于概念的认知，更多来自于口口相传或望文生义的猜测。例如能否严谨地阐述容器，<code>BeanFactory</code>和<code>ApplicationContext</code>三者间的关系。很多文章，包括笔者自己，都在不加区分地使用这三个概念。这种模糊的概念认知，对于日常使用<code>Spring</code>没有任何影响，但在学习源码时，就会产生大量歧义。</p><p>比较常见的源码学习方式，例如跟踪<code>SpringApplication.run</code>方法，查看一层层的调用情况，容易让读者迷失在概念的海洋当中。这样的学习模式是在用未知解释未知，很大一部分还是要靠猜，并且很难靠自己验证猜想是否准确。由于笔者对<code>Spring</code>整体并没有很深刻认知，本篇笔记更多是对源码的翻译和转述，着重描述<code>Spring</code>的概念。这些概念的解释全部来自于<code>Spring</code>源码和注释。</p><p>源码基于<code>SpringBoot3.1.7</code>版本。此版本没特别之处，只是上一个做的项目恰好使用了这个版本。通常在核心层面源码也不会发生大改动，任意一个常用的版本应该都能得到一致的概念描述。</p><h2 id="接口抽象类具体类">接口、抽象类、具体类</h2><p>学习<code>Spring</code>源码，最大的体验就是复杂的类关系。使用了大量的抽象，定义了许多接口、抽象类。</p><p>在面向对象编程的学习中，接口实现通常用来表示“能干什么”，而类继承通常表示“是什么”。但在<code>Spring</code>源码中，很多地方使用接口表示了“是什么”的概念。当然也可以玩文字游戏，接口可以表示“作为什么应该具有的功能”。例如<code>Resource</code>接口表示了，作为资源应该具有的功能。但笔者认为直接使用“是什么”去解释接口更符合人们常规理解。实现了<code>Resource</code>接口表示某个具体类是一种<code>Resource</code>。</p><p>会产生这样的情况，很大原因是<code>java</code>无法进行多继承。而<code>spring</code>由于高度的抽象，功能划分地十分细致（<strong>接口隔离原则</strong>）。当一个具体类具有多个功能，多实现避免了无法多继承的限制。</p><p>但针对某个接口具体实现类中，通常包含大量相似的代码。虽然<code>java 8</code>后，可以通过提供默认方法，将相似代码抽取到接口中。但许多接口方法都依赖于具体的成员变量，而接口中只能包含常量，不能包含非常量的成员变量。因此这部分具体实现类中重复的代码，通常会被抽取到一个抽象类中，将这个抽象类实现接口，并在抽象类中提供许多接口方法的默认实现。</p><p>这样的模式在<code>Spring</code>中极为常见，识别这种模式能更便于理解类之间的关系。</p><h2 id="resource">Resource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.core.io<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamSource</span><br></code></pre></td></tr></table></figure><blockquote><p>Interface for a resource descriptor that abstracts from the actualtype of underlying resource, such as a file or class path resource.</p><p>An InputStream can be opened for every resource if it exists inphysical form, but a URL or File handle can just be returned for certainresources. The actual behavior is implementation-specific.</p></blockquote><p><code>Resource</code>接口用来表示可以被读取内容的资源。<strong>通俗地理解就是某个文件</strong>，但这个文件可以使用多种方式来定位。例如可以使用文件系统路径(<code>FileSystemResource</code>)，也可以使用类路径(<code>ClassPathResource</code>)，或者使用<code>URL/URI</code>来表示位于网络上的资源(<code>UrlResource</code>)。不同的定位方式对应了不同的实现类。早期使用<code>xml</code>文件启动<code>Spring</code>，就是在启动过程中将<code>xml</code>文件的路径，包装成了一个<code>FileSystemResource</code>，用于读取其中定义的配置信息。</p><p>一些<code>Resource</code>接口的实现类也在资源包含的内容进行了声明。例如<code>BeanDefinitionResource</code>、<code>MultipartFileResource</code>。</p><p><code>Resource</code>接口有一个默认实现抽象类<code>AbstractResource</code>。</p><p><code>Resource</code>接口继承于<code>InputStreamSource</code>接口。<code>InputStreamSource</code>接口只声明了一个方法<code>getInputStream</code>，用于从资源中获取流对象，用于读取资源内容。</p><h2 id="beandefinition">BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config.<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AttributeAccessor</span>,BeanMetadataElement<br></code></pre></td></tr></table></figure><blockquote><p>A BeanDefinition describes a bean instance, which has propertyvalues, constructor argument values, and further information supplied byconcrete implementations.</p><p>This is just a minimal interface: The main intention is to allow aBeanFactoryPostProcessor to introspect and modify property values andother bean metadata.</p></blockquote><p><code>BeanDefinition</code>接口定义了<code>Spring</code>容器中所管理的<code>Bean</code>实例的配置元数据，包含了各种属性值、构造器的参数值。<code>BeanDefinition</code>实例和容器中的<code>Bean</code>实例一一对应。</p><p>除此外，还包括<code>parentName</code>、<code>beanClassName</code>、<code>scope</code>、<code>lazyInit</code>、<code>dependsOn</code><code>autowireCandidate</code>、<code>primary</code>、<code>factoryBeanName</code>、<code>factoryMethodName</code>、<code>initMethodName</code>、<code>destroyMethodName</code>、<code>role</code>、<code>description</code>、<code>resolvableType</code>、<code>singleton</code>、<code>prototype</code>、<code>abstract</code>、<code>resourceDescription</code>、<code>originatingBeanDefinition</code>等元数据的访问/修改。关于这些元数据的概念，建议参考源码，在此不赘述。</p><p><code>BeanDefinition</code>接口也有默认实现抽象类<code>AbstractBeanDefinition</code>。</p><p><code>BeanDefinition</code>继承了<code>AttributeAccessor</code>接口。<code>AttributeAccessor</code>接口声明了查询、访问、修改对象数据的方法。对于<code>BeanDefinition</code>来说，这里的数据指的就是元数据。使得对象的元数据可以在运行时动态地添加、获取和删除，从而提高了对象的灵活性和可扩展性。</p><p><code>BeanDefinition</code>继承了<code>BeanMetadataElement</code>接口。<code>BeanMetadataElement</code>接口声明了获取<code>BeanDefinition</code>来源的信息，例如来自xml标签、注解、配置类等可能包含<code>BeanDefinition</code>信息的对象。</p><p>综上，<code>BeanDefinition</code>包含了<code>bean</code>的元数据信息，并包含了查询/修改元数据，获取元数据来源的功能。此接口主要用于<code>BeanFactoryPostProcessor</code>中，对<code>BeanDefinition</code>进行动态调整。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>TermDefinition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Prototype</title>
    <link href="/2024/03/22/Design-Pattern-Prototype/"/>
    <url>/2024/03/22/Design-Pattern-Prototype/</url>
    
    <content type="html"><![CDATA[<p><strong>原型模式<code>(Prototype)</code></strong>是创建型模式中最简单、最不重要的一个设计模式。说不重要不是因为用不到，而是在实践过程中通常使用了其他更简便的方法进行了替代。前两篇设计模式在撰写时文本量超过了预期，本篇尽量言简意赅。</p><h2 id="场景">场景</h2><p>假设现在有个对象，需要根据这个对象中的属性，去创建新的同类对象。这么做的目的可能是重新创建对象过程复杂，直接从已有对象中复制相当于节省了许多步骤，可以<strong>快速获取大量同类对象</strong>。也可能是需要<strong>保留一份对象当前的状态</strong>。这样的需求十分常见。</p><p>在没有学过设计模式或一些现代开发技巧前，想当然的解决办法是，先通过<code>new</code>关键字新建一个对象，然后反复调用其<code>set</code>方法，设置值来自调用原型中的<code>get</code>方法。一些语言，例如C++，也可以通过拷贝构造函数，来完成对象的克隆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassA</span> <span class="hljs-variable">newObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>newObject.setA(oldObject.getA());<br>newObject.setB(oldObject.getB());<br>...<br></code></pre></td></tr></table></figure><p>这样做有时行得通，但需要满足一些前提条件。例如这需要被克隆的类需要提供所有字段的<code>get</code>和<code>set</code>的公共方法。例如客户端需要明确被克隆类的具体类型，才能使用<code>new</code>关键字创建具体类对象。客户端也需要知道关于被克隆类的细节，有哪些字段，增加了代码的耦合度。</p><p>原型模式提供了一个方案，<strong>基于一个已存在的对象克隆生成新的对象，而无需知道具体实现细节</strong>。</p><h2 id="原型模式">原型模式</h2><p>在不知道被克隆对象类型的情况下，需要根据运行时具体类型产生不同运行结果，通常会利用<strong>多态</strong>特性，并在具体类中定义克隆方法，在克隆方法中新建自身类的对象，并完成字段从原型到新对象的复制。由于方法定义在类中，因此也不涉及字段的访问权限问题，也做到了克隆过程和客户端分离的作用。</p><p>在<code>Java</code>中，所有类都继承于<code>Object</code>类。在<code>Object</code>类中，声明了一个克隆方法，方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p><code>protected</code>意味着所有继承的子类均可调用这个方法，<code>native</code>关键字则声明方法是由本地语言实现的，而不是由<code>Java</code>语言实现的。这个方法在<code>JDK</code>中的注释如下：</p><blockquote><p>The method clone for class Object performs a specific cloningoperation. First, if the class of this object does not implement theinterface Cloneable, then a CloneNotSupportedException is thrown. Notethat all arrays are considered to implement the interface Cloneable andthat the return type of the clone method of an array type T[] is T[]where T is any reference or primitive type. Otherwise, this methodcreates a new instance of the class of this object and initializes allits fields with exactly the contents of the corresponding fields of thisobject, as if by assignment; the contents of the fields are notthemselves cloned. Thus, this method performs a "shallow copy" of thisobject, not a "deep copy" operation. The class Object does not itselfimplement the interface Cloneable, so calling the clone method on anobject whose class is Object will result in throwing an exception at runtime.</p></blockquote><p>在每个对象上调用这个方法时，会先检查具体类是否实现了<code>Cloneable</code>接口，然后新建对象，并完成了所有字段的<strong>浅拷贝</strong>。这个<code>Object</code>类的<code>clone</code>方法，相当于帮我们完成了<code>new</code>对象和字段复制。</p><p>如果想通过这种方式完成对象克隆，需要在具体类中实现<code>Cloneable</code>接口。并重写<code>clone</code>方法，将访问修饰符改为<code>public</code>。方法体内可以简单调用<code>super.clone()</code>，也就是<code>Object</code>类的<code>clone</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">public</span> ClassA <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (ClassA)<span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 调用原型对象的clone方法</span><br><span class="hljs-type">ClassA</span> <span class="hljs-variable">newObject</span> <span class="hljs-operator">=</span> oldObject.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>上例代码中，对返回对象做了<strong>类型转换</strong>。原方法返回<code>Object</code>类型，重写时可以返回其子类类型。这是因为在此具体类中，<code>clone</code>方法返回对象的类型是确定的，可以在此直接完成类型转换，而不是由客户端执行类型转换。</p><p>在<code>java</code>之外的语言中，由于无法调用<code>Object</code>类的<code>clone</code>方法，也没有<code>Cloneable</code>接口，可以在方法体中通过调用空参或有参构造函数，再进行字段设置并返回来实现。以下是<code>C++</code>中的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ProductA</span>(<span class="hljs-type">const</span> ProductA&amp; other)&#123;<br>    <span class="hljs-comment">// 拷贝构造函数实现</span><br>    ...<br>&#125;<br><br><span class="hljs-function">ProductA* <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProductA</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>总之，最简单的原型模式就是在类中定义一个拷贝方法，在拷贝方法中完成创建自身类对象，属性复制，并返回对象的操作。</p><h2 id="抽象产品拓展">抽象产品拓展</h2><p>在上一章中，只涉及了一种产品类的复制。产品类的拓展模式在前些篇中已出现多次，被细分为抽象产品和具体产品。如果在需要客户端中使用抽象产品作为变量类型，调用克隆方法，则这意味着克隆方法需要声明在接口中。在<code>java</code>中，可以通过继承<code>Cloneable</code>接口，并声明返回接口类型的克隆方法。并在子类中实现这个克隆方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口实现</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    InterfaceA <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">private</span> String field;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductA</span><span class="hljs-params">(String field)</span> &#123;<br>        <span class="hljs-built_in">this</span>.field = field;<br>    &#125;<br>    <span class="hljs-comment">// 实现克隆方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceA <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (ProductA) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建接口类型对象，并调用clone方法</span><br>    <span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>(<span class="hljs-string">&quot;Draco&quot;</span>);<br>    <span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> objectA.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象产品也可以定义为抽象类。如果所有子类都是简单调用<code>Object</code>中的<code>clone</code>方法，则可以在抽象类中实现<code>Cloneable</code>接口，并提供方法默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类实现</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProduct</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">public</span> AbstractProduct <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (AbstractProduct) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProduct</span> &#123;<br>    <span class="hljs-keyword">private</span> String field;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductA</span><span class="hljs-params">(String field)</span> &#123;<br>        <span class="hljs-built_in">this</span>.field = field;<br>    &#125;<br>    <span class="hljs-comment">// 无需实现克隆方法，使用抽象父类中的默认方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建抽象类对象，并调用clone方法</span><br>    <span class="hljs-type">AbstractProduct</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>(<span class="hljs-string">&quot;Draco&quot;</span>);<br>    <span class="hljs-type">AbstractProduct</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> objectA.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果语言未提供类似<code>java</code>的<code>Cloneable</code>接口，则可以自定义一个接口，在接口中声明一个克隆方法，在抽象产品接口类中继承此接口，并在子类中实现克隆方法的具体实现。</p><h2 id="现代方法">现代方法</h2><p>由于将属性从一个对象复制到另一个对象，这个功能是如此的使用频繁，以至于许多工具类都提供类似功能。因此上文提到的原型模式，在实际使用中通常都被工具类的使用给替代了，使用频率并不高。</p><p>就<code>java</code>来说，最常用的就是<code>Apache BeanUtils</code>和<code>Spring BeanUtils</code>。通常认为后者在可用性和性能上更好，使用更多。这两者都是通过<strong>反射</strong>特性来完成对象间属性拷贝。<code>Spring BeanUtils</code>提供了静态方法，可以传入两个对象，即可把其中一个对象的属性复制到另一个当中。甚至传入的两个对象在类型上不需要有相同或继承的关系，只要有同名同类型的属性即可拷贝。<code>hutool BeanUtil</code>还提供了静态方法，可以传入返回对象的类型，直接获取拷贝后的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>(<span class="hljs-string">&quot;Draco&quot;</span>);<br><span class="hljs-comment">// 新建一个空对象</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>();<br><span class="hljs-comment">// Spring BeanUtils 完成属性复制</span><br>BeanUtils.copyProperties(objectA, objectB)<br>    <br><span class="hljs-comment">// hutool BeanUtil 完成对象创建和属性复制</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectC</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(objectA, ProductA.class)<br></code></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2><p>在不同语言中，数据类型大致可以分为<strong>基础数据类型</strong>和<strong>引用数据类型</strong>。成员变量中，基础数据类型会将实际数值储存在对象中，而引用数据类型存储的是对象的地址，通过这个地址可以访问对象的属性和方法。</p><p>在复制对象时，对于基础数据类型，是内存区域的复制，实际数值会在两个对象中各保存一份；而对于引用数据类型，如果只是引用的复制，复制完两个引用仍指向了同一个对象。这种对于复制模式，称为<strong>浅拷贝</strong>。与之对应的<strong>深拷贝</strong>，则是将每个引用数据类型的对象，在内存中新<code>new</code>了一份，并将返回的引用赋值给成员变量。</p><p>浅拷贝可能存在的问题是，复制完后，对其中一个对象进行了改动，另一个对象的内容也会随之改动，<strong>引用数据类型的成员变量不满足拷贝后的对象与原对象相互独立的特性</strong>。但由于深拷贝需要创建新的对象，会更耗费内存和时间。实际情况下，如果对象在复制完后，不会对其中引用数据类型进行变动，使用浅拷贝提升性能是可取的。</p><p>另外，对于一些不可变类型来说，由于每次变动都会新建一个对象，就算是引用数据类型，使用浅拷贝也是安全的。最典型的便是<code>String</code>、包装数据类型，如果对象中只包含基础数据类型、<code>String</code>和包装数据类型，那么使用浅拷贝也是安全的。</p><h2 id="总结">总结</h2><p>最简单的原型模式，就是在产品类中定义一个拷贝方法，在方法体中完成新建对象和属性的复制。</p><p>如果产品类需要拓展，细分为抽象产品和具体产品，则需要在抽象产品中定义拷贝方法，返回类型设定为抽象产品类，并在具体产品类中实现拷贝方法。</p><p>现代开发习惯中，通常使用工具类来完成对象的拷贝，实现原型模式。</p><p>浅拷贝性能好，但可能存在拷贝后的对象与原型不独立的问题。需要根据实际情况来选择。如果成员变量都是不可变对象，则可以安全地使用浅拷贝。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Builder</title>
    <link href="/2024/03/13/Design-Pattern-Builder/"/>
    <url>/2024/03/13/Design-Pattern-Builder/</url>
    
    <content type="html"><![CDATA[<p>本篇简单描述生成器模式<code>(Builder)</code>的结构和特征，并着重讨论<strong>为什么要使用生成器模式</strong>的思考。</p><h3 id="场景">场景</h3><p><strong>生成器模式</strong>是一种<strong>创建型模式</strong>，目的是创建一个对象。通常创建对象，可以通过<code>new</code>关键字调用构造函数，并在构造函数中传入需要的参数。这在对象结构简单时十分容易。但当类的成员变量变得众多类型复杂，且某些参数可以不是必输的时候，会变得复杂。在一些语言，例如<code>Python</code>中，可以通过提供方法的<strong>默认参数</strong>，避开这个问题，来满足不同场景下的构造函数调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">&quot;default_name&quot;</span>, age=<span class="hljs-number">0</span></span>):<br>        self.name = name<br>        self.age = age<br><br>obj1 = MyClass()<br>obj2 = MyClass(<span class="hljs-string">&quot;Draco&quot;</span>)<br>obj3 = MyClass(age=<span class="hljs-number">35</span>)<br>obj4 = MyClass(<span class="hljs-string">&quot;Draco&quot;</span>, <span class="hljs-number">35</span>)<br></code></pre></td></tr></table></figure><p><code>Java</code>不支持方法默认参数，但可以通过<strong>函数重载</strong>，定义多个不同参数数量，种类组合的构造函数，来适应这种参数非必输时，使用构造函数来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">MyClass() &#123; ... &#125;<br>MyClass(String name) &#123; ... &#125;<br>MyClass(Integer age) &#123; ... &#125;<br>MyClass(String name, Integer age) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>但这会出现一些问题。当对象有<code>n</code>个成员变量需要初始化，那么需要<span class="math inline">\(2^n\)</span>个构造函数。这种指数增长的构造函数显然是不合理的。并且当相邻两个参数为相同类型时，去掉其中任意一个参数会导致方法签名完全一致，编译器无法区分两个方法的区别，会显示编译错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">MyClass() &#123; ... &#125;<br>MyClass(String name) &#123; ... &#125;<br>MyClass(String age) &#123; ... &#125; <span class="hljs-comment">// 编译错误，重复定义</span><br>MyClass(String name, String age) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>又或者不提供所有的构造函数，只提供一个全参的构造函数，如果某个参数无需初始化时，则在构造时将对应参数位置传入<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">MyClass(String name, String address, Integer age) &#123; ... &#125;<br><span class="hljs-comment">// 不需要初始化的参数对应位置传入null</span><br><span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&quot;Draco&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">35</span>);<br></code></pre></td></tr></table></figure><p>当对象的成员变量较多时，会产生一个参数列表非常长的构造函数调用。程序员需要记住每个位置的参数的含义，并在构造时确保不出错。当然现代<code>IDE</code>都提供了参数提示的功能，在输入参数时敲入逗号，或者鼠标悬停至参数位置时，会提供参数列表变量名和类型的提示。但超长的构造函数总归是不方便也不优雅的。</p><p>至于为什么不通过新建对象后，重复调用<code>set</code>方法，这部分原因放到后文再来谈。</p><p>为了解决上述问题，引入了<strong>生成器模式</strong>。</p><h3 id="最简单的生成器模式">最简单的生成器模式</h3><p>类似于<strong>工厂模式</strong>，<strong>生成器模式</strong>也使用了一个独立的类，将对象的创建过程从产品类中抽取出来。<strong>生成器模式提供了逐步构建复杂对象的方法</strong>。将构造函数的一次性调用，拆解成了对生成器设置方法的多次调用。</p><p>这个生成器类可以定义在独立的<code>.java</code>文件中。也可以定义在产品类中，通常是<code>public static class</code>的形式。生成器类通常拥有和原产品类相同的，或其中一部分成员变量，用于作为调用产品类构造函数的参数。在生成器类中，提供了设置成员变量的方法，通常这个方法的返回值类型会被设置为生成器类本身。这样生成器类对象，可以链式调用设置生成器中的成员变量，如此可以<strong>逐步构建复杂对象</strong>，而不是直接调用构造函数本身。最后生成器类还提供了生成方法，调用产品类构造函数，返回产品类对象。在生成方法中，还可以包含一些校验逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用lombok注解生成全参构造函数</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br>    ...<br>    <span class="hljs-comment">// 通过静态内部类形式定义生成器类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassBuilder</span> &#123;<br>        <span class="hljs-comment">// 具有产品类全部或部分成员变量</span><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> Integer age;<br>        <span class="hljs-keyword">private</span> String address;<br>        <span class="hljs-comment">// 提供set方法，设置成员变量</span><br>        <span class="hljs-keyword">public</span> MyClassBuilder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 提供生成方法，返回产品对象</span><br>        <span class="hljs-keyword">public</span> MyClass <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span>(StringUtil.isEmpty(name)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;姓名不得为空&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 调用产品类构造函数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(name, age, address);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyClassBuilder</span> <span class="hljs-variable">myClassBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassBuilder</span>();<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> myClassBuilder.setName(<span class="hljs-string">&quot;DracoYu&quot;</span>)<br>                .setAge(<span class="hljs-number">35</span>)<br>                .setAddress(<span class="hljs-string">&quot;Hangzhou&quot;</span>)<br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure><p>以上便是生成器模式的最简化的结构。究其核心部分，是和产品类相同的<strong>成员变量</strong>，提供了设置成员变量的<strong>设置方法</strong>，以及创建对象的<strong>生成方法</strong>。这样的结构在第三方库中可以经常看到，但这和大部分教材中描述的生成器模式还是有些区别。接下来描述教材中的生成器模式，并描述相对于最简单的生成器模式，多了些什么东西。</p><h3 id="复杂些的生成器模式">复杂些的生成器模式</h3><p>在上一节中，描述了最简单的生成器结构，创建了一种产品类。对于单个产品类来说，这样子的结构是足够且合适的。</p><p>但设计模式考虑代码<strong>拓展性</strong>，如果多个产品类具有类似的成员变量和构建过程，则这些产品类的构建过程可以被抽象为生成器接口/抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Builder</span> &#123;<br>    Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>;<br>    Builder <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span>;<br>    Builder <span class="hljs-title function_">setSalary</span><span class="hljs-params">(Double salary)</span>;<br>    Builder <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span>;<br>    Person <span class="hljs-title function_">build</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当多个产品类实现了共同的接口或继承于共同的父类，那么在生成器中可以提供<code>build</code>生成方法，并返回接口/父类类型。如果没有共同的接口或父类，则<code>build</code>方法需要在每个具体<code>builder</code>中单独定义。</p><p>定义完生成器接口后，需要针对每一个产品类，定义对应的具体生成器类，这点和<code>工厂方法</code>模式很像。区别是工厂方法通常只声明了创建抽象产品的方法，而在生成器接口中通常还声明了多个产品共同构建过程的设置方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaffBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-meta">@override</span><br>    builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        ...<br>    &#125;<br>    ...<br>    <span class="hljs-meta">@override</span><br>    Person <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回具体产品类对象，其中Staff类实现了Person接口</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Staff</span>(name, age, salary, address);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Staff</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Builder</span> <span class="hljs-variable">staffBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaffBuilder</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">staff</span> <span class="hljs-operator">=</span> staffBuilder.setName(<span class="hljs-string">&quot;DracoYu&quot;</span>)<br>                .setAge(<span class="hljs-number">35</span>)<br>                .setSalary(<span class="hljs-number">0</span>)<br>                .setAddress(<span class="hljs-string">&quot;Hangzhou&quot;</span>)<br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时，客户端通过实例化具体的生成器类，并调用其中由生成器接口声明的设置方法和生成方法，获取产品类对象。</p><p>但此刻，客户端类仍体现出对生成器接口过度的依赖：客户端需要了解生成器接口声明的设置方法。如果多处对生成器类的设置方法调用，具有相似的结构，则可以将这些对于生成器设置方法的调用，抽取到专门的类当中，这个类通常称为<code>主管类(director)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>    <span class="hljs-comment">// 可以使用成员变量来管理生成器对象</span><br>    <span class="hljs-keyword">private</span> Builder builder;<br><span class="hljs-comment">// 通过构造函数注入生成器对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.builder = builder;<br>    &#125;<br><span class="hljs-comment">// 由于上述示例代码每次调用设置方法都不相同，此处没有遵循上面的例子</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>    &#125;<br>    <span class="hljs-comment">// 另一套设置方法的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">anotherConstruct</span><span class="hljs-params">()</span> &#123;<br>        builder.buildPartA();<br>        builder.buildPartC();<br>        builder.buildPartD();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Builder</span> <span class="hljs-variable">builderA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderA</span>();<br>    <span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(BuilderA);<br>    director.construct();<br>    <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> builderA.build();<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，整个生成器模式的结构应该和大部分设计模式教材中一致，总结一下其中包含的部分。</p><ul><li>产品：需要创建的对象，此处不分区抽象/具体产品。</li><li>生成器接口/抽象生成器：抽象了多种产品构建过程中的相同部分，声明为设置方法。设置方法通常返回生成器接口本身。</li><li>具体生成器：一个具体生成器对应一个具体产品，实现了生成器接口中声明的设置方法。并提供生成方法创建具体的产品对象。</li><li>主管类：通过生成器接口，调用了生成器的具体设置方法。</li></ul><h3 id="生成器模式的各种变体">生成器模式的各种变体</h3><p>由于生成器模式有不同的展现方式，在网上查资料时，虽然各种文章都在描述生成器模式，但感觉每篇文章讲的都不是同一个东西。这可能与原版生成器模式（四人帮提出的23种设计模式）过于复杂，在实践过程中产生了各种简化版本和变体有关。也可能是因为<code>builder</code>这个概念被滥用，而导致发生了众多歧义。笔者结合自己看过的文章，以及查阅<code>JDK</code>和各种第三方库中的生成器源代码，来对不同实现做个列举。</p><ul><li>简单生成器：大部分情况下，产品类不需要拓展，因此也不需要生成器接口，主管类也可以省略。此时只新增了一个生成器类，这个类可以通过静态内部类形式定义在产品类本身代码中。<strong>简单生成器是实践中最常见的形式</strong>。</li><li>产品类：多个具体产品类可以实现相同接口，也可以不实现。只要有相似的构建过程，完全不相同的产品类也可以使用相同的生成器接口。这是因为生成器接口只定义了构建过程，而具体实现由具体生成器类实现。</li><li>生成器接口/抽象生成器：如果生成的产品实现了同一接口，可以像<code>工厂方法</code>那样定义生成方法返回产品接口类型。如果没有，则可以让具体生成器定义生成方法的返回类型。此时主管类中也无法通过生成器接口调用生成方法，转由客户端来调用。</li><li>具体生成器：具体生成器可以拥有和产品类相同的成员变量，也可以用产品作为成员变量。如果以产品作为成员变量，需要在构造时或提供初始化方法新建产品对象，并赋值给成员变量。调用生成方法时将成员变量返回即可。</li><li>主管类：大部分情况下可以省略，对设置方法的调用通常转由客户端来完成。一方面是因为大部分设置方法的调用是定制的，无法确定每个产品设置方法的调用顺序，次数，以及参数，难以抽取公共方法。另一方面客户端类对生成器接口的依赖是可以被接受的。</li></ul><h3 id="为什么使用生成器模式">为什么使用生成器模式</h3><p>笔者在学习完生成器模式后，很长一段时间无法体会到其实用性。浏览网上众多资料，给出的原因大多归于这么几类：</p><ol type="1"><li>避免过于复杂的构造函数调用，提供了逐步构建复杂对象的方法</li><li>链式调用</li></ol><p>对于原因1，另一个想当然的解决方法就是调用空参构造函数，并在新建完对象后，反复调用<code>java bean</code>规范的<code>set</code>方法，便可以达成逐步构建复杂对象的目的。对于原因2，可以手动将<code>set</code>方法设置为返回对象本身（这会破坏<code>java bean</code>规范），便可实现链式调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-comment">// set方法返回对象本身</span><br>    <span class="hljs-keyword">public</span> MyClass <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-comment">// 满足逐步构建、链式调用</span><br>        myObject.setName(<span class="hljs-string">&quot;Draco&quot;</span>)<br>                .setAge(<span class="hljs-number">35</span>)<br>                .setAddress(<span class="hljs-string">&quot;Hangzhou&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>如此来看生成器模式仿佛是多余的，所有的特性都可以通过其他更简便的形式来实现。</p><p>会产生这样的想法，是因为上述例子中，将产品的设置方法、生成方法都做了简化。上述生成器中的设置方法，除了返回生成器本身，和<code>java bean</code>的<code>set</code>方法无异。而实际情况中，<strong>设置方法可能复杂包含逻辑</strong>的。例如设置方法会对输入进行校验，可以联动调整多个属性，或者向一个<code>Collection</code>中反复添加元素。这些功能不是简单的<code>setter</code>能实现的。如果在产品类中添加太多创建对象的逻辑规则，则又违反了表现和构建相分离的原则（单一职责原则）。</p><p>另一个十分重要的原因是，在<code>JDK</code>和许多第三方库中使用了<strong>不可变对象</strong>。不可变对象<code>(immutable objects)</code>是指一旦创建后，其状态就不能被修改的对象。这意味着对象的所有成员变量都是不可变的，它们的值在对象的整个生命周期内保持不变。</p><p>不可变对象有许多优秀特性，例如线程安全，无副作用等。不过这不是本篇讨论的重点。要创建一个不可变对象，最简单的是将所有成员变量声明为<code>private</code>和<code>final</code>，并且不提供修改成员变量的公共方法<code>(setter)</code>。由于成员变量被声明为<code>final</code>，则必须要在构造函数中进行初始化，否则会报编译错误。<strong>不可变对象无法先新建对象，再调用设置方法的形式去为对象赋值</strong>。</p><p>从这个视角看，生成器替不可变对象<strong>暂存了成员变量</strong>，并提供了基于成员变量的<strong>一些设置方法、校验规则</strong>。如果生成器的目的是创建不可变对象，则无法使用产品类作为成员变量的变体。</p><p>一个体现了这个原因，最常用的生成器便是<code>StringBuilder</code>。在<code>java</code>中，<code>String</code>类为不可变类，所有的<code>String</code>对象在实例后就不会再变化，所有涉及字符串操作，都是通过创建新<code>String</code>对象来实现。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;2&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果暂不考虑常量池，这行代码一共存在了三个<code>String</code>对象，分别为<code>"1"</code>，<code>"2"</code>，<code>"12"</code>。如果每一次字符串操作都会新实例化一个<code>String</code>，多次的字符串操作所带来的申请、初始化内存操作是性能低下的。<code>String</code>本身是个字节数组，<code>StringBuilder</code>通过一个字节数组成员变量，并提供了对字节数组增删改的操作，使得进行字符串操作时，无需每次操作都生成一个<code>String</code>对象。最后，调用<code>toString()</code>方法，来将生成器中的数据用来构造<code>String</code>对象。</p><p>此外，生成器模式还体现了一种，维护对象<strong>原子性、一致性、有效性</strong>的作用。如果采用新建对象再设置的方式，则对象可能处于无效状态。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid, not good</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid, not good</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure><p>创建了一个长方形对象。对于一个长方形来说，长和宽都是必须的，不存在没有长或者没有宽的长方形。新建对象后再设置的过程中，不可避免对象会处于这种无效的状态。为了避免这种无效的状态，必须要在构造函数中提供所有必须的参数。</p><p>而在生成器的生成方法中，可以通过参数校验，来限制这种无效对象的产生，保证产生的不可变对象都是有效的。</p><h3 id="总结">总结</h3><p><strong>生成器模式</strong>是一种<strong>创建型设计模式</strong>，用于将复杂对象的构建过程与其表示分离，以便可以按步骤构建对象，同时隐藏其构建细节。</p><p>最常见、最简单的生成器模式只包含一个产品类，一个生成器类，并且通常将生成器类以静态内部类定义在产品类中。</p><p>生成器类通过提供设置方法和生成方法，提供了逐步构建复杂对象的方法。</p><p>生成器模式可以通过新增抽象产品、抽象生成器、主管类来进行拓展。</p><p>笔者认为生成器模式最重要的目的是保证对象的<strong>原子性、一致性、有效性</strong>。通常和<strong>不可变对象</strong>一起使用。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Factory-Pattern</title>
    <link href="/2023/11/03/Design-Pattern-Factory-Pattern/"/>
    <url>/2023/11/03/Design-Pattern-Factory-Pattern/</url>
    
    <content type="html"><![CDATA[<p>接下来就是介绍具体的比较经典的设计模式。</p><p>按照常规的分类方式，设计模式分为<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。创建型模式关注对象的<strong>创建</strong>，结构型模式关注类/对象之间的<strong>关系</strong>，行为型模式关注对象之间的<strong>交互</strong>。</p><p>实际上，结构型模式和行为模式的边界很模糊。不同对象/类之间的关系限制了之间的交互模式，交互模式又依赖于对象之间的关系。总之，结构型模式关注系统的<strong>静态结构</strong>，用于构建对象和类之间的关系，而行为型模式关注系统的<strong>动态行为</strong>，用于管理对象之间的交互以实现特定行为。</p><p>本系列首先从创建型模式开始介绍，这是相对简单，使用频率更高的设计模式。创建型模式包含<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>生成器模式</strong>、<strong>原型模式</strong>、<strong>单例模式</strong>。</p><h2 id="工厂模式">工厂模式</h2><p>通常来说，工厂模式包括<strong>简单工厂</strong>（不被包含在许多设计模式教材中）、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。在一些书籍中可能还会包含其他模式，本篇只介绍这三种模式。</p><p>归根结底，工厂模式是一种创建型模式，其根本目的是<strong>创建对象</strong>。在开发中，最常见的新建对象的方式是通过<code>new</code>关键字，后面跟着构造函数的调用，使用一个目标类型的变量来接受新建对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br></code></pre></td></tr></table></figure><p>如果使用<strong>默认构造函数</strong>（无其他明确定义的构造函数，自动生成的无参构造函数），生成的对象属性默认初始化为<code>null</code>，通常需要在后续代码中调用对象的<code>setter</code>给对象赋值。<strong>新建对象，并对其属性赋值的过程统称为创建对象</strong>。</p><p>如果在代码中，多处地方都使用了此类<code>new</code>之后<code>.setX()</code>的代码来创建对象，并且代码有非常多重复的地方，便可以新建一个类专门负责这类对象创建的过程，这个类就是<strong>工厂类</strong>。这样做的好处是，如果这个类发生变动，例如新增/删除了一个属性，则不需要去追溯所有创建此类对象的地方，而只需在一个<strong>统一入口</strong>中进行调整，以便于代码维护。这也符合<strong>单一职责</strong>原则，即使用这些对象的地方不该拥有创建对象的职责，否则代码会变得更耦合。</p><p>额外思考一下，是否一定需要新建一个类来负责对象创建过程？能否把这个创建过程写在类的定义中，例如类的构造函数或静态方法中，是否也能实现<strong>创建对象统一入口</strong>的特性？笔者认为这是可行的。但当对象创建过程复杂时，例如需要查配置文件、查数据库表、访问网络时，把这些实现写在一个需要在多处使用的<code>Java Bean</code>中，这个<code>Bean</code>会添加很多依赖，这不符合<strong>模块化编程</strong>的思想，也增加了<strong>创建过程</strong>和<strong>使用过程</strong>的耦合。而静态方法中没法依赖非静态的属性，写法上会多很多限制。并且当涉及代码扩展时，会希望有一个统一的入口去创建这些有些相似但不同的类，而不是分布在每个类的构造函数中。</p><p>所以当类简单且不涉及扩展时，使用构造函数或静态方法来创建对象是可行的；但涉及创建过程复杂和类的拓展性时，工厂模式是更为合适的实践。</p><p>当涉及<strong>类的拓展</strong>时，为了保证代码的<strong>通用性</strong>，通常会使用接口来表示一系列具有类似功能的类。当工厂类中创建对象方法，返回的不是某个特定类的对象，而是一系列实现某个对象的接口，那么认为这就是工厂模式。此时在实际使用这个对象的地方，可以使用<strong>接口类型</strong>作为变量类型。如此这样，当替换/拓展了具体对象的类型，只要是实现了同一个接口，在使用这个对象的地方（例如使用变量接收创建的对象，调用对象的方法等，通常称为<code>客户端</code>）不需要改变代码就能正常运行，代码具有良好的拓展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个客户端代码是通用的，可以拓展createA()方法返回的具体类型，只要这个具体类实现了InterfaceA接口，在客户端不修改其他代码就能正常运行</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> factoryA.createA();<br>objectA.interfaceMethodA();<br></code></pre></td></tr></table></figure><h3 id="简单工厂">简单工厂</h3><p>上文描述的场景，基本上就是简单工厂的核心了。为了总结简单工厂的特征，对上文中提到的一些概念进行命名。</p><ul><li><p><strong>抽象产品接口</strong>：为了描述一系列具有相似功能的具体产品类定义的接口，相似部分通过声明接口方法来表示。在客户端中使用产品接口，可以不改变客户端代码，即可实现功能的拓展，符合开闭原则。</p></li><li><p><strong>具体产品类</strong>：产品接口的具体实现类。需要进行扩展时，可以定义一个新的具体产品，实现产品接口，并在工厂类的创建方法中新增对应的实例化此类的代码。</p></li><li><p><strong>工厂类</strong>：包含了创建产品对象的方法，返回一个产品接口类型的对象，根据客户端的需求来创建具体产品类对象</p></li><li><p><strong>客户端</strong>：调用工厂类方法来创建对象，并使用产品接口作为变量类型接收返回的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 产品接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span><br><span class="hljs-comment">// 具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span> <br><span class="hljs-comment">// 工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creater</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">(String name)</span>;<br>&#125; <br><span class="hljs-comment">// 客户端</span><br>&#123;<br>...<br><span class="hljs-comment">// 使用产品接口作为变量类型</span><br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">objectA</span> <span class="hljs-operator">=</span> Creater.createInterfaceA(<span class="hljs-string">&quot;classA&quot;</span>);<br><span class="hljs-comment">// 调用产品接口中声明的方法</span><br>objectA.interfaceMethodA();<br>...<br>&#125; <br></code></pre></td></tr></table></figure><p>对于简单工厂，“简单”二字体现在工厂类中，通常使用一个<strong>静态公共方法</strong>，并通过接受一个入参，根据入参来决定具体创建哪个具体产品类。这在代码中通常由一系列的<code>if else</code>或<code>switch</code>语句来实现。如果创建对象<strong>过程复杂</strong>，需要<strong>依赖其他对象</strong>，静态方法可能无法满足，那么写成一般方法，并在客户端中完成工厂类的实例化，再来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简单工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creater</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-type">InterfaceA</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ClassA&quot;</span>.equals(name)) &#123;<br>object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ClassB&quot;</span>.equals(name)) &#123;<br>object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB</span>();<br>&#125; ...<br><span class="hljs-keyword">return</span> object;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能这样描述还无法感受简单在哪。在后文介绍工厂方法和抽象工厂时，对比不同工厂模式的工厂类怎么处理，会有更直观的感受。</p><p>对于简单工厂来说，如果需要进行拓展，需要：</p><ol type="1"><li>新建一个具体产品类并实现产品接口</li><li>工厂类中的创建方法中新增一个<code>if else</code>分支，用于返回新建的具体产品类对象</li><li>客户端中调整调用创建方法时的入参</li></ol><h3 id="工厂方法">工厂方法</h3><p>在简单方法中，所有具体产品类的创建方法都在同一个工厂类中，因此拓展新具体产品时，不可避免地会对已有代码进行修改，违反了<strong>开闭原则</strong>。而在客户端中，由于只存在一个工厂类，不需要利用多态的特性，所以直接调用工厂类的静态方法。</p><p>要避免扩展时对已有代码的修改，这意味着工厂的创建方法也需要被拓展，<strong>工厂类本身也需要抽象</strong>。</p><p>因此相对于简单工厂，工厂方法对工厂类进行了抽象，新增以下定义</p><ul><li><strong>抽象工厂接口/抽象类</strong>：声明了创建产品接口的方法。如果除创建产品接口方法外，多个具体工厂类有许多类似代码，可以把这些代码抽取到工厂抽象类中（通常认为接口不提供方法实现），提供这些公共方法的默认实现。抽象类的特性也限制了其无法被实例化，并且子类必须实现声明的抽象方法。某种程度上可以理解为提供默认方法的接口。</li><li><strong>具体工厂类</strong>：具体工厂是抽象工厂的实现类/子类，实现了抽象工厂中定义的工厂方法</li></ul><p>与简单工厂不同，工厂方法通过抽象工厂来创建对象。这意味着客户端使用的是抽象工厂，而不是具体工厂类。相对于简单工厂中调用工厂类的静态方法，进一步降低了代码耦合。</p><p>抽象工厂这个词可能会产生歧义。前文提到“工厂模式包括<strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>”中的抽象工厂是指抽象工厂<strong>设计模式</strong>，而在此处定义的抽象工厂是<strong>接口/抽象类</strong>，是工厂方法模式中类组织关系中的一个<strong>角色</strong>。至于为什么工厂方法模式包含抽象工厂的概念，还要叫工厂方法，就不是本文要讨论的。设计模式的命名沿用了四人帮的著作《设计模式：可复用面向对象软件的基础》。</p><figure><img src="/img/factory-method.png" alt="工厂方法类图" /><figcaption aria-hidden="true">工厂方法类图</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CreaterInterfaceA</span> &#123;<br>InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 具体工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreaterClassA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CreaterInterfaceA</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">abstractCreater</span> &#123;<br>    <span class="hljs-keyword">abstract</span> InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span>;<br>    ...<br><span class="hljs-comment">// 一些其他公共方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sharedMethod</span><span class="hljs-params">()</span>;<br>    ...<br>&#125;<br><span class="hljs-comment">// 具体工厂类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreaterClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">abstractCreater</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    InterfaceA <span class="hljs-title function_">createInterfaceA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassA</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 客户端</span><br>&#123;<br>    <span class="hljs-comment">// 实例化工厂类，使用工厂接口类型接收</span><br><span class="hljs-type">CreaterInterfaceA</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreaterClassA</span>();<br>...<br>InterfaceA = factory.createInterfaceA()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码来看，由于通过<code>new CreaterClassA()</code>实例化具体工厂类，客户端仍含有对具体工厂类的依赖。但可以定义成员变量，并通过<code>IoC</code>注入，那么在客户端中将不会有关于任何<code>CreaterClassA</code>的依赖，降低了代码的耦合度。</p><p>对于工厂方法来说，如果需要进行拓展，需要：</p><ol type="1"><li>新建一个具体产品类并实现产品接口，这和简单工厂是一样的</li><li>需要新增一个具体工厂类，并实现抽象工厂接口的创建对象方法</li><li>在客户端中实例化具体工厂类，如果是通过依赖注入则不需要改动客户端</li></ol><h3 id="抽象工厂">抽象工厂</h3><p>在工厂方法模式中，抽象工厂定义了一个创建某种抽象产品的方法。在实际开发场景中，某个抽象产品可能并不是单独使用，还需要与其他有关联的抽象产品<strong>一起使用</strong>。例如在GUI相关代码中，按钮是一个抽象产品，文本框也是一个抽象产品。对于按钮这个抽象产品来说，有对应的Windows按钮具体产品实现，也有Mac按钮具体产品实现。文本框同理。对于程序来说，绘制GUI需要多种组件。但在一个应用程序中，创建这些组件对象，使用的都是同一个平台的具体产品实现。几乎不出现使用Windows的按钮，但使用Mac的文本框这种情况。这意味着具体产品可以通过<strong>平台维度进行分类</strong>。</p><table><thead><tr class="header"><th>平台</th><th>按钮抽象产品</th><th>文本框抽象产品</th></tr></thead><tbody><tr class="odd"><td>Windows</td><td>Windows按钮具体产品</td><td>Windows文本框具体产品</td></tr><tr class="even"><td>Mac</td><td>Mac按钮具体产品</td><td>Mac文本框具体产品</td></tr></tbody></table><p>如果沿用工厂方法模式，需要创建按钮抽象工厂接口、文本框抽象工厂接口、以及Windows按钮具体工厂类、Mac按钮具体工厂类、Windows文本框具体工厂类、Mac文本框具体工厂类。这是只有两种平台、两种抽象产品的情况下，当产品和平台数量变多时，具体工厂类的数量会<strong>急剧增加</strong>。</p><p>对于产品来说，每个产品都要有对应的代码，具体产品类的数量是无法减少的。而对于具体工厂类来说，由于某些产品会一起使用，而某些产品不可能一起使用。<strong>可以把能一起使用的抽象产品的创建都定义在同一个抽象工厂中</strong>。如此一来，抽象工厂不是只创建一种抽象产品，而是多种相关联的抽象产品。具体工厂类的数量可以从<code>抽象产品种类 * 平台种类</code>压缩至<code>平台种类</code>。在客户端调用抽象工厂的方法也从创建一种产品，变成创建多种相关的产品。</p><figure><img src="/img/abstract-factory.png" alt="抽象类图" /><figcaption aria-hidden="true">抽象类图</figcaption></figure><p>对于抽象工厂来说，如果需要进行拓展，通常是新增一种平台，需要：</p><ol type="1"><li>实现所有抽象产品的具体产品类</li><li>新增一种具体工厂类，实现所有抽象产品的创建方法，返回1中新增的具体产品类</li></ol><p>总的来说，抽象工厂模式，适用于存在<strong>多种抽象产品相互关联</strong>，可以通过<strong>某种维度对具体产品类进行分类</strong>的场景（上文中的操作系统平台）。在抽象工厂中，声明创建一系列抽象产品的创建方法，并在每个维度的具体工厂中实现这些方法。</p><h2 id="总结">总结</h2><p>介绍了工厂模式，工厂模式包括<strong>简单工厂</strong>、<strong>工厂方法</strong>、<strong>抽象工厂</strong>。</p><p>在工厂模式中，几个重要的概念为：抽象产品、具体产品、抽象工厂、具体工厂、客户端。</p><p>在简单工厂中，不存在抽象工厂，直接在具体工厂中提供了根据入参创建多种具体产品对象的创建方法，以抽象产品类型返回。这个方法通常是静态方法。客户端通过依赖具体工厂类来创建对象。</p><p>在工厂方法中，抽象工厂中定义了创建一种抽象产品的方法，需要在具体工厂中实现。客户端通过抽象工厂，调用创建方法来创建一种抽象产品对象。</p><p>在抽象方法中，抽象工厂中定义了一系列创建相关联的抽象产品的方法，一个具体工厂需要实现所有抽象产品的创建方法。客户端通过抽象工厂，调用创建方法来创建一系列抽象产品对象。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-SOLID</title>
    <link href="/2023/11/01/Design-Pattern-SOLID/"/>
    <url>/2023/11/01/Design-Pattern-SOLID/</url>
    
    <content type="html"><![CDATA[<p>距离上一次写博客已经过去了三个多月，一直忙于工作。</p><p>上次说到，设计原则是使得代码拥有更好复用性和拓展性的指南针，是一种基于优秀代码的经验总结。既然是经验总结，不同学者必然存在着不同归纳角度。上次提到的<strong>封装变化</strong>、<strong>面向接口而不是面向实现</strong>、<strong>组合优于继承</strong>原则是一种归纳，这次要讲的<strong>SOLID</strong>原则也是一种归纳。这些原则本是并列关系，但实际又会觉得互相关联、交融。因为本身可能都是对同一件事情，不同角度的描述。</p><p>SOLID原则是五条原则的简称，首次提出于罗伯特·马丁的著作《敏捷软件开发：原则、模式与实践》。每次遇到这类把多个原则或者理论，缩写成某个单词，我总是想，这是作者先想出来，然后发现这些原则凑巧就能拼成一个单词，还是在想原则名的时候，就在往这个单词上凑。</p><h2 id="single-responsibility-principle-单一职责原则">SingleResponsibility Principle 单一职责原则</h2><blockquote><p>一个类应该只有一个引起它变化的原因，或者说一个类应该只有一个职责。</p></blockquote><p><strong>改变的原因</strong>非常拗口，这是马丁对于职责的定义。使用更为通俗的说法，一个类应该只有一组互相关联的功能和属性（好像更复杂了）。如果一个类里面，不同的方法和属性没有互相依赖的关系，那么可以认为这个类具有了多个职责，可以将这些没有依赖的平行关系，拆分成多个类。</p><p>但这个原则最令人困惑，也是最模棱两可的地方，是很难界定某些功能和属性是否归属于相同职责。职责的界定依赖于人们对功能的主观理解，和划分的粒度。</p><p>不论如何，这个原则所表达的思想是，一个类里如果代码太多，可能就需要考虑是不是能拆成多个类。这与<strong>封装变化原则</strong>有相似的地方。封装变化原则将变化部分抽取为方法或类。有一种类内变化的部分负责一个职责，不变的部分负责另一个职责的感觉，最终实现单一职责原则的效果。</p><p>拆分成多个类的好处是：</p><ol type="1"><li>提高代码可读性。当你想要了解一个功能时，需要关注的内容变得更少</li><li>降低变更风险。修改代码时，可以减少影响到其他职责的风险。</li><li>增加代码的复用性。拆分出的类可以在多处被使用，而不用担心引入了过多不需要的功能。</li></ol><h2 id="openclosed-principle-开闭原则">Open/closed Principle开闭原则</h2><blockquote><p>对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的</p></blockquote><p>开闭原则关注在对代码扩展功能时，保持原有功能不发生变动。<strong>开放</strong>意味着拓展功能应该是容易且方便的，<strong>封闭</strong>意味着拓展时不应该改动已有代码的运行结果。</p><p>代码开发过程中，经常性会对已有功能进行拓展。拓展可能会对已有功能进行破坏，需要通过回归测试来确认改动的影响。一种解决办法是，每次拓展功能时都新增代码，不使用任何已经存在的代码。这样可以确保拓展的功能与源代码互不影响，但会导致代码复用率低。编程通常采用模块化编程和分层模型，就是为了提高代码的复用率。因此基本不采用这种办法。</p><p>比较合理的解决办法是，可以通过<strong>定义接口</strong>的形式，在方法中使用接口类型来接受变量。这样无需改动方法体本身，通过改变传入方法的参数，即可改变方法的实际行为，对功能进行了拓展，原有的功能也不会受到影响。这其实也体现了<strong>面向接口而不是面向实现</strong>的原则。另一种方法是<strong>使用继承</strong>，使得子类可以复用父类中的定义的方法，并在父类基础上进行调整。</p><p>开闭原则最关键的好处：</p><p>1.减少了回归测试的任务量</p><p>2.提高了代码的复用率</p><p>3.拓展新功能方便。如果在定义方法/成语变量时，使用接口作为参数类型，那么拓展功能只需改变传入方法或构造函数的参数，即可完成功能拓展。</p><h2 id="liskov-substitution-principle-里氏替换原则">Liskov SubstitutionPrinciple 里氏替换原则</h2><blockquote><p>派生类（子类）对象可以在程式中代替其基类（超类）对象。</p></blockquote><p>里氏替换原则是针对继承特性的原则。程序员通过继承，可以进行代码复用，在子类中复用其父类中定义的方法。在代码中，主要是通过调用父类中定义的公共方法，使用父类实例。里氏替换原则要求使用父类对象的地方，替换成子类对象，程序表现一致。</p><p>根据多态的特性，子类的对象可以赋值给父类的变量类型，并且只允许调用父类中定义的公共方法。如果子类中对父类定义的方法进行了重写，则实际会调用子类中重写的方法。要保证替换后程序行为一致，这意味着父类中实现的公共方法，不应该被子类重写。</p><p>稍宽松些，允许子类重写，需要保证逻辑符合父类中的定义，其方法的参数列表应该一致或更宽松，其返回类型应该兼容父类方法的返回类型。也就是父类方法中接受的参数，需要可以赋值给子类方法，子类方法中返回的对象，需要可以赋值给父类的返回类型。还有子类不能抛出比父类更多的异常类型、子类不应该加强其前置条件、子类不能削弱其后置条件等等要求。</p><p>由于在子类中重写父类方法会处处受限，因此更多的做法是不重写。或者直接将父类的方法定义为抽象方法，这样代码中就不会存在父类对象（抽象类不可实例化），自然也不涉及替换的问题了。</p><p>在开闭原则中提到，继承是一种遵循开闭原则的拓展类功能的方法。在代码中使用多态特性的地方很多，里氏替换原则保证了这些使用多态的地方，不会因为实际对象类型是父类还是子类，影响程序正常运行。在组合优于继承中提到，组合通常能达到和继承相同的作用，同时更灵活，但这也不是绝对的。实话说这很让人感到疑惑，前面说继承不好，现在又说使用继承应该注意的事项，不用不就行了吗？经验总结就会出现的情况是，归纳时通常只是针对某些特殊情况，虽然归纳本身已经是宽泛的理解。组合的优势在于，可以避免多维度继承带来的类数量爆炸，避免选择性继承的难题。如果不涉及多级继承，或者组合的对象数量不多，继承通常也是可以的选择。实际开发中可以根据继承层级、功能是否可分，以及是否需要动态性，选择使用组合和继承。</p><h2 id="interface-segregation-principle-接口隔离原则">InterfaceSegregation Principle 接口隔离原则</h2><blockquote><p>客户端不应被强迫依赖于其不使用的方法</p></blockquote><p>尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。</p><p>不同于继承，实现可以一次性实现多个接口，因此可以将功能过于复杂的接口，拆分成多个简单接口。这样在实现时可以选择性的实现，避免去实现那些用不到的方法（接口要求其实现类必须实现其定义的抽象方法）。</p><p>这一看和单一职责原则很像，都在表述需要将复杂的东西进行细分。但是单一职责原则针对类，而接口隔离原则针对接口。如果没有做好接口隔离原则，对接口进行细分，并且类中实现了接口定义的方法，那么通常这个类也是不满足单一职责原则的。</p><h2 id="dependency-inversion-principle-依赖倒置原则">DependencyInversion Principle 依赖倒置原则</h2><blockquote><p>高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。 具体实现应该依赖于抽象接口</p></blockquote><p>常规开发模式下，高层次类会调用低层次类提供的函数，体现出高层次类依赖低层次类的关系。在这种模式下，如果对低层次类进行改动，可能会对高层次类的运行产生影响。或者需要替换另一种低层次类的实现，例如数据不是从本地硬盘，而是从网络中获取，需要变动高层次类中的相关代码。</p><p>依赖倒置的<strong>倒置</strong>，指的就是改变这种高层次类直接依赖低层次类的关系。通过增加抽象层，依赖方向变成了两者都依赖抽象层。抽象层通常是通过接口，定义一组通用的方法或协议。高层次类直接依赖接口，低层次类通过实现的方式依赖接口。这样子分层的设计降低了层与层之间的耦合度。当需要更新低层次类，或者拓展出新的低层次类，只要保证低层次类实现了接口，在高层次类中的调用代码就无需改变。这也体现了开闭原则。</p><p>此外，由于高层次类中通过接口依赖低层次类。程序在运行时需要确定被引用的具体低层次类对象，这个创建低层次类对象，并将其赋值给高层次类对象的过程，通常是通过容器框架的依赖注入功能。这也和之前聊到的<code>Spring</code>框架的功能联系到了一起。</p><h2 id="总结">总结</h2><p>SOLID原则是一组优秀代码的经验总结。</p><p>单一职责原则是指，一个类只负责一系列相关功能，需要把过于复杂的类，根据功能划分，拆分成小的类。开闭原则是指程序设计，应该有良好的拓展性，拓展的同时又能保证已有功能不受影响，通常是通过继承或接口来实现。里氏替换原则限制了子类尽量不要重写父类中实现的公共方法，避免将子类对象赋值给父类类型时，可能会导致程序出错的情况。接口隔离是指定义接口时，如果存在实现类实现了不必要的方法的情况，可以考虑把接口进行拆分，使得实现类可以在实现时有选择进行实现。依赖倒置原则是指，高层次类不应该直接依赖低层次类，而是将依赖关系改成高层次类和低层次类都依赖于抽象类。在运行时，这些类的实际依赖通常通过框架的依赖注入来完成。</p><p>虽然这些原则广为人知，在写代码时仍要根据实际情况，决定是否遵循原则。例如可以思考未来是否会对其进行同类型功能的拓展；一个类行数比较多了是否要进行重构；改了一处代码，处处受影响。遇到这些情况时，就应该想起这些设计原则，并用于指导代码编写和重构。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven-Single-Module-Compilation</title>
    <link href="/2023/07/18/Maven-Single-Module-Compilation/"/>
    <url>/2023/07/18/Maven-Single-Module-Compilation/</url>
    
    <content type="html"><![CDATA[<p>最近工作比较繁忙，没有太多时间学习和写笔记，忙里偷闲写下了这篇。</p><p>在大型<code>Java</code>项目中，通常会有多个主应用。<strong>主应用</strong>是指具有诸如<code>public static void main</code>程序入口，可以被<code>java</code>执行的模块。<code>Maven</code>概念中一个<code>packing</code>属性不为<code>pom</code>的<code>pom</code>文件对应一个模块，可以单独编译、测试和打包。与应用相对的概念是<strong>库</strong>，不包含程序入口，但可以提供特定功能和服务被其他应用调用。在一个项目中，不同主应用之间独立运行又相互协作。例如常规<code>SpringBoot</code>应用提供页面操作接口，可以添加自动任务，而自动任务应用间隔扫描任务列表，并根据任务状态来执行对应操作。</p><p>当修改代码的范围只影响项目中一个应用，只需打包部署对应应用及其依赖即可。</p><p>在<code>IDEA</code>的<code>Maven</code>菜单界面中，有列出项目中的所有<code>pom</code>文件。如果选择其中某个主应用执行<code>mvn clean package</code>，则可能会提示无法找到依赖的项目中的其他模块，或者打包后发现受影响的依赖库没有更新。</p><p>解决问题最简单的方法是在所有模块的根<code>pom</code>执行<code>mvn clean package</code>，这样所有的模块都会进行编译。当然会得到正确的<code>jar</code>包，但不受影响的库和应用也进行了重新编译，增加了编译过程的耗时。</p><p>会出现这种问题的原因是，模块之间并不互相认识，因此在编译时无法区分其依赖是项目中的其他模块，还是在本地库中的第三方模块。为了说明这个情况，需要了解<strong>项目继承</strong>和<strong>项目聚合</strong>。</p><h2 id="项目继承">项目继承</h2><p>项目继承(Project Inheritance)<ahref="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#project-inheritance">官方文档</a>。</p><p>通俗来说，项目继承就是在<code>pom</code>文件中，通过<code>&lt;parent&gt;</code>标签指定父<code>pom</code>。具体可以通过<code>artifactId</code>或相对路径来指定。父<code>pom</code>可以来自于同一个项目，也可以来自其他第三方<code>pom</code>。如果来自于同一项目且使用<code>artifactId</code>时，则需要父<code>pom</code>文件位于子<code>pom</code>的上一级目录。</p><p>项目继承使得子<code>pom</code>可以继承父<code>pom</code>中的标签属性值。当然也不是所有的属性都会被继承，可以被继承的属性可以参考官方文档。</p><blockquote><p>Elements in the POM that are merged are the following:</p><ul><li>dependencies</li><li>developers and contributors</li><li>plugin lists (including reports)</li><li>plugin executions with matching ids</li><li>plugin configuration</li><li>resources</li></ul></blockquote><p>这意味着如果在子<code>pom</code>中，不显式地给某个属性赋值时，会默认使用父<code>pom</code>中的值。常见的作用是<ahref="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#dependency-management">依赖管理</a>。如果项目中多个模块会使用到同一个第三方库，依赖的版本不一致可能会出现问题。此时在父<code>pom</code>中进行了依赖版本的设定，那么在子<code>pom</code>中无需指定依赖的版本，会默认使用父<code>pom</code>中设定的版本。这样可以在单个<code>pom</code>文件中，进行整个项目用到的第三方库的版本管理。</p><h2 id="项目聚合">项目聚合</h2><p>项目聚合（Project Aggregation）<ahref="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#project-aggregation">官方文档</a>。</p><p>通俗来说，项目聚合就是在父<code>pom</code>文件中，通过<code>&lt;modules</code>&gt;标签指定其包含的模块。当在父<code>pom</code>处调用<code>maven</code>命令，如<code>mvn clean install</code>，则会递归地在其所有模块中调用相同命令。在项目根<code>pom</code>中调用可以编译所有模块使用的就是这个机制。此外还需要将父<code>pom</code>的<code>&lt;packaging&gt;</code>标签属性设置为<code>pom</code>。</p><p>值得一提的是，虽然使用了父<code>pom</code>这个概念，但项目聚合本身不必须进行项目继承。也就是在子<code>pom</code>中不必须指定<code>&lt;parent&gt;</code>。但通常项目聚合和项目继承会一起使用。其中项目继承常用来控制版本，项目聚合用来管理不同模块的递归编译。</p><h2 id="问题原因">问题原因</h2><p>在主应用所在的<code>pom</code>处执行<code>mvn clean package</code>，由于其没有子模块，因此不符合项目聚合的条件。所以并不知道其依赖来自于同一个项目，还是本地库。默认所有依赖都会去本地库中查找。如果本地库中存在同一个项目的模块上次打包的<code>jar</code>包，则会使用这个<code>jar</code>包，否则则会报错无法找到依赖。由于上次打包的<code>jar</code>包并不包含项目中现有的代码变动，因此会产生明明代码改了但没生效的情况。</p><p>一个直观的想法便是，在编译某个主应用前，手动将所有其他依赖的项目中的模块重新打包安装到本地库。确实可以解决问题，但这样会麻烦，而且模块之间的依赖和依赖传递关系靠手动分析很容易出错。</p><p>这个问题显然和项目聚合相关，而不是项目继承。出现这个问题的原因是，项目聚合只能在父<code>pom</code>处调用。父<code>pom</code>可以通过递归访问子模块信息，来组织子模块间的依赖关系。子<code>pom</code>无法通过递归访问父<code>pom</code>来了解父<code>pom</code>的其他模块信息。前文提到项目聚合不必须进行项目继承，也就是子<code>pom</code>可能都不知道父<code>pom</code>是谁，父<code>pom</code>有没有自己这个孩子。也就是说项目聚合的递归调用只能是从根到子节点，而不能是子节点向根（<code>pom</code>通过树的形式组织）。子<code>pom</code>所在的模块，项目中的其他模块对其来说是不可见的。</p><h2 id="解决方法">解决方法</h2><p>要能满足只编译主应用及其依赖模块，根据项目聚合的特性，只能在主应用和依赖模块的共同祖先节点处执行<code>maven</code>命令。不管项目具体结构如何，根目录一定满足这个共同祖先这个要求。所以为了解决这个问题通常还是会在根<code>pom</code>处执行<code>maven</code>命令。</p><p>而在根<code>pom</code>直接执行<code>maven</code>命令，默认行为会对所有模块执行。因此<code>maven</code>提供了一组参数来控制这个过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mvn">-pl, --projects<br>        Comma-delimited list of specified reactor projects to build instead of all projects. A project can be specified by [groupId]:artifactId or by its relative path<br>-am, --also-make<br>        If project list is specified, also build projects required by the list<br></code></pre></td></tr></table></figure><p><code>-pl</code>参数指定了编译的具体模块。指定后<code>maven</code>命令不再对所有模块执行。-am参数指定了目标模块如果依赖项目中其他模块，那会递归编译。</p><p>如果目标应用<code>pom</code>和根<code>pom</code>在文件目录上不是直接父子目录关系，通常使用<code>[groupId]:artifactId</code>的方式来指定具体模块。通常<code>[groupId]</code>可以省略，所以常见的写法是。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean install -pl :some-app -am<br></code></pre></td></tr></table></figure><p>把<code>some-app</code>替换为具体目标应用的<code>groupId</code>即可。</p><h2 id="总结">总结</h2><p><code>maven</code>中项目继承和项目聚合是两个非常常用的功能。但由于都涉及父子关系的概念，很容易将两者混淆。</p><p>项目继承是指子<code>pom</code>通过<code>&lt;parent&gt;</code>标签指定父<code>pom</code>。这样子<code>pom</code>就可以从父<code>pom</code>中获得很多属性的默认值。例如在依赖管理中，可以在父<code>pom</code>中指定依赖的版本，在子<code>pom</code>中就不需要指定依赖的版本号。</p><p>项目聚合是指在一个父<code>pom</code>中指定其拥有的模块，并将<code>&lt;packaging&gt;</code>标签属性设置为<code>pom</code>。此后在父<code>pom</code>中调用<code>maven</code>命令时，默认会在所有子模块中递归执行。执行顺序取决于子模块间的依赖关系。</p><p>项目聚合默认会对所有子模块执行，如果只相对其中某个应用执行，则可以通过<code>-pl am</code>参数来指定目标模块。</p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
      <tag>Single Module Compilation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-String-Pool</title>
    <link href="/2023/07/04/JVM-String-Pool/"/>
    <url>/2023/07/04/JVM-String-Pool/</url>
    
    <content type="html"><![CDATA[<p>最近在学习<code>JVM</code>的过程中，遇到了一个十分容易混淆的概念，<code>字符串池</code>。有关<code>字符串池</code>的代码，运行结果始终没有和预期对应上。查询了大量资料无果后，在<code>stackoverflow</code>上发布了提问，<ahref="https://stackoverflow.com/questions/76579840/java-string-intern-function-and">提问链接</a>。提问后的半天内（在此感叹下国际友人的钻研精神），有两位大佬和我就此问题进行了探讨。在交流中对这个概念的理解逐渐清晰。通过将这个事情记录下来，来理清自己的思路，并分享给更多人。</p><p>由于具体情况可能在不同<code>JVM</code>上表现不同，本次实验和讨论基于<code>JDK8</code>，<code>HotSpot JVM</code>。</p><h2 id="问题">问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;12&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;21&quot;</span>);<br>    s1.intern();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1221&quot;</span>;<br>    System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;12&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;21&quot;</span>);<br>    <span class="hljs-comment">// s1.intern();</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1221&quot;</span>;<br>    System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有上述两段代码，唯一的区别就是是否调用了<code>s1.intern()</code>，而产生了不同的输出结果。</p><p><code>intern</code>是一个<code>native</code>方法，在Java8源代码中的注释如下：</p><blockquote><p>When the intern method is invoked, if the pool already contains astring equal to this String object as determined by the equals(Object)method, then the string from the pool is returned. Otherwise, thisString object is added to the pool and a reference to this String objectis returned.</p></blockquote><p>这段代码的字节码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bytecode"> 0 new #2 &lt;java/lang/StringBuilder&gt;<br> 3 dup<br> 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br> 7 new #4 &lt;java/lang/String&gt;<br>10 dup<br>11 ldc #5 &lt;12&gt;<br>13 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br>16 invokevirtual #7 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br>19 new #4 &lt;java/lang/String&gt;<br>22 dup<br>23 ldc #8 &lt;21&gt;<br>25 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br>28 invokevirtual #7 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br>34 astore_1<br>35 aload_1<br>36 invokevirtual #10 &lt;java/lang/String.intern : ()Ljava/lang/String;&gt;<br>39 pop<br>40 ldc #11 &lt;1221&gt;<br>42 astore_2<br>43 getstatic #12 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br>46 aload_1<br>47 aload_2<br>48 if_acmpne 55 (+7)<br>51 iconst_1<br>52 goto 56 (+4)<br>55 iconst_0<br>56 invokevirtual #13 &lt;java/io/PrintStream.println : (Z)V&gt;<br>59 return<br></code></pre></td></tr></table></figure><h2 id="错误的理解">错误的理解</h2><ol type="1"><li>在源代码中，出现了<code>"12"</code>、<code>"21"</code>、<code>"1221"</code>字面量。因此编译后，字节码常量池中可以观察到这三个字面量对应的<code>CONSTANT_String_info</code>，这些<code>CONSTANT_String_info</code>在这些指令中被使用：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bytecode">11 ldc #5 &lt;12&gt;<br>23 ldc #8 &lt;21&gt;<br>40 ldc #11 &lt;1221&gt;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>当程序运行，类加载器加载这个类时，字节码文件中常量池被载入内存。在内存中称为运行时常量池。字符串池是运行时常量池的一部分，因此在字符串池中包含<code>"12"</code>、<code>"21"</code>、<code>"1221"</code>这些字符串。</p></li><li><p><code>new String("12")</code>在堆中申请了一块空间，容纳新<code>String</code>实例，并从字符串池中取出<code>"12"</code>，并用此对新实例进行初始化。对应的字节码如下，<code>new String("21")</code>也是同理。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bytecode"> 7 new #4 &lt;java/lang/String&gt;<br>11 ldc #5 &lt;12&gt;<br>13 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>+</code>进行字符串拼接，本质被编译器转化为了<code>StringBuilder</code>实例和进行<code>append</code>方法，并最后调用<code>toString</code>方法，对应的字节码:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bytecode">0 new #2 &lt;java/lang/StringBuilder&gt;<br>4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br>16 invokevirtual #7 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>在<code>toString</code>方法中，调用了<code>new String</code>，因此最后返回的<code>s1</code>是<code>"1221"</code>的<code>String</code>实例，位于堆上。</li><li>根据文档，<code>s1.intern()</code>方法，查看了字符串池，发现确实存在<code>"1221"</code>，返回了字符串池中的地址引用。不管如何，代码中没有利用返回值，只是将他<code>pop</code>掉了，因此不会对已有的变量进行任何改动。</li><li><code>String s2 = "1221"</code>查看了字符串池，发现存在，因此将其地址引用赋值给<code>s2</code>。对应字节码为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bytecode">40 ldc #11 &lt;1221&gt;<br>42 astore_2<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li><code>==</code>运算符对于引用类型来说，比较的是俩者的地址。<code>s1</code>的地址指向堆中，<code>s2</code>的地址指向字符串池中。俩者怎么可能会相等？</li></ol><h2 id="疑惑">疑惑</h2><ol type="1"><li><code>s1</code>和<code>s2</code>到底指向哪里？</li><li>为什么调用<code>intern</code>方法会影响代码行为，甚至没有去利用其返回值？</li></ol><h2 id="正解">正解</h2><p>错误出现在理解<strong>2</strong>和<strong>6</strong>中，字符串池并没有随着类加载，被载入运行时常量池。<code>s1.intern()</code>是首次将<code>"1221"</code>加入到字符串池中，而后运行的<code>String s2 = "1221"</code>，会根据字符串池中是否存在<code>"1221"</code>改变行为。</p><p>为了更好解释这个问题，首先对涉及的关键概念进行定义。</p><h3 id="关键概念">关键概念</h3><ul><li>常量池：字节码中的一种存储结构，用来存储源代码中用到的常数、字符串，类、字段、方法、接口、参数类型等。位于硬盘上的字节码文件中。具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">官方文档</a>。</li><li>运行时常量池：程序运行时，内存中的常量池。在类加载时，会将常量池数据加载到<code>JVM</code>方法区，形成运行时常量池。具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1">官方文档</a>。</li><li><code>CONSTANT_String_info</code>：常量池中的一种数据结构，储存了源代码中字符串字面量对应的<code>Unicode</code>序列，具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3">官方文档</a>。</li><li>字符串池：JDK8堆中的一块内存区域，用于存取用到过的<code>String</code>实例。源码中<code>String.intern()</code>函数的<ahref="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/String.html#intern()">官方文档</a>。</li></ul><blockquote><p>A pool of strings, initially empty, is maintained privately by theclass String.</p></blockquote><ul><li><code>ldc #5</code>，将序号为5的常量从运行时常量池中推到操作数栈上，具体见<ahref="https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-6.html#jvms-6.5.ldc">官方文档</a>。在使用到通过字面量表示的字符串，都会先检查字符串池中是否存在对应的<code>string</code>实例。如果存在，则入栈其引用地址；如果不存在，则在字符串池内创建<code>string</code>实例并入栈其地址。</li></ul><h3 id="错误原因">错误原因</h3><p>错误来自于误解了字符串池和常量池（此后不加区分地使用常量池和运行时常量池）间的关系。</p><p>虽然通常称其为<strong>字符串常量池</strong>，但其和常量池并不存在属于关系。因此并不会随着类的加载而载入。在<code>JDK6</code>时，字符串池和常量池都位于永久代，好似之间存在一些关系。但在<code>JDK8</code>中，字符串池被移到堆中。与其说是常量池的一部分，更不如说是<code>String</code>类的一部分。可以理解为<code>String</code>类的一个私有的成员变量，虽然在<code>String</code>源码中无法观察到。字符串池中的<code>String</code>实例在被创建后，无法改变实例中的字节数组字段。如果对已有的<code>String</code>实例进行改变的操作，会生成一个新的<code>String</code>实例，表现出<strong>常量</strong>的特性，所以通常称其为<strong>字符串常量池</strong>。但为了避免混淆字符串池和常量池，本文尽量使用<strong>字符串池</strong>，而不是<strong>字符串常量池</strong>。</p><p>与其容易混淆的另一个概念是常量池中的<code>CONSTANT_String_info</code>。里面以<code>Unicode</code>序列储存着字符串字面量，并且会随着类加载，载入到运行时常量池中。但其和字符串池有着本质区别：<code>CONSTANT_String_info</code>只储存了<code>Unicode</code>序列，而字符串池储存了<code>String</code>实例。<code>String</code>实例不仅包含了<code>Unicode</code>序列，还包含了其他成员属性，如<code>hash</code>。并且<code>String</code>类绑定了许多方法，这些方法无法在<code>CONSTANT_String_info</code>上执行。可以通过以<code>CONSTANT_String_info</code>中的<code>Unicode</code>序列为参数，执行<code>String</code>初始化函数，生成对应的<code>String</code>实例。</p><h3 id="具体行为">具体行为</h3><p>根据文档，字符串池初始为空，并会在字符串第一次被使用时被加入到字符串池中。以后再用到相同的字符串，会复用字符串池已经存在的对象。所以详细描述的<code>ldc #5</code>执行过程应该是这样的：</p><p>1.取出运行时常量池中的索引为5的<code>Unicode</code>序列</p><p>2.根据此序列，在字符串常量池中寻找是否存在对应的<code>String</code>实例</p><p>3.如果存在，则将其引用入栈</p><p>4.如果不存在，则在字符串中创建一个新的<code>String</code>实例，以<code>Unicode</code>序列为参数，执行初始化，并将新创建的<code>String</code>实例的引用入栈。</p><p>而<code>new</code>关键字，则会在堆（字符串池外）中创建一个新的<code>String</code>实例。如果通过字面量形式赋值，如<code>new String("12")</code>，则会现在字符串池中创建实例，再以字符串池中的实例为参数，调用参数类型为<code>String</code>的初始化函数。执行完后，内存中存在两个一模一样的<code>String</code>实例，一个在堆中，一个在字符串池中。这点可以从字节码指令中看出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bytecode"> 7 new #4 &lt;java/lang/String&gt;<br>10 dup<br>11 ldc #5 &lt;12&gt; //字符串池中不存在，因此会创建一个String`实例<br>13 invokespecial #6 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt; //调用参数为String的初始化函数<br></code></pre></td></tr></table></figure><p>向字符串池中加入新的<code>String</code>实例通常有两个方法。<code>ldc</code>一个字符串池中不存在的常量，或者调用一个字符串池中不存在的<code>string</code>实例的<code>intern</code>方法。第二中方法相对少见，因为这需要在堆上，不通过字面量的形式创建一个<code>string</code>实例。这通常需要通过字符串操作来做到。</p><p>对于一个字符串池中不存在的<code>string</code>实例，对其调用<code>intern</code>方法会将其引用添加到字符串池中，而不是重新在字符串池中创建一个新的相同的实例。此为<code>JDK8 Hotspot</code>的行为，这个行为可能会因<code>JDK</code>版本和<code>JVM</code>具体实现而异。例如在<code>JDK6</code>就会重新在字符串池中创建一个新的相同的实例。</p><p>因此回答上文提到的两个问题：</p><p>1.<code>s1</code>指向堆中的<code>"1221" String</code>实例，<code>s2</code>根据字符串池中储存的引用，最终也指向了堆中的<code>"1221" String</code>实例。所以在<code>JDK8</code>中，内存中存在两处<code>"1221"</code>序列，一处在常量池中，一处在堆上。字符串池由于存储的是引用，因此没有<code>"1221"</code>序列。</p><p>2.因为<code>s1</code>没有通过字面量，而是字符串拼接的形式创建了<code>"1221" String</code>实例，在这种情况下，字符串池中不存在<code>"1221"</code>，调用<code>intern</code>方法会影响字符串池，从而影响到<code>ldc</code>指令获取到的地址。</p><h2 id="总结">总结</h2><p>避免混淆字符串池、常量池、<code>CONSTANT_String_info</code>的概念和之间的关系。</p><p>字符串池是一个位于堆上的，用于管理<code>String</code>实例的数据结构，可以被视为<code>String</code>类的一个私有成员变量。</p><p>常量池是字节码文件中的存储结构。运行时常量池是在类加载过程中，将常量池加载到方法区/元空间形成的内存区域。</p><p><code>CONSTANT_String_info</code>是常量池/运行时常量池中的存储结构，储存了源代码中用到的字符串字面量的<code>Unicode</code>序列。是常量池的一部分，随类加载而加载。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>String Pool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Design-Principle</title>
    <link href="/2023/06/27/Design-Pattern-Design-Principle/"/>
    <url>/2023/06/27/Design-Pattern-Design-Principle/</url>
    
    <content type="html"><![CDATA[<p>设计模式是一系列优秀的代码构思实践。但从代码的功能性角度来说，很难定义什么是优秀的。<strong>“这不是也能跑吗”</strong>是对这个想法的准确体现。如果两份代码执行表现完全相同，凭什么说，其中一份比另外一份代码要好？设计原则回答了这个问题。</p><p>在日常开发中，看到一份代码变量名规范，注释规范，我们会说代码是好的。这是从可读性上对代码进行的评判。而设计原则从另一个角度进行评价：<strong>代码复用</strong>和<strong>拓展性</strong>。有时候设计原则和可读性是相违背的，一些设计模式为了增加复用性和可扩展性，反而会把类的结构变得更复杂，影响可读性。</p><h2 id="代码优秀特征">代码优秀特征</h2><h3 id="代码复用">代码复用</h3><p>可以通过观察代码中重复或相似的片段的多少，来体现代码复用执行的程度。</p><p>如果一份代码在多处被使用，那么可以抽取成一个方法，并在使用处改写为对方法的调用。方法中可能发生变化的地方，可以抽取成方法的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>...<br>methodC();<br>...<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>...<br>methodC();<br>...<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sharedMethodC</span><span class="hljs-params">()</span> &#123;<br>some shared code<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的好处是，如果这些反复使用的代码要进行改动，那么只需要改动抽取后的方法就可以了。不采取复用的话，需要找到所有使用这些代码的地方进行修改。而且代码复用本身也可以减少开发量，缩短开发周期。</p><p>从小的层面讲，将多处使用到的代码，抽取成一个方法，或者把相关的方法再次打包成一个类，就是代码复用。开发中经常会有一些工具类，提供一些静态方法，可以在多个地方被使用。工具类就是代码复用的一个体现。</p><p>往大了说，框架本身也是代码复用的体现。不同的项目可以根据业务特殊需求，自定义子类，而使用共同的<code>SpringBoot</code>框架。</p><p>而在这两个层次之间，就是设计模式。设计模式通常用来组织少数对象之间的关系和其间的互动行为。在设计模式中，可以将描述的角色替换成不同的具体类，来实现代码复用。</p><h3 id="拓展性">拓展性</h3><p><strong>变化</strong>是程序员生命中唯一不变的事情。</p><p>程序员经常会面对新出现的需求，进行新功能的开发。这些新功能可能和已有的功能有些相似，但也不完全相同。考虑之前提到的代码复用，可能需要对相似的部分进行抽取，或者所有代码都得重写。但这样不可避免就会破坏已有的代码，没有人能保证代码重构后，原功能仍然能正常运行。如果每次添加新功能，都需要将已有的功能重新测试，这无疑增加了工作量。因此在首次开发功能时，就需要对未来可能会出现的新需求进行预测和假设。</p><p>一份代码，在增加新功能时非常方便，并且不会破坏原有代码时，则称其有良好扩展性。</p><h2 id="设计原则">设计原则</h2><p>为了使代码更优秀，也就是使代码拥有更好的复用性和可拓展性，程序员总结出了一系列设计原则。在开发中遵守这些原则，就可以提高代码质量。设计模式中或多或少都体现了对这些原则的遵守。值得一提的是，原则不是必须遵守的，程序员需要根据实际情况，衡量遵守原则的收益和代价。代价通常是前文提到的代码复杂性和可读性。</p><h3 id="封装变化的原则">封装变化的原则</h3><p>找到程序中的变化内容并将其与不变的内容区分开。</p><p>该原则的主要目的是将变更造成的影响最小化。根据未来是否可能会发生变化，将变化部分的代码抽取成一个方法。当进行修改时，只在抽取后的方法中进行修改。这样不会对调用处的原方法造成更多影响。要说影响的话，也就具体返回值可能会发生变化，从而将影响控制到了最小程度。</p><p>在代码中，通常会有根据字符串或者某些标识符，进行<code>switch case</code>判断，来决定执行的逻辑。通常可以认为，未来会有更多的<code>case</code>情况，也就是会发生变化。从而将<code>switch case</code>部分进行方法抽取，将变量或标识符通过参数传递到抽取的方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    ...<br>switchCase(<span class="hljs-keyword">case</span>);<br>    ...<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">switchCase</span><span class="hljs-params">(String <span class="hljs-keyword">case</span>)</span> &#123;<br>    <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">case</span>) &#123;<br>        <span class="hljs-keyword">case</span> case1:<br>            ...<br>            <span class="hljs-keyword">break</span>;<br>...        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将变化部分的代码抽取成方法，这是方法层面的封装。如果将类中常发生变动的成员变量和方法进行抽取成一个新的类，这是类层面的封装。多个变化的类，甚至可以以成员变量的形式共享同一个不变的类，这也是<code>享元</code>设计模式的核心思想。</p><h3 id="面向接口而不是面向实现的原则">面向接口而不是面向实现的原则</h3><p>之前提到，接口可以视为一些具体类的集合。</p><p>在代码中，如果将变量定义为某个具体类（相对于抽象类/接口），那么需要使用新扩展的具体类时，就需要改动使用处的变量类型。这也违反了上一条<code>封装变化</code>的原则。说明原则之间不全是相互独立的，其间也可能存在交叉的关系。</p><p>符合原则的做法是，将可能会扩展的类，和已有的具体类中方法相似的部分，抽取成一个接口，将新扩展和已有的具体类都实现这个接口，并将所有用到这些类的地方的变量类型设置为接口类型，通过多态性调用具体类的实现。接口中定义了允许调用的方法，规范了类和类之间交互的行为。新定义的类只要符合规范（实现接口），就可以无缝扩展到已有代码中。程序员通过查看接口代码，就基本能了解其具体实现类能做的行为。</p><p>在一些<code>SpringBoot</code>项目中，会采用分层模型：<code>Controller</code>、<code>Service</code>、<code>DAO</code>。在<code>Service</code>层中，可以定义一系列的<code>Service接口</code>，并使用<code>ServiceImpl</code>去实现具体类。然后在<code>Controller</code>中使用<code>Service</code>时，通过接口进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeController</span> &#123;<br>    <span class="hljs-comment">// 通过@Resource自动注入或构造器传参</span><br>Service service;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    some method declear<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    concrete method implementation<br>&#125;<br></code></pre></td></tr></table></figure><p>但接口也会使代码更复杂。本来只有两个具体类，现在还多了一个接口。如果项目代码中<code>ServiceImpl</code>和<code>Service</code>是一一对应关系，也就是没有进行扩展，可能也不需要将其拆成一个接口和一个类。具体是否拆成两个的代码习惯得参照公司规范。</p><h3 id="组合优于继承">组合优于继承</h3><p>如果几个类都具有共同的属性和方法，那么可以通过继承，来实现代码复用。这些类通常在概念上是互相相关的，例如丘丘人和史莱姆都属于怪物，体现出<code>is-a</code>关系。</p><p>具体做法是将共同的属性和方法都抽取到一个怪物类中，然后将丘丘人和史莱姆都继承于怪物类。为了使子类必须实现怪物类中定义的方法，通常会将怪物类设置为抽象类。而且怪物本身也是个抽象概念，不应该被实例化。</p><p>但问题在于，无法选择性继承，这意味着对于某些怪物，基类中的某些方法可能不是必须的。例如有些丘丘人萨满无法攻击，那么攻击力属性和攻击方法，可能就是不需要的。风史莱姆会飞，但对于土史莱姆来说，飞行方法可能是不需要的。当然可以从怪物抽象类中，继承出会攻击怪物和不会攻击怪物抽象类，再将会攻击怪物分成会攻击会飞行怪物，和会攻击不会飞行怪物。到这里已经能体会到继承可能存在的问题了。</p><p>因为无法选择性继承，而某些具体类又不需要完全用到被继承类的所有属性和方法时，就需要多加一层继承关系。当在多个独立的维度上同时发生这些问题时，会造成类的组合爆炸。</p><p>更加好的做法是，定义两个接口，<code>Flyable</code>和<code>Attackable</code>。并根据具体类的情况，实现其中对应的接口。而如果多个会飞的怪物，他们的飞行属性和飞行方法中，代码相似度非常高，为了实现代码复用，可以将飞行相关的属性和方法抽取成<code>FlyAbility</code>类，并实现<code>Flyable</code>接口。然后以成员变量的形式将<code>FlyAbility</code>组合/聚合到具体怪物类中。调用具体怪物类的飞行方法时，将调用<code>FlyAbility</code>成员变量的飞行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br>Double hitPoint;<br>...<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">death</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyAbility</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>Double flySpeed;<br>Double flyHeight;<br>    ...<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>    concrete method implementation<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnemoSlime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">private</span> FlyAbility flyAbility;<br>    ...<br>    AnemoSlime()&#123;<br>        <span class="hljs-built_in">this</span>.flyAbility = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyAbility</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        flyAbility.fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中，风史莱姆是通过组合了<code>FlyAbility</code>变量，而不是继承的形式，来获得了飞行相关的属性，实现了代码复用。这就是组合优于继承。</p><p>但原则不是绝对的。从代码可以观察到类的结构确实因为组合而变得复杂了许多。一般来说，如果一些对象，其属性和方法没有在多个维度有区分，继承关系比较简单，那么使用继承也是可以的。当需要对对象进行细粒度拆分，可能组合是更好的选择。</p><h2 id="总结">总结</h2><p>限于篇幅，<code>SOLID原则</code>放到下篇讲。</p><p>在代码能按照设计功能正常运行时，我们通常通过可读性、复用性、可拓展性来衡量一份代码的好坏。</p><p>为了提高代码的复用性和可拓展性，程序员总结了一系列的设计原则，遵守这些原则可以写出更优秀的代码。设计模式是这些原则的优秀实践。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Rebase</title>
    <link href="/2023/06/19/Git-Rebase/"/>
    <url>/2023/06/19/Git-Rebase/</url>
    
    <content type="html"><![CDATA[<p><code>Git</code>是最常用的<code>VCS</code>(<em>version control</em>system，版本控制系统)工具。在<code>Git</code>中，多人协作开发涉及到多分支，而分支管理则必然会涉及<code>新建分支</code>和<code>分支合并</code>。相对于<code>新建分支</code>，<code>分支合并</code>复杂得多，是问题的高发地段。<code>合并分支</code>通常有两种方式，<code>merge</code>和<code>rebase</code>。其中<code>merge</code>是通过新建一个特殊的提交（本文不加区分地使用提交/节点），这个提交指向了两个节点（常规的提交只有一个父节点），这两个节点分别来自不同的分支。</p><figure><img src="/img/merge.png" alt="merge" /><figcaption aria-hidden="true">merge</figcaption></figure><p>如果合并时发生冲突，那么<code>合并提交</code>还会包含了冲突解决的信息。在<code>IDEA</code>中查看提交的文件改动，会发现相较于常规的两个窗口（一个显示提交前的版本，一个显示提交后的版本），<code>合并提交</code>的改动有三个窗口，因为提交前的版本有两个，来自不同分支。</p><h2 id="rebase">rebase</h2><p>相对于<code>merge</code>，<code>rebase</code>就要复杂得多。一个可能的原因是<code>rebase</code>会改动提交历史，并且没有交换律。</p><p>通俗来讲，<code>rebase</code>的工作是找到两个分支的共同的祖先节点，并统计自共同的祖先节点开始的所有提交，在另一条分支上执行一次。此处借用<ahref="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">《GitPro》</a>中的图片。</p><figure><img src="/img/basic-rebase-1.png" alt="初始状态" /><figcaption aria-hidden="true">初始状态</figcaption></figure><figure><img src="/img/basic-rebase-3.png" alt="rebase后" /><figcaption aria-hidden="true">rebase后</figcaption></figure><p>图中，找到<code>experiment</code>分支的<code>C4</code>节点，和<code>master</code>分支的<code>C3</code>节点的共同祖先，也就是<code>C2</code>节点，并将自<code>C2</code>开始的所有发生在一侧的提交，在另一侧重现（图中只有一个<code>C4</code>，如果有更多都会重现）。并将<code>experiment</code>的指针指向<code>C4'</code>。<strong>这里就涉及到谁<code>rebase</code>到谁上的问题</strong>。体现在图中就是到底是新的<code>C4'</code>在<code>C3</code>后，还是新的<code>C3'</code>在<code>C4</code>后。</p><p>在<ahref="https://git-scm.com/docs/git-rebase">官方文档</a>中，<code>git rebase</code>指令可以有很多变体。例如<code>git rebase A</code>、<code>git rebase A B</code>、<code>git rebase --onto A C B</code>。其中A、B、C表示分支的索引或提交。指定A、B、C本质就是在解决谁<code>rebase</code>到谁上的问题。</p><p>在<code>merge</code>时，合并时两个分支的地位是均等的。在<code>A</code>分支输入<code>git merge B</code>和在<code>B</code>分支输入<code>git merge A</code>，最后的结果几乎是一致的。细微的区别是合并后指向<code>合并提交</code>的分支是<code>A</code>或<code>B</code>，但在切换到另一个分支再<code>merge</code>一次后(<code>fast-forward</code>)，状态就完全一致。<code>merge</code>的这种两分支互换对合并后结果几乎没影响，我称之为<strong>交换律</strong>。</p><p>相较于<code>merge</code>，<code>rebase</code>不遵循<strong>交换律</strong>。把<code>A</code>放在<code>B</code>上和把<code>B</code>放在<code>A</code>上，这显然是两个不同的状态。由于指令的复杂，以及A、B、C互相不可交换，地位不均等，导致<code>rebase</code>比<code>merge</code>更容易犯错。</p><p>回到上面提到的三个指令<code>git rebase A</code>、<code>git rebase A B</code>、<code>git rebase --onto A C B</code>。其中<code>A</code>表示<code>新基</code>，<code>B</code>表示被<code>rebase</code>的分支，<code>C</code>表示从<code>C</code>开始计算到<code>B</code>的改动。上述指令的含义表示：<strong>从<code>C</code>开始统计，统计到<code>B</code>分支指向的节点做的所有改动，将这些改动在<code>A</code>上重现一次，并将<code>B</code>的引用指向重现完后的状态</strong>。如果<code>B</code>省略，则<code>B</code>默认为当前所在分支。如果<code>C</code>省略，则默认为<code>A</code>和<code>B</code>的最近的祖先节点。</p><h3 id="常规实践">常规实践</h3><p>在实际开发中，通常有一个共享的主分支，例如<code>master</code>分支。开发人员从<code>master</code>分支上某个节点建立新分支<code>feature</code>，并在此上开发。相对于共享的<code>master</code>分支，<code>feature</code>通常是不共享的。<code>master</code>被多人共同使用，改动会造成较大影响，因此主分支上的提交历史通常不会修改。而<code>feature</code>分支历史的修改只影响个人。因此在涉及谁<code>rebase</code>到谁上的问题时，<strong>通常会将<code>feature</code>分支<code>rebase</code>到<code>master</code>上</strong>。因为<code>rebase</code>操作会修改被<code>rebase</code>的分支的提交历史，对应上图中原本的<code>C4</code>节点将无法通过新指针找到，提交历史从<code>C2</code>-&gt;<code>C4</code>，变成了<code>C2</code>-&gt;<code>C3</code>-&gt;<code>C4'</code>。</p><p>为了将<code>feature</code>分支<code>rebase</code>到<code>master</code>上，当然可以使用<code>git rebase A B</code>指令。但通常在GUI操作中，会先切换到<code>feature</code>，在进行<code>rebase</code>操作，相当于执行了<code>git rebase A</code>，把<code>B</code>和<code>C</code>都省略了。这里有一个助记的方法，做的所有操作，都是在当前所在分支进行修改。根据这个助记，就能分辨<code>签出并变基到A(Checkout and Rebase onto Current)</code>，和<code>将A变基到B(Rebase Current onto Selected)</code>这两个操作的实际行为了。</p><figure><img src="/img/IDEA-rebase2.png" alt="IDEA-rebase-本地分支" /><figcaption aria-hidden="true">IDEA-rebase-本地分支</figcaption></figure><p>在集中式的<code>VCS</code>中，例如<code>SVN</code>，开发人员在提交代码前，需要先拉取，这个行为就像是<code>rebase</code>。因为开发是基于主分支某个历史状态，而主分支会在开发过程中产生新的提交。在开发完成后，就需要把从开发基于的节点（共同的祖先节点），到主分支的最新状态中的修改，重新包括进来。结果就好像是在最新状态进行的开发，而不是某个历史状态。如果将修改引入的过程中遇到了冲突，那还涉及冲突解决。在<code>Git</code>中使用<code>rebase</code>而不是<code>merge</code>，会产生像集中式<code>VCS</code>简单的线性历史记录，使得整个开发历史更直观。</p><h3 id="rebase的撤销">rebase的撤销</h3><p>如果在<code>rebase</code>时发生了冲突，则会在新的提交中包含冲突解决的信息。如上图中的<code>C4</code>和<code>C3</code>发生了冲突，那么需要在新的<code>C4'</code>中解决冲突。冲突解决的结果是<code>C4</code>相对于<code>C2</code>做的修改，将不同于<code>C4'</code>相对于<code>C3</code>做的修改。</p><p>由于提交历史的改动，导致<code>rebase</code>的撤销要麻烦一些。<code>rebase</code>前<code>experiment</code>处于<code>C4</code>节点，<code>rebase</code>后处于<code>C4'</code>节点。撤销<code>rebase</code>应该将<code>experiment</code>指针重新指向<code>C4</code>，通常可以使用<code>git reset --hard</code>指令。但此时<code>C4</code>已不被任何分支跟踪，所以在<code>IDEA</code>的分支可视化界面中，找不到指向<code>C4</code>的指针，也找不到<code>C4</code>的哈希码。此处提供两个解决方案：</p><ol type="1"><li><code>rebase</code>前，在<code>C4</code>状态建立新分支<code>backup</code></li><li>使用<code>git reflog</code>指令，查看指针的历史信息，在其中寻找<code>C4</code>的哈希码</li></ol><p>而在<code>merge</code>中，撤销就简单的多。因为<code>合并提交</code>指向被合并前的状态，可以在GUI中选取。</p><h3 id="idea中的rebase使用">IDEA中的rebase使用</h3><p>在开发完后，需要将代码rebase到主分支中。此时需要位于开发的<code>feature</code>分支，在分支界面中选取<strong>远程</strong>的<code>maseter</code>分支，选<strong>本地</strong>的可能会缺少最新的提交。当然也可以<code>pull</code>一下本地的<code>maseter</code>分支，再<code>rebase</code>到其上，但这样不优雅。选取后出现菜单如下。</p><figure><img src="/img/IDEA-rebase.png" alt="IDEA-rebase-远程分支" /><figcaption aria-hidden="true">IDEA-rebase-远程分支</figcaption></figure><p>其中有两个<code>rebase</code>相关的选项,<code>将A变基到B(Rebase Current onto Selected)</code>和<code>使用变基拉入A(Pull into Current Using Rebase)</code>。那么这两个选项有什么区别，<ahref="https://www.jetbrains.com/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch-onto-another-branch">官方文档</a>。</p><blockquote><ul><li>Rebase Current onto Selected (for both remote and local branches) torebase the branch that is currently checked out on top of theselected.</li><li>Pull into Current Using Rebase (for remote branches) to fetchchanges from the selected branch and rebase the current branch on top ofthese changes.</li></ul></blockquote><p>仔细一看好像没有什么区别。执行每个选项后，可以在<code>Git</code>选项卡的控制台中观察到实际执行的<code>git</code>指令，这两选项唯一的区别就是后者在rebase前会执行一次fetch，确保rebase时远程分支是最新状态。因此在实际开发中更建议使用后者。</p><h3 id="与cherry-pick对比">与cherry-pick对比</h3><p>如果使用了<code>git rebase --onto A C B</code>形式的指令，则其行为与<code>cherry-pick</code>很像。<code>cherry-pick</code>可以把某个或某些提交，在其他分支上进行重现。如果指定<code>rebase</code>指令中<code>C</code>和<code>B</code>是同一个，那行为就等同于选了一个提交的<code>cherry-pick</code>。</p><p>当然还是存在许多区别。简单的区别是<code>git rebase</code>指令中的<code>B</code>必须是<code>分支</code>，而<code>cherry-pick</code>的参数是<code>提交</code>。<code>rebase</code>会选取<code>B</code>和<code>C</code>之间连续的所有提交，而<code>cherry-pick</code>可以只选择其中一部分，且不要求连续。</p><h2 id="总结">总结</h2><p>合并分支常用两种方式<code>merge</code>和<code>rebase</code>。</p><p>相较于<code>merge</code>，<code>rebase</code>的优势在于不会新增<code>合并提交</code>，并且会使得整个<code>提交历史</code>更加简洁。但缺点是会修改<code>提交历史</code>导致撤销麻烦，并且指令相对merge更为复杂，不符合交换律。</p><p>想要撤销rebase恢复到之前的状态，由于修改了提交历史，需要通过<code>git reflog</code>指令找到修改前状态的哈希值，再通过<code>git reset</code>恢复。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Rebase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Relationships-Between-Objects</title>
    <link href="/2023/06/12/Design-Pattern-Relationships-Between-Objects/"/>
    <url>/2023/06/12/Design-Pattern-Relationships-Between-Objects/</url>
    
    <content type="html"><![CDATA[<p>最近半个月，结合视频和书籍，把<code>设计模式</code>反反复复看了好几遍。</p><p>编写<code>设计模式</code>的笔记和分享，确实具有一定难度。首先，<code>设计模式</code>本身是抽象的，是对实践经验的总结。这意味着，对于每个<code>设计模式</code>，并没有完全确定的规范，不同的人有着不同的经验，也会有不同的实现。所以<code>设计模式</code>本质是一种思想，是不同实现中的相同部分，而思想本身很难用文字来完整表述。其次，笔记很容易变成网络上已有资料的复制。因为从头思考每个概念，琢磨其间关系，设计表达，本身事件很麻烦的事情，为了偷懒就会去复制别人的表述。最后，笔者也不一定保证自己的理解是准确的。但在刚刚学习完，一定是印象最深刻的。所以趁此机会做下记录。</p><p><code>设计模式</code>是基于<code>面向对象编程(Object-Oriented Programming, OOP)</code>的。对于面向对象的思想和四大特性在此不赘述，直接从对象之间关系开始聊起。</p><h2 id="对象之间的关系">对象之间的关系</h2><p>对象/类之间（因为大部分类最后都会实例化，因此不加区分地使用类/对象）的关系包括：<code>实现</code>、<code>继承</code>、<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>。</p><p>值得一提的是，不同编程语言对于<code>OOP</code>的支持也不同，例如<code>Python</code>中要定义抽象类/接口，需要继承<code>ABC抽象基类</code>，而<code>Java</code>中可以通过<code>abstract class</code>来定义抽象类，通过<code>interface</code>来定义接口；<code>Java</code>中可以定义内部类，而<code>PHP</code>则不支持内部类。对象之间的关系是脱离于语言的，本文以<code>Java</code>为例，描述对象之间的关系在<code>Java</code>中的体现。</p><h3 id="继承和实现">继承和实现</h3><p><code>继承</code>和<code>实现</code>的特征比较明显，容易区分。</p><p><code>继承</code>通常描述两个类中，其中一个类可以复制另一个类的<code>属性/成员变量</code>和<code>方法</code>。</p><p>通常来说，<code>继承</code>是为了提高代码复用性。如果有A、B两个类，在他们的定义中，都有一些相同的属性和方法，那么可以将这部分属性和方法抽取到C类中，并将A、B类都<code>继承</code>自C，那么A、B就拥有了C中定义的属性和方法。如果修改C类，那么A、B类会相应发生变动。而A/B中，可以在C的基础上新增<code>属性</code>和<code>方法</code>，或者<code>重写</code>C中定义的<code>方法</code>，以此来区分C和A/B。C和A、B类的关系就是<code>继承</code>，称C为<code>父类</code>，A/B为<code>子类</code>。</p><p><code>实现</code>通常描述一个<code>类</code>实现了另一个<code>接口</code>的所有方法的过程。当一个<code>类</code>实现了一个<code>接口</code>时，它必须提供<code>接口</code>中定义的所有方法的具体实现。<code>接口</code>通常是一个特殊的<code>类</code>，不能包含<code>属性</code>、<code>构造方法</code>，且方法只有签名声明。</p><p><code>接口</code>通常定义不同对象间交互的规范，而<code>实现</code>则是提供规范的具体实施过程。如果有两个类A、B，在他们定义中，包含同名且功能类似但不完全相同的方法，则可以将这些同名函数抽取到一个<code>接口</code>C中，且只需声明函数签名即可。为了<code>实现</code>接口C，A/B必须提供C中声明的所有方法的具体代码。</p><p>从此处看，<code>实现</code>本身没有提供额外的功能，也没有降低代码的冗余度。但可以利用多态的动态性，降低代码的耦合度。可以将代码中对A、B类的引用，都改成对接口C的引用。接口C的引用，可以指向所有实现了接口C的一堆类。调用C中声明的方法时，会动态根据对象具体类型，调用对应的实现。通过改成对接口C的引用，使得用到A、B的地方，不仅仅局限于只能使用A/B。有一种接口变量类型是一堆具体类的集合感觉。</p><h3 id="依赖关联聚合组合">依赖、关联、聚合、组合</h3><p><code>依赖</code>也是容易区分的。因为其他所有的关系，都必然是<code>依赖</code>关系。如果修改一个类的定义可能会造成另一个类的变化，那么这两个类之间就存在<code>依赖</code>关系。</p><p>在一个类的代码中，只要见到了另一个类的代码，通常这两个类就是依赖关系。但不包含另一个类的代码，也可能是<code>依赖</code>关系，例如对象A依赖了对象B，而对象B依赖了对象C。根据定义，修改C的代码，可能会导致B的行为变动，从而引起对象A的变化。这样看大部分类之间都包含<code>依赖</code>关系。幸运的是，对于大部分的<code>依赖关系</code>我们不需要刻意关注。</p><p><code>关联</code>可视为一种特殊类型的<code>依赖</code>，即一个对象总是拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。</p><p>在<code>Java</code>中，方法形参、局部变量是存在于栈中，方法返回后，其引用就会随着弹出而销毁。因此这种关系通常是临时的，通常使用<code>依赖</code>描述。而<code>成员变量</code>，在对象整个生命周期、不同方法中，都可以访问，关系是永久性的，因此使用<code>关联</code>描述。</p><p>在<code>关联</code>中，又可以细分为<code>聚合</code>和<code>组合</code>。在许多教材中，<code>组合</code>是一种特殊的<code>聚合</code>，即<code>聚合</code>包含<code>组合</code>。但在实际术语使用中，<code>聚合</code>通常指<code>聚合</code>中不包含<code>组合</code>的那部分，因此通俗地说两者不是包含关系，而是并列互斥的关系。</p><p><code>关联</code>描述了一个对象A，通过成员变量的形式，拥有了另一个对象B的访问权限。在此基础上，如果对象A控制着对象B的生命周期，则A与B是<code>组合</code>关系，否则则是<code>聚合</code>关系。</p><p>常见的控制生命周期的形式，便是在构造函数中对成员变量进行实例化赋值，并且不提供<code>setter</code>方法。如此对象A在实例化时，便会完成对成员变量B的实例化，并且外部无法去替换成员变量的引用。对象A销毁时，由于全局不会再有对B的引用，B也会被销毁。<code>组合</code>体现出A和B“同生共死”的关系。</p><p>如果成员变量可以被外部替换，或者两者的生命周期可以不一致时，通常就是<code>聚合</code>关系。值得一提的是，<code>Spring</code>框架中，通过<code>@Autowired</code>注解自动注入的成员变量，通常是<code>聚合</code>关系，因为其生命周期不一致，被引用对象也可以作为其他对象的成员变量，并且也可以通过某些方式替换这些成员变量。</p><h2 id="总结">总结</h2><p>对象之间的关系包括<code>实现</code>、<code>继承</code>、<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>。</p><p>其中<code>实现</code>、<code>继承</code>容易区分和识别。</p><p><code>依赖</code>是最弱的关系表示，剩下五种关系都是<code>关联</code>关系。</p><p><code>关联</code>在<code>Java</code>中，通常使用成员变量来表示。他包含两种具体情况。如果两个对象同生共死，则为<code>组合关系</code>，否则则是<code>聚合</code>关系。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>DesignPattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Lazy-Initialization-PartII</title>
    <link href="/2023/05/26/SpringBoot-Lazy-Initialization-PartII/"/>
    <url>/2023/05/26/SpringBoot-Lazy-Initialization-PartII/</url>
    
    <content type="html"><![CDATA[<p>在<a href="/2023/05/04/SpringBoot-Lazy-Initialization/" title="SpringBoot-Lazy-Initialization">SpringBoot-Lazy-Initialization</a>提到，懒加载可以延迟容器中单实例的创建时机，从容器启动时延迟到实例被使用时。</p><p>在实际设置懒加载时，遇到了一些问题，在此记录并分析。</p><h2 id="静态方法访问">静态方法访问</h2><p>如果试图调用一个类的静态方法，而此方法依赖的静态变量需要通过实例去进行设置，启用全局懒加载就会导致<code>NPE（NullPointerException）</code>报错。</p><p>常见的场景是，编写一个<code>SpringContextUtil</code>工具类，用于从容器中根据条件（名称、类型）获取<code>bean</code>。<code>SpringContextUtil</code>通过实现<code>ApplicationContextAware</code>接口，来设置静态成员变量，并通过公共静态方法来向外暴露。一个典型的<code>SpringContextUtil</code>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringContextUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        applicationContext = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> &#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>SpringContextUtil</code>实例化时，通过<code>ApplicationContextAwareProcessor</code>后置处理器调用<code>setApplicationContext</code>方法，完成属性注入。具体的注入时机引用源代码注释。</p><blockquote><p>Invoked after population of normal bean properties but before an initcallback.</p></blockquote><p>问题在于，静态方法属于类，在懒加载的情况下，调用静态方法并不会引起类实例化，也因此不会对静态成员变量<code>applicationContext</code>进行设置，其值为引用类型的默认值<code>null</code>。此时调用静态方法<code>getBean</code>就会返回<code>NPE</code>。</p><p>解决的办法也很简单，就是将<code>SpringContextUtil</code>单独设置为非懒加载。由于<code>SpringContextUtil</code>是通过<code>@Component</code>注解，被组件扫描载入容器中，一种方法便是在<code>@ComponentScan</code>中设置<code>excludeFilters</code>属性。另一种更为简单优雅的做法是直接在<code>SpringContextUtil</code>类定义上添加<code>@lazy(false)</code>的注解。根据就近原则，会覆盖掉全局设置。</p><p>实际上<code>@lazy</code>有着很灵活的用法，可以添加在很多地方，在此不过多赘述。</p><h2 id="mybatis扫描懒加载">Mybatis扫描懒加载</h2><p>开启懒加载的另一种方式是通过设置<code>@ComponentScan</code>的<code>lazyInit</code>属性，将通过组件扫描载入的<code>bean</code>设置为懒加载。这么做是合理的。对于大型项目来说，通过组件扫描载入的<code>bean</code>数量远大于其他方式，而且是些影响范围较小的<code>bean</code>(相对于框架层)。这么设置可以较大程度加快程序启动，又尽可能避免了bug延迟暴露的问题。</p><p>但如此设置后，发现项目中的<code>Mybatis Mapper</code>并不会开启懒加载。研究后发现，<code>Mapper</code>扫描和组件扫描使用的并不是同一个扫描器。</p><p>查询<code>Mybatis</code>懒加载相关资料后，发现存在歧义。在<code>MyBatis</code>中，懒加载表示按需进行关联查询，这显然与<code>SpringBoot</code>中懒加载的含义不同。因此无法通过在<code>Mybatis</code>配置文件中，开启我们需要的<code>bean</code>懒加载功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>而<code>Mapper</code>扫描使用的是<code>ClassPathMapperScanner</code>。在<code>Mybatis</code>中，可以通过<code>@MapperScan</code>的<code>lazyInitialization</code>属性，设置<code>Mapper Bean</code>的懒加载。</p><p>但公司框架中使用的是<code>通用mapper</code>，<code>maven</code>坐标如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mapper&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>由于公司使用的<code>通用mapper</code>版本较早，仍未添加懒加载功能。新增懒加载的<ahref="https://github.com/abel533/Mapper/pull/874">PR</a>。</p><p>因此无法开启懒加载，只能使用全局懒加载。</p><h2 id="总结">总结</h2><p>在实际开发过程中，总会遇到预料之外的情况。调试、分析、学习的过程中积累的经验，远重要于解决问题本身。经过这次问题解决，对<code>Spring</code>、<code>Mybatis</code>框架的理解又更深入了一步。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Lazy Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven-compilation</title>
    <link href="/2023/05/17/Maven-compilation/"/>
    <url>/2023/05/17/Maven-compilation/</url>
    
    <content type="html"><![CDATA[<p>由于公司<code>Java</code>项目代码量庞大，使用<code>Maven</code>作为构建工具进行编译时，往往会花费较长时间。</p><p>进行代码测试时，修改一行代码，可能会引起整个项目重新编译。这是<code>Maven</code>的默认行为，一旦检测到代码变更，便重新编译改变文件对应的模块。但其实那些没有改动的代码，复用以前的编译结果即可。为此，引入了增量编译。</p><h2 id="增量编译">增量编译</h2><p>增量编译(Incremental Compilation)是指，只重新编译修改的代码文件。</p><p>大部分<code>Java</code>开发人员都使用<code>IDEA</code>作为<code>IDE</code>。<code>IDEA</code>自带的构建工具默认支持增量编译，<ahref="https://www.jetbrains.com/help/idea/compiling-applications.html#compile_module">官方文档</a>。</p><blockquote><p>When you change any class inside the build target and then executethe build action, IntelliJ IDEA performs the incremental build thatcompiles only the changed classes. IntelliJ IDEA also recursively buildsthe classes' dependencies.</p></blockquote><p><code>IDEA</code>还会进行依赖分析，以确定是否需要连带重新编译其他文件。</p><p>而<code>Maven</code>则默认不开启增量编译，<ahref="https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#optional-parameters">官方文档</a>。</p><blockquote><p>to enable/disable incremental compilation feature.</p><p>This leads to two different modes depending on the underlyingcompiler. The default javac compiler does the following:</p><ul><li>true <strong>(default)</strong> in this mode the compiler plugindetermines whether any JAR files the current module depends on havechanged in the current build run; or any source file was added, removedor changed since the last compilation. If this is the case, the compilerplugin recompiles all sources.</li><li>false <strong>(not recommended)</strong> this only compiles sourcefiles which are newer than their corresponding class files, namely whichhave changed since the last compilation. This does not recompile otherclasses which use the changed class, potentially leaving them withreferences to methods that no longer exist, leading to errors atruntime.</li></ul></blockquote><p><code>Maven</code>通过设置<code>&lt;useIncrementalcompilation&gt;</code>标签来控制增量编译行为。比较坑的地方是，选项的实际行为不符合常规理解。设置为<code>true</code>时，关闭增量编译，这是默认行为；设置为<code>false</code>时，开启增量编译。</p><p>根据官方文档，<code>Maven</code>会比较源文件(<code>.java</code>)和编译文件(<code>.class</code>)的时间戳。如果源文件的修改时间晚于编译文件，意味着上次编译后源文件发生了变动，文件需要重新编译。默认不推荐增量编译是因为<code>Maven</code>不会进行依赖检查，因此如果修改的位置删除了一个函数，而这个函数在别的源文件中被引用，会导致运行时出错。</p><h2 id="无文件变动">无文件变动</h2><p>无论是否开启增量编译，当所有源文件都没有发生改动时，编译并不会使任何文件重新编译。</p><p>Maven会有如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Maven">[INFO] Nothing to compile - all classes are up to date<br></code></pre></td></tr></table></figure><p>但在实际使用时，可能会出现一种情况：明明无文件变动，但导致了项目重新编译。这是因为项目代码中存在空文件。</p><p>空文件是指一个<code>.java</code>文件中，没有声明<code>public class</code>，使其并不会生成对应的<code>.class</code>文件。因此在进行时间戳对比时，会提示文件修改，导致项目重新编译。Maven提示如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Maven">[INFO] Changes detected - recompiling the module!<br></code></pre></td></tr></table></figure><p>这种情况一般发生在整个文件都被注释的情况。</p><h2 id="测试编译和跳过测试">测试编译和跳过测试</h2><p>在使用<code>Maven</code>进行<code>clean compile</code>后，运行单元测试，发现IDEA又将项目代码编译了一遍。由于未设置<strong>将IDE构建/运行操作委托给Maven</strong>，重新编译使用了<code>IDEA</code>原生构建工具。</p><p>研究后发现，<code>Maven</code>的<code>compile</code>阶段并不包括测试的编译，这可以从执行<code>mvn clean compile</code>命令后，<code>target</code>文件夹中并不会有<code>test-classes</code>文件夹生成可以看出。</p><p>因此在运行时，<code>IDEA</code>没有找到单元测试的<code>.class</code>文件，会再重新编译。</p><p>因此如果要编译整个项目，包括测试，需要使用<code>clean test</code>。但<code>test</code>阶段还默认绑定了单元测试运行，会将项目测试代码中带有<code>@Test</code>的方法都执行一遍，并生成测试报告。这也是日常开发不需要的，因此需要设置跳过测试运行。</p><p>如果去百度，可以搜到两条有关测试跳过的运行参数。</p><ul><li>-DskipTests</li><li>-Dmaven.test.skip=true</li></ul><p>这两条都可以跳过测试运行，区别是<code>-Dmaven.test.skip=true</code>还会额外跳过测试阶段，而<code>-DskipTests</code>只是跳过了测试阶段中的测试运行目标。</p><p>为了保证<code>Maven</code>编译完后可以直接运行单元测试，应该选择<code>-DskipTests</code>。</p><h2 id="总结">总结</h2><p><code>Maven</code>是最常用的构建工具，为了开启增量编译功能，需要在<code>pom</code>文件中将<code>compile</code>插件的<code>useIncrementalcompilation</code>属性设置为false。</p><p>如果希望<code>Maven</code>编译完后可以直接运行单元测试，需要至少使用<code>test</code>而不是<code>compile</code>。如果只希望编译测试代码，但跳过测试运行，需要设置运行参数<code>-DskipTests</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Incremental Compilation</tag>
      
      <tag>Test Compilation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Commit-Message</title>
    <link href="/2023/05/12/Git-Commit-Message/"/>
    <url>/2023/05/12/Git-Commit-Message/</url>
    
    <content type="html"><![CDATA[<p><code>Git</code>在<code>commit</code>时，必须输入<code>commit message</code>，来表示对提交内容的说明。没有则无法提交。</p><p>理论上，<code>commit message</code>可以输入任意内容。但如果参与多人协作开发和持续开发，就会有相应的规范，帮助程序员快速理解别人写的提交，或者回顾自己以前提交的作用。</p><p>目前应用最为广泛的规范是前端框架<code>Angular</code>提出的<ahref="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#-commit-message-format">Angular提交信息规范</a>（简称规范）。</p><h2 id="angular-commit-message-format">Angular Commit MessageFormat</h2><p>总的来说，规范要求，每次提交信息包含三部分。</p><p>1.信息头(<code>header</code>)</p><p>2.信息体(<code>body</code>)</p><p>3.信息尾(<code>footer</code>)</p><p>三个部分用空行间隔，来区分。其中<code>body</code>和<code>footer</code>为可选部分。</p><figure class="highlight plaintext"><figcaption><span>Message</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Commit">&lt;header&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><h3 id="header">header</h3><p>header是三个部分中最复杂的。包含三个区域<code>&lt;type&gt;</code>、<code>&lt;scope&gt;</code>和<code>&lt;short summary&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs header">&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;<br>  │       │             │<br>  │       │             └─⫸ Summary in present tense. Not capitalized. No period at the end.<br>  │       │<br>  │       └─⫸ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|<br>  │                          elements|forms|http|language-service|localize|platform-browser|<br>  │                          platform-browser-dynamic|platform-server|router|service-worker|<br>  │                          upgrade|zone.js|packaging|changelog|docs-infra|migrations|<br>  │                          devtools<br>  │<br>  └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|test<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;type&gt;</code>为必须项，所有可能的取值和意义如下。</p><blockquote><ul><li><strong>build</strong>: Changes that affect the build system orexternal dependencies (example scopes: gulp, broccoli, npm)</li><li><strong>ci</strong>: Changes to our CI configuration files andscripts (examples: CircleCi, SauceLabs)</li><li><strong>docs</strong>: Documentation only changes</li><li><strong>feat</strong>: A new feature</li><li><strong>fix</strong>: A bug fix</li><li><strong>perf</strong>: A code change that improves performance</li><li><strong>refactor</strong>: A code change that neither fixes a bugnor adds a feature</li><li><strong>test</strong>: Adding missing tests or correcting existingtests</li></ul></blockquote><p>其中用的最多的应该是<code>feat</code>、<code>fix</code>和<code>test</code>。</p><p><code>&lt;scope&gt;</code>为可选项，可能的取值人为规定，一般使用项目的某个模块名或业务名，用来表示提交的修改的影响范围。</p><p><code>&lt;short summary&gt;</code>为必须项。用一句话概括此次提交。此部分的要求如下。</p><blockquote><ul><li>use the imperative, present tense: "change" not "changed" nor"changes"</li><li>don't capitalize the first letter</li><li>no dot (.) at the end</li></ul></blockquote><p>这样子设置header的好处是，在查看<code>commit</code>历史记录时，可以选择只显示第一行内容。可以很快地理解每次提交的性质。</p><figure><img src="/img/commit-log.png" alt="commit-log" /><figcaption aria-hidden="true">commit-log</figcaption></figure><h3 id="body">body</h3><p>这一部分详细描述提交的内容，比如所做修改的动机，所做修改的思路，改动前后程序表现的对比。</p><p>规范相对于<code>header</code>来说很简单，仅仅是使用祈使句和现在时。</p><h3 id="footer">footer</h3><p>这一部分一般是使用Github时才会较多使用，主要用来引用提交所针对得<code>PR</code>或<code>issue</code>，另外也可以用来说明重大更改和弃用说明。</p><p>由于这一部分在公司内使用不多，大部分情况下为空即可，因此不过多介绍，详见<ahref="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#commit-message-footer">官方文档</a>。</p><h2 id="总结">总结</h2><p>使用<code>git commit</code>时需要输入<code>commit message</code>，目前最常用的规范是<code>AngularJS commit message format</code>。</p><p>此规范包含三部分，其中最重要的部分为<code>header</code>。<code>header</code>中需要指明修改的类型、影响的范围和简单的一句话概括。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Commit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Lazy-Initialization</title>
    <link href="/2023/05/04/SpringBoot-Lazy-Initialization/"/>
    <url>/2023/05/04/SpringBoot-Lazy-Initialization/</url>
    
    <content type="html"><![CDATA[<p>在<a href="/2023/04/13/SpringBoot-Testing/" title="SpringBoot-Testing">SpringBoot-Testing</a>提到，使用<code>Junit</code>测试<code>SpringBoot</code>项目时，需要使用<code>@SpringBootTest</code>来创建一个<code>Spring容器</code>。而当<code>@SpringBootTest</code>标注的测试类没有使用内嵌<code>@Configuration</code>注解时，会自动使用<code>@SpringBootConfiguration</code>上的配置。</p><blockquote><p>Automatically searches for a <span class="citation"data-cites="SpringBootConfiguration">@SpringBootConfiguration</span>when nested <span class="citation"data-cites="Configuration">@Configuration</span> is not used, and noexplicit classes are specified.</p></blockquote><h2id="springbootconfiguration"><code>@SpringBootConfiguration</code></h2><p><code>@SpringBootConfiguration</code>本身是一个合成注解，包含三个注解：</p><ol type="1"><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ol><p>其中，<code>@SpringBootConfiguration</code>本身也包含<code>@Configuration</code>，也就是可以在类中通过<code>@bean</code>注解往容器中添加<code>bean</code>。<code>@EnableAutoConfiguration</code>为自动配置功能，可以根据pom文件中的依赖，自动向容器中添加<code>bean</code>。<code>@ComponentScan</code>组件扫描在<a href="/2023/04/17/SpringBoot-Configuration/" title="SpringBoot-Configuration">SpringBoot-Configuration</a>已经阐述过。</p><p>测试往往只针对某个新写的方法，但默认的配置需要将整个应用程序环境都启动，会导致测试程序启动缓慢。一个很直观的解决方法就是使用自定义的配置类，而不是使用默认的主应用的程序环境。</p><h2 id="自定义配置类">自定义配置类</h2><p>前面提到<code>@SpringBootTest</code>标注如果带有内嵌<code>@Configuration</code>注解，则不会使用<code>@SpringBootConfiguration</code>上的配置。因此如果需要使用自定义配置类，需要在测试类上添加<code>@Configuration</code>或通过<code>@SpringBootTest</code>的<code>classes</code>属性指定自定义配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>内嵌自定义配置类需要定义在测试类中，并且使用<code>static</code>关键词修饰。</p><blockquote><p>static, non-private, non-final, nested classes annotated with <spanclass="citation" data-cites="Configuration">@Configuration</span></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = TestConfiguration.class)</span><br></code></pre></td></tr></table></figure><p>在自定义配置类中，可以如<a href="/2023/04/17/SpringBoot-Configuration/" title="SpringBoot-Configuration">SpringBoot-Configuration</a>中往容器中添加<code>bean</code></p><h2 id="懒加载">懒加载</h2><p>虽然Spring可以通过<code>Auto-configured Tests</code>和<code>@ComponentScan</code>来控制自动配置和包扫描规则，来避免不必要的bean导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;SomeExcludeClass.class&#125;)&#125;)</span><br></code></pre></td></tr></table></figure><p>但有时很难分清哪些被使用到，哪些没有被使用到，因为bean之间的依赖关系错综复杂。手动去控制自动配置规则和扫描规则太过繁琐。因此更直觉、简便的解决方法是使用懒加载。<ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.lazy-initialization">官方文档</a></p><blockquote><p><code>SpringApplication</code> allows an application to beinitialized lazily. When lazy initialization is enabled, beans arecreated as they are needed rather than during application startup. As aresult, enabling lazy initialization can reduce the time that it takesyour application to start.</p></blockquote><p>懒加载就是在<code>bean</code>被使用时才去实例化，而不是程序一启动就把所有的<code>bean</code>都实例化。因此可以加快程序的启动时间，但会增加用户使用时的延迟。</p><p>对于生产中的设备来说，启动时间（只启动一次，往往在半夜没用户使用时）、内存消耗是可以忽略的，但用户体验至关重要。因此生产实践中通常不开启懒加载。</p><blockquote><p>Lazy initialization can be enabled programmatically using the<code>lazyInitialization</code> method on<code>SpringApplicationBuilder</code> or the<code>setLazyInitialization</code> method on<code>SpringApplication</code>. Alternatively, it can be enabled usingthe <code>spring.main.lazy-initialization</code> property</p></blockquote><p>由于单元测试中容器是自动创建的，<code>lazyInitialization</code>和<code>setLazyInitialization</code>的方法无法执行，因此使用<code>application.properties</code>配置文件的方式是最简单优雅的。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.main.lazy-initialization</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>如果测试类需要使用独立的配置文件，可以在测试上使用<code>@TestPropertySource</code>注解来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestPropertySource(&quot;classpath:application-test.properties&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p><code>@SpringBootTest</code>标注的测试类，默认情况会使用<code>@SpringBootConfiguration</code>的环境设置。</p><p>如果需要使用自定义配置可以使用内嵌<code>@Configuration</code>或<code>@SpringBootTest</code>的<code>classes</code>属性。</p><p>懒加载是个加速程序启动的简单且有效方法。原理是将<code>bean</code>的实例化过程推迟到使用时才实例化。避免了测试过程中大部分<code>bean</code>都用不到，但会被实例化的问题。</p><p>在单元测试中，简单且优雅的方式是通过<code>application.properties</code>配置文件来开启懒加载。为了避免影响生产，通常采用测试独立的配置文件，并通过<code>@TestPropertySource</code>来指定。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Lazy Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Conflict</title>
    <link href="/2023/04/27/Git-Conflict/"/>
    <url>/2023/04/27/Git-Conflict/</url>
    
    <content type="html"><![CDATA[<p>最近在工作中频繁使用到了<code>Git</code>。虽然之前基本把<ahref="https://git-scm.com/book/en/v2">《ProGit》</a>读完了，但在实际使用中还是遇到不少问题。</p><p>究其原因，这可能因为国内的<code>Git</code>教程普遍基于命令行，并且只教最基础的使用。而大部分的开发人员往往使用集成在<code>IDE</code>中的<code>Git</code>，并且对于<code>Git</code>背后的原理和设计思路并不了解。</p><p>上一篇讲到当未<code>commit</code>的修改和将要进入的分支有<code>conflict</code>时，该怎么保存这些修改。这里将进入的分支可以是<code>checkout</code>到别的分支，或者是将要<code>update</code>、<code>rebase</code>、<code>merge</code>的分支。其中<code>checkout</code>引起的矛盾只有<code>IDE</code>才会发生，原生的命令行<code>Git</code>在那种情况下根本不允许<code>checkout</code>。但未详细说明什么是<code>conflict</code>，以及什么情况下会发生。</p><p>在<code>Git</code><ahref="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#_basic_merge_conflicts">官方文档</a>中，对于冲突只有一句简单的解释。</p><blockquote><p>If you changed the same part of the same file differently in the twobranches you’re merging, Git won’t be able to merge them cleanly.</p></blockquote><p>冲突发生在修改同一个文件同一个位置。同一个文件好理解，但修改是指什么，同一个位置又指什么？由于这部分内容实在未找到详细的文档，只能通过实验测试，来验证这两个到底指的什么意思。</p><h2 id="实验">实验</h2><p>实验设置很简单，初始化一个空的<code>Git</code>库，并在其中建立一个<code>txt</code>文本文件，通过进行不同的位置，不同类型的修改，观察是否触发<code>conflict</code>，来尝试找出其中规律。</p><p>修改的类型，主要是增加和删除两种，修改可以看作是删除和修改同时进行。</p><p>同一个位置，可以是同一光标，同一行，相邻行，或者间隔更大的行。</p><h3 id="修改类型初始化设置">修改类型初始化设置</h3><p>基于此，新建一个<code>ConflictTest.txt</code>文本文件，并初始化为如下。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br></code></pre></td></tr></table></figure><p><code>commit</code>后，新建分支<code>branch1</code>和<code>branch2</code>。</p><h3 id="同时增删">同时增删</h3><p>从直觉上讲，如果两个分支同时对一行代码进行了增加和删除，那么此时必然会发生冲突，因为两个分支上的改动是互相矛盾的，必须决定这些改动的去留。实验也证实了这一点。在实验中，一个分支将<strong>first</strong>删除，另一个分支在行末添加了<strong>.</strong>，并触发了<code>conflict</code>。结果也不会智能地合成<strong>Theline.</strong>。如果在同一行地不同位置进行了增删都会触发<code>conflict</code>，那在同一光标就更无疑问地会触发了。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">The line<br>===============<br>The first line.<br></code></pre></td></tr></table></figure><p>在提到智能地合成<strong>Theline.</strong>，其实默认了一种改动去留的规则，也就是将两个分支的改动都保留。而实际情况，根据对A，B分支改动的去留，共有四种情况。解决冲突的过程本质就是在决定，对于这些发生在同一位置的改动，是都留，都舍弃，还是只保留其中一侧的改动。</p><h3 id="同时删除">同时删除</h3><p>同时删除不同内容会触发<code>conflict</code>，而删除相同内容不会触发<code>conflict</code>，这也很符合直观理解。因为删除相同内容后，两个文件在这个位置地内容是完全相同的，不需要考虑改动的去留。</p><h3 id="同时增加">同时增加</h3><p>同时增加是有些争议的地方。添加相同内容不会触发冲突，这点原理和删除相同内容一样。但同时添加不同内容<code>Git</code>会如何处理就有些无法确定，<code>Git</code>是否会将两部分添加都保留。这种情况非常常见，例如两个人同时在代码文件最末尾添加了新的函数。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br>The second line 1<br>===============<br>The first line<br>The second line 2<br></code></pre></td></tr></table></figure><p>两个分支分别在文件末添加了不同的内容，实验结果触发了<code>conflict</code>。对于多人开发的场景，解决冲突的方式更多是将两个人的修改都保留。</p><h3 id="一侧改动另一侧没改动">一侧改动，另一侧没改动</h3><p>上面实验给人的感觉是，如果两个分支的文件内容不同，则发生冲突。但有一种情况两个文件不同时也会发生<code>conflict</code>。也就是当对一侧（分支）文件没有改动，另一侧没改动时。对此猜测，可能其中一侧的文件快照是另一侧的父/祖节点时（Git底层使用树的结构存储信息），则以更新的子节点为准。</p><p>为了验证这个猜测，对没改动的一侧进行了改动并提交，随后再进行一次改动，恢复初始状态并提交。此时原来没改动的一侧因为两次<code>commit</code>，文件的状态和另一侧不再是父/祖关系。此时合并两个分支，也没触发<code>conflict</code>。所以否定了两个文件不同时，父/祖关系可以避免<code>conflict</code>。</p><p>并且上面的测试，提交修改一次，再提交返回修改前状态，这也和矛盾最原始的定义有矛盾。即发生了同一文件同一位置的修改，但没<code>conflict</code>。</p><p>基于上述实验，本人猜测<code>Git</code>并不是对比了两个分支的文件，而是将两个文件和他们的共同祖先状态进行了对比。通过<code>diff</code>算法，计算了每个分支所做的修改。<code>Git</code>本身带有<code>diff</code>工具，但对其内部原理没有深究。通过对比两个分支的修改，如果修改发生在同一位置，那么则触发<code>conflict</code>。并且<code>IDE</code>提供的解决冲突的界面，三路合并，其中两路是两个分支的最新状态，另外一路是两个分支的共同祖先。这变相地也证明了对比的可能是两者从相同状态后，发生的差异。由于此部分内容没有查到详细资料，可能存在一定误解。</p><h3 id="修改位置初始化">修改位置初始化</h3><p>新建一个<code>ConflictTest.txt</code>文本文件，并初始化为如下。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br>The second line<br>The third line<br></code></pre></td></tr></table></figure><p><code>commit</code>后，新建分支<code>branch1</code>和<code>branch2</code>。</p><h3 id="修改位置">修改位置</h3><p>修改位置的实验相对简单。对其中一侧进行第一行修改，对另一侧进行第二/三行修改时，发生了不同结果（同一行已在之前测试）。第二行触发了<code>conflict</code>而第三行没有。如果简单点说，这样可能就把问题解决了，相同位置指的是相邻行。</p><p>但往复杂了说，怎么样定义相邻行。原本相邻的行，通过插入换行符，使得其不在相邻，再进行修改，这会引起冲突吗？</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line 1<br>The second line<br>The third line<br>===============<br>The first line<br><br><br>The second line 2<br>The third line<br></code></pre></td></tr></table></figure><p>答案是会。这可能因为差异是基于原祖先文件计算。一侧变动修改了第1行，另一侧变动修改了第2行，并且1行和2和之间插入了内容（空行）。这样看改动仍然发生在相邻行。</p><p>另外还有一种情况。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">branch1<br>The first line<br>The second line<br>The third line<br>===============<br>The first line<br>branch2<br>The second line<br>The third line<br></code></pre></td></tr></table></figure><p>此时在原来第1行之前、之后插入了内容。从某种程度上也算是相邻行，但没有触发<code>conflict</code>。所以说相邻行的解释也不够完备。</p><h2 id="总结">总结</h2><p><code>Git</code>在合并不同分支时，如果两个分支的同一文件状态不一致，则会计算其与共同祖先的差异。如果差异发生在相对于祖先文件的同一行或相邻行，则会引起<code>conflict</code>。</p><p>在解决冲突时，需要针对每个位置，决定是否舍弃和保留每个分支的改动。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Conflict</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Stash</title>
    <link href="/2023/04/19/Git-Stash/"/>
    <url>/2023/04/19/Git-Stash/</url>
    
    <content type="html"><![CDATA[<p>为了简化本地测试代码的过程，往往会对一些代码/配置进行修改。例如设置日志级别，开启Bean的懒加载，关闭一些不必要的服务。这些修改只发生在本地<code>工作区(Working Directory)</code>，不会<code>commit</code>到<code>本地仓库(Repository)</code>，更不会<code>push</code>到<code>远程仓库(Remote repositories)</code>。由于在<code>IDEA</code>中，默认没有启用<code>暂存区(Staging Area/Index)</code>，因此主要讨论的是<code>工作区</code>和<code>仓库</code>。</p><p>当<code>工作区</code>存在一些未<code>commit</code>的修改，并需要<code>checkout</code>到别的分支，并且这个分支也对被修改的文件做了其他修改，就会导致<code>冲突(conflict)</code>发生。</p><p>如果在<code>IDEA</code>中，发生了这样的冲突，则会不允许<code>checkout</code>。检查<code>IDEA</code>中的<code>git console</code>，错误信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: Your <span class="hljs-built_in">local</span> changes to the following files would be overwritten by checkout:<br>SomeFile.txt<br>Please commit your changes or stash them before you switch branches.<br>Aborting<br></code></pre></td></tr></table></figure><p>提示也十分明确，解决方法包括<code>commit</code>和<code>stash</code>。接下来就具体说明每一种方式是怎么解决的。</p><h2 id="commit">commit</h2><p>前面提到，这些修改本身是不想<code>commit</code>的，因为下次<code>push</code>时会默认将这个<code>commit</code>推送到远程仓库。实际情况中不会选择这种方案。</p><p>在<code>commit</code>之后，<code>工作区</code>、<code>本地仓库</code>就保持一致了，不存在未保存的信息。此时<code>checkout</code>到别的分支时没有任何报错。从别的分支再返回时，也能恢复这部分<code>工作区</code>修改。</p><p>如果需要在别的分支上也应用这部分修改，那么就需要合并分支，也就是<code>merge</code>和<code>rebase</code>。由于两个分支存在<code>冲突</code>，在合并时会需要先解决<code>冲突</code>。但这样做，在两个分支上都会有这部分修改的commit。</p><h2 id="stash">stash</h2><p><code>stash</code>是一个<code>git</code>命令，通过<code>stash</code>指令，可以将未提交的<code>工作区</code>和<code>暂存区</code>中的修改保存起来，并恢复到上一次<code>commit</code>的状态，像是将工作区<code>reset --hard</code>到了<code>HEAD</code>所指的版本。但修改部分的内容并没有丢失，像是有一个隐藏的临时<code>commit</code>。由于此时<code>工作区</code>和<code>本地仓库</code>保持一致，<code>checkout</code>到别的分支不会有任何问题。</p><p>在下次<code>checkout</code>回此分支时，可以通过<code>git stash pop</code>将<code>工作区</code>还原回之前的状态。像是<code>reset</code>回了之前的隐藏临时<code>commit</code>。如果在别的分支使用<code>git stash pop</code>，那么会发生<code>冲突</code>，但不会因此产生合并的<code>commit</code>。</p><h2 id="idea-shelve">IDEA Shelve</h2><p><code>IDEA</code>提供了一个功能上和<code>stash</code>几乎一样的<code>Shelve</code>。略微有些区别是stash默认操作整个<code>工作区</code>，而<code>Shelve</code>可以通过<code>GUI</code>选择单个文件或<code>Changelist</code>。<code>Changelist</code>是<code>IDEA</code>提供的将未提交修改分组的功能。</p><h2 id="总结">总结</h2><p>只有在<code>工作区</code>，<code>暂存区</code>和<code>版本库</code>一致时，也就是<code>working tree clean</code>时，才能<code>checkout</code>到别的分支。我们使用的<code>IDE</code>可以自动<code>stash</code>或<code>Shelve</code>，使得这三者不一致时也能<code>checkout</code>。但如果发生<code>冲突</code>，就需要手动解决<code>冲突</code>。</p><p>对于一些便于测试的代码/配置修改，相较于<code>commit</code>更推荐<code>stash</code>或<code>Shelve</code>。如果使用的是<code>IDEA</code>，那么更推荐<code>Shelve</code>，因为其提供了<code>GUI</code>，并且可以方便地指定暂存部分修改。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Stash</tag>
      
      <tag>Shelve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Configuration</title>
    <link href="/2023/04/17/SpringBoot-Configuration/"/>
    <url>/2023/04/17/SpringBoot-Configuration/</url>
    
    <content type="html"><![CDATA[<p>前面提到，对于<code>Spring</code>项目来说，项目的功能取决于<code>Spring容器</code>中有哪些<code>bean</code>，每一个<code>bean</code>都是一个功能模块的实例化对象。所以问题就来到了如何向<code>Spring容器</code>中添加<code>bean</code>。</p><h2 id="xml-配置文件">XML 配置文件</h2><p><code>XML配置文件</code>是最原始的添加<code>bean</code>的方式。使用<code>XML配置文件</code>符合了<code>配置文件分离</code>的原则。可以通过修改<code>XML配置文件</code>直接修改程序的功能，而不需要将项目重新编译。</p><p>在<code>XML配置文件</code>中通过<code>&lt;bean&gt;</code>标签来声明一个<code>bean</code>，并指定其类名、属性、依赖关系等信息，将该<code>bean</code>注册到<code>Spring</code>容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;anotherBean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此处定义了一个<code>bean</code>，为<code>com.example.MyBean</code>类的实例对象，其标识符通过<code>id</code>属性指定。通过<code>&lt;property&gt;</code>标签，可以对其成员变量进行属性注入。对于基础数据类型，可以直接使用<code>value</code>属性进行赋值；对于对象数据类型，可以使用<code>ref</code>属性进行引用，属性值为另一个容器中<code>bean</code>的<code>id</code>。也可以通过设置<code>bean</code>的<code>autowire</code>属性来指定是否采用自动注入。例如可以指定<code>autowire="byType"</code>来采用类型匹配自动注入。如果容器中符合成员变量类型的<code>bean</code>只有一个，那么就可以自动赋值。</p><p>启动时，通过指定<code>XML配置文件</code>，即可启动<code>Spring容器</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;configuration.xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>在定义<code>bean</code>时，还有许多可配置属性。但作为便于理解的笔记，这部分内容此处不再深入，可以在需要的时候去查相关文档。</p><ul><li><code>id</code>：指定 bean 的唯一标识符，用于在容器中进行引用。</li><li><code>class</code>：指定 bean 的类名，用于实例化 bean 对象。</li><li><code>scope</code>：指定 bean 的作用域，包括singleton（单例，默认值）、prototype（原型）、request（请求）、session（会话）等。</li><li><code>init-method</code>：指定 bean 初始化时调用的方法。</li><li><code>destroy-method</code>：指定 bean 销毁时调用的方法。</li><li><code>property</code>：用于设置 bean 的属性值。</li></ul><p>其中可以指定<code>bean</code>的初始化<code>init-method</code>和销毁方法<code>destroy-method</code>，这也是上篇提到的管理<code>bean</code>生命周期的功能。</p><h2 id="组件扫描">组件扫描</h2><p>如果需要往容器中添加一百个<code>bean</code>，那么需要在<code>XML配置文件</code>中写一百个<code>&lt;bean&gt;</code>标签，过程十分繁琐。实际项目中，需要添加到容器中的<code>bean</code>往往是自己写的<code>Java类</code>，这些<code>Java类</code>在<code>类路径</code>上通常有特点，例如处于某个包之下。指定某个<code>类路径/包</code>下的所有<code>Java类</code>都加入到<code>Spring容器中</code>这个想法就十分自然。这种批量添加<code>bean</code>的方式叫组件扫描。</p><p><code>XML配置文件</code>中开启组件扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用注解<code>@ComponentScan</code>开启组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages=&quot;com.example&quot;)</span><br></code></pre></td></tr></table></figure><p>组件扫描需要搭配<code>@Component</code>使用，这是一个类注解。只有扫描路径下带有<code>@Component</code>注解的类才会被添加到容器，没有的类则会被忽略。组件扫描<code>@ComponentScan</code>和<code>@Component</code>组合使用可以灵活地控制路径下哪些类会被添加入容器。</p><p>除了<code>@Component</code>，还可以通过设置<code>@ComponentScan</code>的<code>includeFilters</code>和<code>excludeFilters</code>属性，来灵活地自定义扫描路径下的过滤规则。</p><h2 id="配置类configuration">配置类@Configuration</h2><p><code>Java</code>的注解特性太过便捷，<code>Spring</code>项目逐渐从传统<code>XML配置文件</code>方式向注解方式迁移，这种大量依赖注解来配置和管理<code>Spring容器</code>中的<code>Bean</code>的方式叫<code>注解驱动</code>。</p><p>在<code>注解驱动</code>下，一个<code>XML配置文件</code>对应于一个带有<code>@Configuration</code>注解的<code>Java类</code>。<code>XML配置文件</code>中所有的标签，都有对应的定义方式。其中最重要的<code>&lt;bean&gt;</code>标签，在配置类中对应一个方法。这个方法会被添加<code>@bean</code>注解，并且要求返回一个<code>对象实例</code>或对象的<code>工厂bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回Bean的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要一提的是，配置类本身也是一个<code>bean</code>，存在于容器中。</p><p>基于单一职责原则，一般一个配置类往往只负责一类高度相关的功能。要开启某个功能往往就是把这个功能对应的配置类加入到容器中。配置类就会自动把功能相关的bean注册到容器中。</p><h2 id="importresource"><span class="citation"data-cites="ImportResource">@ImportResource</span></h2><p>实际项目开发中，可能会同时运用<code>XML配置文件</code>和<code>@Configuration配置类</code>。<code>配置类</code>作为主流的导入<code>bean</code>方式，那么就需要提供在其中引入<code>XML配置文件</code>的方法。<code>@ImportResource</code>就是这个作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(&quot;classpath:appCtx-dubbo.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在公司项目中，提供的对外Dubbo服务没有采用<code>配置类</code>的方式，而是将其写在了<code>XML配置文件</code>。通过在<code>XML文件</code>引入<code>xmlns:dubbo</code>，在文件内部可以使用dubbo提供的特定标签<code>&lt;dubbo:service&gt;</code>来注册服务。然后通过<code>@ImportResource("classpath:appCtx-dubbo.xml")</code>将生产者和消费者对应的<code>bean</code>加入到容器中。</p><h2 id="import"><span class="citation"data-cites="Import">@Import</span></h2><p>在Java配置类上使用<code>@Import</code>注解，将其他Java配置类引入当前配置类中，从而将这些配置类中定义的<code>Bean</code>一同注册到<code>Spring容器</code>中。<code>@Import</code>也能导入非配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;AnotherConfig.class, YetAnotherConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-comment">// 引入其他配置类中的Bean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相较于<code>@bean</code>的方式，<code>@Import</code>要简单很多。由于<code>@bean</code>注解在方法之上，可以通过编程式对每个<code>bean</code>进行细粒度的配置，而<code>@Import</code>就没法进行细粒度的控制。</p><p><code>@Import</code>通常也用于注解之上，使其变得更容易理解。例如<code>@Import(AspectJAutoProxyRegistrar.class)</code>就是<code>@EnableAspectJAutoProxy</code>上的注解。开启自动代理功能，本质就是导入了<code>AspectJAutoProxyRegistrar.class</code>注册器。注册器中，通过重载了<code>registerBeanDefinitions</code>的回调方法，向容器中动态注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>，从而开了<code>AspectJ</code>代理功能。相较于<code>@Import(AspectJAutoProxyRegistrar.class)</code>，<code>@EnableAspectJAutoProxy</code>更具有语义化。实际上，大部分的<code>@Enablexxx</code>本质都是利用了<code>@Import</code>导入了一些特殊的<code>bean</code>。</p><h2id="实现beanfactorypostprocessor接口">实现BeanFactoryPostProcessor接口</h2><p>这种方式作为用户不常用。一般作为开发者设计第三方库时的选择。</p><p>通过自定义一个实现了<code>BeanFactoryPostProcessor</code>接口的类，在其<code>postProcessBeanFactory()</code>方法中使用<code>BeanDefinitionRegistry</code>接口手动注册Bean到Spring容器中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 使用BeanDefinitionRegistry接口手动注册Bean</span><br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(MyBean.class);<br>        beanFactory.registerBeanDefinition(<span class="hljs-string">&quot;myBean&quot;</span>, beanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上还有<code>ImportBeanDefinitionRegistrar</code>。由于这部分内容找到的资料不多且良莠不齐，在此不深入讨论。</p><p>总的来说，这类方式是通过实现接口中预先定义的回调函数，在<code>Spring容器</code>启动过程的早期阶段会调用这些函数。在这些函数中，可以获取到<code>Spring容器</code>，并通过<code>Spring容器</code>的注册方法向其中注册自定义<code>bean</code>。</p><p>这部分内容令人感到困惑的原因是，<code>Spring容器</code>本身有多个接口和实现类，其中有许多都提供了注册方法。</p><h2 id="总结">总结</h2><p><code>Spring</code>应用的功能取决于其中的<code>bean</code>。向容器中添加/注册<code>bean</code>可以通过许多形式。其中最常用的是通过<code>@Configuration</code>的方式自定义配置类。结合<code>SpringBoot</code>的<code>AutoConfiguration</code>，可以很容易将各种应用集成到<code>Spring</code>中。由于<code>AutoConfiguration</code>内容太复杂，限于篇幅放到下一篇。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Testing</title>
    <link href="/2023/04/13/SpringBoot-Testing/"/>
    <url>/2023/04/13/SpringBoot-Testing/</url>
    
    <content type="html"><![CDATA[<p>在写上一篇<code>IoC</code>和<code>DI</code>之前，本来想记录的是<code>SpringBoot</code>如何完成<code>AutoConfiguration</code>自动配置，但因为篇幅直接分离出来了一篇。这次又把<code>Testing</code>给分离了出来。</p><p>事情的起因是，写项目代码时，常常需要对自己写的部分进行测试和调试。根据自己以往的编程经验，个人习惯于写一点就运行一点，并通过断点调试来确认内存的运行状态，避免犯一些低级的逻辑错误。虽然公司有专门的测试岗位，但从代码提交到GitLab请求合并，到部署到测试服务器，到测试人员设计用例并测试，到反馈到开发人员，整个过程涉及多个人员，太过漫长。而一些代码本身就需要反复调试，例如写了一些数据库操作，需要确认数据库实际执行结果是否符合预期。例如一个循环的跳出是否符合预期。执行结果符合预期本身是个很玄乎的事，很多时候代码看起来没啥问题，跑起来却又满脸问号。询问同事，都回答说让测试去测。而我觉得开发人员有义务确保代码没有低级的逻辑错误。</p><h2 id="junit">JUnit</h2><p>在<code>SpringBoot</code>框架中，常用的测试框架是<code>JUnit</code>。现在最新版本<code>SpringBoot3.0.5</code>对应的<code>Junit5</code>版本，<ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing">官方文档</a>。公司内部使用的是<code>Junit4</code>。</p><p>对于<code>JUnit</code>框架内部原理暂时没深入了解。从使用角度，常常会对需要测试的类，新生成一个对应的测试类，命名规范通常为<code>新测试类命 = 旧类命 + "Test"</code>。例如有一个<code>Calculator</code>类，那会新定义一个<code>CalculatorTest</code>测试类，并在测试类中定义成员测试方法，对应于被测试类中的方法。在每个成员方法中添加注解<code>@Test</code>，通过IDE或者构建工具就可以自动执行测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Addition方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtraction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Subtraction方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还可以编写其他测试方法...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在测试中，可以通过构建测试用例，并使用断言，将方法输出和预期输出进行对比。还可以使用代码覆盖率工具，来分析测试覆盖率。这些是<code>JUnit</code>核心功能，其他功能暂时还未深入了解。</p><h2 id="testing-in-springboot">Testing in SpringBoot</h2><p>在<code>SpringBoot</code>中，一个应用有什么功能，取决于在容器中有哪些<code>Bean</code>实例。例如我需要访问数据库，容器中必须要有<code>JDBC</code>相关的<code>Bean</code>，我需要处理<code>web</code>请求，容器中必须有<code>Tomcat</code>和<code>Sevlet</code>相关的<code>Bean</code>。</p><p>如果采用上文的方式去测试<code>Spring</code>项目中某个模块，那必然会报错。因为<code>JUnit</code>并不会像<code>Spring</code>一样启动，并将这些功能<code>Bean</code>添加到容器中。也就无法完成例如依赖注入等功能。</p><p>为了让<code>JUnit</code>能启动容器环境，<code>Spring</code>提供了<code>@SpringBootTest</code>注解。只需要在测试类前添加<code>@SpringBootTest</code>，就可以在测试时启动<code>Spring</code>容器。如果不指定注解的<code>classes</code>属性，也就是启动的配置类，那么会将主应用程序类，也就带有<code>@SpringBootApplication</code>注解的类作为配置类。</p><p>另外，如果使用的是<code>JUnit4</code>，还需要在测试类上额外添加<code>@RunWith(SpringRunner.class)</code>。需要这么做的原因涉及<code>JUnit</code>框架原理，在此不深究。</p><p>但问题是，使用<code>@SpringBootTest</code>注解时，会创建一个真实的<code>SpringBoot</code>上下文，并加载所有的<code>Bean</code>，这会导致测试的运行速度较慢。测试可能往往只是想测一个刚写完的某个方法，但却需要将许多不相关的<code>Bean</code>都加载进来，这会造成严重性能浪费。较长的测试启动时间也会大大降低测试时的主观感受。</p><p>要解决这个问题，就需要知道容器里的<code>Bean</code>是怎么样的方式被加载进去的，已经如何自定义加载需要的<code>Bean</code>，这也是下一篇要讨论的内容。</p><h2 id="总结">总结</h2><p><code>JUnit</code>是<code>Java</code>中最公认的测试框架。使用时只需要在测试类的测试方法上加<code>@Test</code>注解，即可对目标方法进行测试。在测试类中，可以使用许多功能并生成测试报告，来判断目标方法是否按照预期执行。</p><p>由于<code>JUnit</code>框架默认不会启动<code>Spring</code>容器，而<code>Spring</code>应用的功能依赖于<code>Spring</code>容器。因此直接使用<code>JUnit</code>测试<code>Spring</code>项目中的类会发生错误。可以使用<code>@SpringBootTest</code>在测试类中启动<code>Spring</code>容器环境。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-IoC-DI</title>
    <link href="/2023/04/13/SpringBoot-IoC-DI/"/>
    <url>/2023/04/13/SpringBoot-IoC-DI/</url>
    
    <content type="html"><![CDATA[<p>在讨论<code>Spring</code>框架时，其中最核心的组件莫过于<code>Spring Core</code>。而<code>Spring Core</code>完成了两个关键概念：<code>IoC</code>（Inversionof Control，控制反转）和<code>DI</code>（DependencyInjection，依赖注入）。</p><h2 id="ioc">IoC</h2><p><code>IoC</code>是一种设计模式，它将对象的创建和管理的控制从应用程序代码转移到了容器中。在Java当中，为了提高代码的复用率和可维护性，我们采用模块化编程，将功能相关的代码抽取成一个类/模块。在本文中，模块专指提供方法，被其他类调用的类，本身也是一个类；而模块的调用类就称为类。</p><p>如果不采用<code>IoC</code>，使用某个模块的方法时，需要通过<code>new</code>关键字创造对象，再调用其中的方法，或者通过模块类直接调用其中的静态方法。这样在代码中需要显示地创建对象。并且如果一个模块在多个类中被使用时，会被重复创建多次，造成性能浪费。如果采用单实例，则需要通过构造函数显示地将实例传递进来。这在一个模块被多个类使用，一个类会使用多个模块的情况下变得十分繁琐。</p><p>而在<code>IoC</code>模式下，所有类的实例都会由容器统一创建并管理。容器本身很像<code>HashMap</code>，可以通过类名/类型等作为<code>key</code>，从容器中获取到<code>value</code>实例对象。当需要在某个类中使用某个模块的方法，不再需要手动创建，而是直接从容器中获取已经创建好的实例对象。这就是<code>IoC</code>创建对象实例的功能。实际上<code>IoC</code>常还被用来解决对象之间的依赖关系、处理对象的生命周期等，在此不赘述。</p><p>从描述中可以发现，每个模块的实例化时机也发生了变化。本来是在每次将被访问时，<code>new</code>一个实例；而<code>IoC</code>一般是在程序启动时就将所有模块进行实例化并放入容器。但这本身也可以通过配置项进行修改。</p><h2 id="di">DI</h2><p>在上文介绍中，<code>IoC</code>管理了实例的创建，并将所创实例统一用一个容器进行管理访问。那么每当需要使用某个模块时，操作变成了从容器中获取实例，再调用实例的方法。当一个类中有多个方法都使用同一个实例，这个实例会在每个方法中都需要获取一次。因为方法内定义的是局部变量，方法运行结束就会出栈。为了简化开发，可以将用到的实例都设置为成员变量，这样实例的作用域扩大到整个类，所有成员方法都能使用。额外一提，将实例设置为成员变量，只会记录实例的指针/引用，并不会新建一个实例，因此其开销是可接受的。这种将某个实例赋值给成员变量的过程，叫依赖注入。</p><p>但问题还存在，每个成员变量的初始化该怎么操作。可以通过直接在声明时赋值、使用代码块初始化，或者通过构造函数初始化。但无论使用哪种方式，为每个成员变量显示地从容器中根据类名/类型获取实例的代码不可避免。实际情况中，大部分实例在容器中都是单实例模式的，这意味着根据成员变量的类型，在容器中有且仅能获取到一个。</p><p>为了简化开发，<code>Spring</code>提供了<code>@Autowire</code>注解。只需要在每个实例成员变量上添加这个注解，<code>Spring</code>就会在创建对象时，自动从容器中找到每个成员变量对应的单实例并赋值。这里也引出了新的问题，如果被引用的实例还没创建该怎么办，循环引用了该怎么办。这些问题可以单独再写一篇，在此略过。</p><h2 id="总结">总结</h2><p>通过<code>IoC</code>和<code>DI</code>，程序员的开发过程变成了：</p><ol type="1"><li>开发每个模块，并通过<code>IoC</code>将模块实例化并放到容器中。</li><li>在需要引用模块的地方，声明模块实例的成员变量，并通过<code>@Autowire</code>关键字实现<code>DI</code>。</li></ol><p>如果不使用<code>IoC</code>，那么程序员将难以知晓创建了多少实例，每个实例的状态，每个实例的生命周期。而<code>IoC</code>将创建的实例统一放在了容器当中，相当于提供了一个控制台，可以很容易的获取每个实例的信息。如果不使用<code>DI</code>，那么在每个类中调用某个模块的方法会十分繁琐。而通过<code>成员变量</code>+<code>DI</code>的模式，可以清楚地读到每个类依赖了哪些模块，并简化开发流程。</p><p>通过<code>IoC</code>和<code>DI</code>，整个过程的耦合度大大降低，基于这种模式的开发也成为了最佳实践。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-ConfigurationProperties</title>
    <link href="/2023/04/07/SpringBoot-ConfigurationProperties/"/>
    <url>/2023/04/07/SpringBoot-ConfigurationProperties/</url>
    
    <content type="html"><![CDATA[<p>写代码时，常会在代码中使用配置相关的常量。</p><p>对于这些配置常量，最佳实践是配置文件分离，即将这些配置常量写入一个配置文件中。常见的配置文件包括如properties、XML文件、JSON文件、YAML文件。这样每次修改配置时，不需要改动源文件并重新编译，也不需要通过命令行传参，只需改动配置文件中对应属性即可。而且把配置信息放在一起会使代码可读性，可维护性更好。</p><h2 id="java中的配置文件">Java中的配置文件</h2><p>Java的常用配置文件为properties文件。可以通过<code>FileInputStream</code>或<code>ClassLoader</code>来读取配置文件。并通过包装成<code>Properties</code>对象，来解析文件中的属性。由于Java的配置文件通常位于类路径下，因此使用<code>ClassLoader</code>来读取有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-comment">// 使用ClassLoader获取配置文件的输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getClassLoader().getResourceAsStream(fileName);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to find &quot;</span> + fileName + <span class="hljs-string">&quot; in classpath&quot;</span>);<br>    &#125;<br>    properties.load(inputStream);<br>    inputStream.close();<br>    <span class="hljs-keyword">return</span> properties;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后需要将配置文件中的属性赋值到Java类的字段上。这种配置文件和类字段映射的思想叫做<code>配置文件驱动开发</code>。</p><p>但在实际开发中，一整个项目的配置信息是十分多的。如果对于每一个配置属性都显式地赋值给一个类字段，那整个赋值过程会十分繁琐。因此需要一种方式，能将配置文件自动映射到类字段上。</p><h2 id="configurationproperties">ConfigurationProperties</h2><p>谈到Java开发就离不开Spring（SpringBoot）。Spring提供了许多常见且通用的功能和工具来简化Java 应用程序的开发，例如上文提到的配置文件的自动映射。</p><p>在Spring当中，如果需要将配置文件映射到某个类上，那么只需要在这个类上添加<code>@ConfigurationProperties</code>注解，并将这个类在Spring容器中实例化，Spring就会自动完成配置属性注入的功能。</p><p>具体实现时，通常有两种方式。</p><ol type="1"><li><p><code>@ConfigurationProperties</code> +<code>@Component</code></p></li><li><p><code>@ConfigurationProperties</code> +<code>@EnableConfigurationProperties</code></p></li></ol><p>其中<code>@ConfigurationProperties</code>加在需要配置属性注入的类上，并在注解中指定配置属性的前缀。并通过<code>@Component</code>将类加入到容器中。需要注意的是，通过这种方式需要确保在主配置类中开启了<code>@ComponentScan</code>，并且能扫描到此类。</p><p>而Spring的默认配置文件名为<code>application.properties</code>，且位于类路径的根目录下。这是Spring的<code>默认大于配置</code>软件设计原则。也就是如果没特殊情况，大家都遵守这样的约定。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">abc.name</span>=Tom<br><span class="hljs-attr">abc.version</span>=V1.<span class="hljs-number">1</span><br><span class="hljs-attr">logging.level.root</span>=info<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处定义了<code>MyConfiguration</code>类，并且包含两个字段<code>name</code>，<code>version</code>，字段名与配置文件中的属性键去掉前缀对应。并通过<code>@ConfigurationProperties(prefix = "abc")</code>注解指定了配置文件中的前缀，这样就可以在配置文件中通过前缀组织不同配置的属性。</p><p>或者，可以使用<code>@EnableConfigurationProperties</code>，添加在主配置类上，此时可以将属性注入的类上的<code>@Component</code>去掉，否则容器中会有两个<code>MyConfiguration</code>的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyConfig.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>@EnableConfigurationProperties</code>中指定需要开启属性注入功能的类。</p><p>但在实际过程中，出现了一些问题。</p><h2 id="遇到的问题">遇到的问题</h2><p>在实际学习过程中，属性注入一直失败。最后排查发现，对于属性注入的类，还需要配置Setter方法。这是因为配置属性注入，是通过Java反射，调用了对应的Setter方法。可以自行显示地定义Setter方法，或者使用<code>@Data</code>注解，自动生成类的Getter、Setter方法。</p><p>但在定义完Setter方法后，使用<code>@ConfigurationProperties</code> +<code>@Component</code>的方式配置属性注入依旧无法完成。通过对类属性打上断点，并查看调用栈，发现要使用这种方式完成配置属性注入，容器内必须要有<code>ConfigurationPropertiesBindingPostProcessor</code>。这是一个<code>BeanPostProcessor</code>，本质也是一个Bean，但和普通Bean的不同在于它可以参与Bean的实例化过程，以对其他Bean进行属性修改或功能增强。而在不使用<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>的最小配置启动下，默认没有向容器中导入这个<code>BeanPostProcessor</code>。</p><figure><img src="/img/ConfigurationPropertiesBindingPostProcessor.png"alt="ConfigurationPropertiesBindingPostProcessor" /><figcaptionaria-hidden="true">ConfigurationPropertiesBindingPostProcessor</figcaption></figure><p>并且在调用栈中，可以观察到最后是通过反射的方式，调用Setter方法来完成了配置属性注入。</p><figure><img src="/img/SetName.png" alt="SetName" /><figcaption aria-hidden="true">SetName</figcaption></figure><p>而使用<code>@ConfigurationProperties</code> +<code>@EnableConfigurationProperties</code>的方式则不需要<code>@EnableAutoConfiguration</code>配置项。通过调试发现，<code>@EnableConfigurationProperties</code>带有<code>@Import(EnableConfigurationPropertiesRegistrar.class)</code>注解，而<code>EnableConfigurationPropertiesRegistrar</code>在方法<code>registerBeanDefinitions</code>中，向容器中注册了<code>ConfigurationPropertiesBindingPostProcessor</code>，而后被实例化以提供配置属性注入的功能。</p><p>这一部分内容很涉及框架层面的内容，暂时不准备挖的更深。总之，<code>@EnableConfigurationProperties</code>本身就会向容器内导入<code>ConfigurationPropertiesBindingPostProcessor</code>，因此不需要<code>@EnableAutoConfiguration</code>也能完成配置属性注入工作。</p><h2 id="总结">总结</h2><p>配置文件分离是软件部署的最佳实践，熟悉其过程和原理也是每个程序员的必修课。在Spring框架中，使用<code>@ConfigurationProperties</code>来完成配置文件与类的绑定，在使用时需要指定每个类对应配置文件键的前缀。并把这个类放入容器中，以被<code>ConfigurationPropertiesBindingPostProcessor</code>完成属性注入的功能。而<code>ConfigurationPropertiesBindingPostProcessor</code>可以通过<code>@EnableAutoConfiguration</code>或<code>@EnableConfigurationProperties</code>导入。<code>ConfigurationPropertiesBindingPostProcessor</code>最终是通过Java反射完成属性注入，需要调用对应的Setter方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>ConfigurationProperties</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除/高亮页面元素的JS脚本</title>
    <link href="/2023/04/06/remove-highlight-javascript/"/>
    <url>/2023/04/06/remove-highlight-javascript/</url>
    
    <content type="html"><![CDATA[<p>最近开发了一个基于TamperMonkey的JS脚本，其主要功能为去除特定页面中的广告、Header等无效信息元素，并根据逻辑高亮其中重要信息元素。</p><p><a href="https://github.com/DracoYus/lolalytics-light">Github</a></p><p>从解决需求角度出发，常见的去除页面中的广告可以通过CSS植入，并利用样式选择器将广告元素的display属性设置为none。但需要根据逻辑高亮元素（如经过元素内文本排序后，对前n位进行高亮），简单的CSS植入无法满足这个需求。因此最后采用了TamperMonkey执行JS脚本的方案，利用JS操纵DOM元素来达到去除/高亮元素的目的。</p><p>目标页面采用了懒加载处理，可见范围外的元素不会提前加载。而TamperMonkey的内置执行时机，只能在页面开始加载或加载完成后执行一次。对于页面加载完成后，动态新加载的元素，无法完成功能。</p><table><thead><tr class="header"><th><span class="citation" data-cites="run-at">@run-at</span></th><th>Timing</th></tr></thead><tbody><tr class="odd"><td>document-start</td><td>as fast as possible</td></tr><tr class="even"><td>document-body</td><td>body element exists</td></tr><tr class="odd"><td>document-end</td><td>when or after the DOMContentLoaded event was dispatched</td></tr><tr class="even"><td>document-idle</td><td>after the DOMContentLoaded event was dispatched</td></tr><tr class="odd"><td>context-menu</td><td>it is clicked at the browser context menu</td></tr></tbody></table><p>由于页面的动态加载，需要多次执行目标函数。一种做法是，通过<code>setInterval</code>函数来指定目标函数每隔一段时间执行。这样的优点是编码简单，缺点是消耗系统资源，不太优雅。页面动态加载会导致DOM元素的增加或减少，因此更为优雅的做法是注册事件，当页面元素发生变化时，重新执行目标函数，这就用到了<code>MutationObserver</code>。</p><h2 id="mutationobserver">MutationObserver</h2><p><code>MutationObserver</code>可以检测页面元素属性变化、子节点的添加或删除、文本内容的变化等。</p><p><code>MutationObserver</code> 的使用步骤如下：</p><ol type="1"><li><p>创建一个 MutationObserver对象，传入一个回调函数作为参数，该回调函数将在 DOM树变化时被调用。在此问题中，callback就是去除/高亮页面元素的函数。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br></code></pre></td></tr></table></figure></p></li><li><p>使用 <code>observe</code> 方法开始监视 DOM元素的变化，传入要观察的 DOM 元素以及要观察的变化类型的配置对象。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">observer.<span class="hljs-title function_">observe</span>(target, options);<br></code></pre></td></tr></table></figure></p><p><code>target</code> 是要观察的 DOM元素，一般为<code>document.documentElement</code>，表示监视整个页面文档的元素变化。<code>options</code>是一个配置对象，用于指定要观察的变化类型。此处为<code>&#123;childList: true, subtree: true&#125;</code>，表示检测target以及其子节点的元素变化。如果不设置，默认只监测<code>target</code>本身，子节点的添加和减少不会被监测到。</p></li><li><p>在回调函数中处理 DOM 变化的情况。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">mutationsList, observer</span>) &#123;<br>  <span class="hljs-comment">// mutationsList 是一个 MutationRecord 对象的数组，包含了发生的 DOM 变化</span><br>  <span class="hljs-comment">// observer 是当前的 MutationObserver 对象</span><br><br>  <span class="hljs-comment">// 在这里处理 DOM 变化的情况</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>回调函数可以接收到发生变化的元素的信息。可以通过判断改变的是哪个元素，来具体执行去除/高亮的动作。在本项目中，为了偷懒并没有在此进行判断。</p></li></ol><h2 id="引发的问题">引发的问题</h2><p>在采用<code>MutationObserver</code>之后，页面出现了无法加载的情况。通过调试器查看到，目标函数被反复调用，整个页面陷入卡死的状态。猜测是页面元素发生变动，调用了目标函数后，目标函数也改变了页面元素（但是我的代码里没有啊？），反复触发了<code>MutationObserver</code>的目标函数，形成了递归死循环。为了解决这个问题，了解了函数防抖和函数节流。</p><h2 id="函数防抖和函数节流">函数防抖和函数节流</h2><p>函数防抖和函数节流都是用于限制某个函数的执行频率。如果函数调用的频率小于设定的阈值，那么是否采用函数防抖和函数节流对程序执行没有任何区别。</p><p>防抖的基本思想是在一定的时间间隔内，只执行最后一次触发事件的处理函数，忽略在此时间间隔内的其他触发事件。与函数防抖不同，函数节流是在一定的时间间隔内，定期执行事件处理函数。</p><p>函数防抖就像拍卖，拍卖成功（目标函数执行）会在敲三锤（一定间隔后）执行，一旦在敲三锤前进行了竞拍（再次调用用防抖包裹的目标函数），那么间隔会被重置。</p><p>函数节流就像大学抢浴室。一个人进了浴室（调用用节流包裹的目标函数），其他人再想进去（再次调用用节流包裹的目标函数）就不行，必须等这个人洗完（一定间隔），一旦他洗完（目标函数执行），所有人都可以再次抢浴室（调用用节流包裹的目标函数）。从某种角度，这和锁机制很像，被上锁的对象为计时器。只有获得计时器的调用才会被真正执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId; <span class="hljs-comment">// 记录定时器的ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 如果已存在定时器，则先清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timerId) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    <span class="hljs-comment">// 创建新的定时器，延迟执行 func 函数</span><br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行 func 函数</span><br>      timerId = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空定时器ID</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123; <span class="hljs-comment">// 判断当前时间与上次执行的时间间隔是否超过指定的等待时间</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>      lastTime = now; <span class="hljs-comment">// 更新上次执行的时间戳</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖和节流都能限制函数被调用的频率，区别是什么时候能再次被调用，防抖是从多次小于设定间隔的连续调用的最后一次开始计算，而节流是从第一次调用开始计算，因此相同条件下，节流可以更快地进行第二次有效调用。</p><p>总的来说，函数防抖适合在需要等待一段时间后再执行函数的场景。如果目标函数不需要等待可以立即执行，则使用节流即可。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TamperMonKey</tag>
      
      <tag>MutationObserver</tag>
      
      <tag>函数防抖</tag>
      
      <tag>函数节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
