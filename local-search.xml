<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot-Testing</title>
    <link href="/2023/04/13/SpringBoot-Testing/"/>
    <url>/2023/04/13/SpringBoot-Testing/</url>
    
    <content type="html"><![CDATA[<p>在写上一篇<strong>IoC</strong>和<strong>DI</strong>之前，本来想记录的是<strong>SpringBoot</strong>如何完成<strong>AutoConfiguration</strong>自动配置，但因为篇幅直接分离出来了一篇。这次又把<strong>Testing</strong>给分离了出来。</p><p>事情的起因是，写项目代码时，常常需要对自己写的部分进行测试和调试。根据自己以往的编程经验，个人习惯于写一点就运行一点，并通过断点调试来确认内存的运行状态，避免犯一些低级的逻辑错误。虽然公司有专门的测试岗位，但从代码提交到GitLab请求合并，到部署到测试服务器，到测试人员设计用例并测试，到反馈到开发人员，整个过程涉及多个人员，太过漫长。而一些代码本身就需要反复调试，例如写了一些数据库操作，需要确认数据库实际执行结果是否符合预期。例如一个循环的跳出是否符合预期。执行结果符合预期本身是个很玄乎的事，很多时候代码看起来没啥问题，跑起来却又满脸问号。询问同事，都回答说让测试去测。而我觉得开发人员有义务确保代码没有低级的逻辑错误。</p><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>在<strong>SpringBoot</strong>框架中，常用的测试框架是<strong>JUnit</strong>。现在最新版本<strong>SpringBoot3.0.5</strong>对应的<strong>Junit5</strong>版本，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing">官方文档</a>。公司内部使用的是<strong>Junit4</strong>。</p><p>对于<strong>JUnit</strong>框架内部原理暂时没深入了解。从使用角度，常常会对需要测试的类，新生成一个对应的测试类，命名规范通常为 <strong>新测试类命 &#x3D; 旧类命 + “Test”<strong>。例如有一个</strong>Calculator</strong>类，那会新定义一个<strong>CalculatorTest</strong>测试类，并在测试类中定义成员测试方法，对应于被测试类中的方法。在每个成员方法中添加注解<strong>@Test</strong>，通过IDE或者构建工具就可以自动执行测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Addition方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtraction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Subtraction方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还可以编写其他测试方法...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在测试中，可以通过构建测试用例，并使用断言，将方法输出和预期输出进行对比。还可以使用代码覆盖率工具，来分析测试覆盖率。这些是<strong>JUnit</strong>核心功能，其他功能暂时还未深入了解。</p><h2 id="Testing-in-SpringBoot"><a href="#Testing-in-SpringBoot" class="headerlink" title="Testing in SpringBoot"></a>Testing in SpringBoot</h2><p>在<strong>SpringBoot</strong>中，一个应用有什么功能，取决于在容器中有哪些<strong>Bean</strong>实例。例如我需要访问数据库，容器中必须要有<strong>JDBC</strong>相关的<strong>Bean</strong>，我需要处理<strong>web</strong>请求，容器中必须有<strong>Tomcat</strong>和<strong>Sevlet</strong>相关的<strong>Bean</strong>。</p><p>如果采用上文的方式去测试<strong>Spring</strong>项目中某个模块，那必然会报错。因为<strong>JUnit</strong>并不会像<strong>Spring</strong>一样启动，并将这些功能<strong>Bean</strong>添加到容器中。也就无法完成例如依赖注入等功能。</p><p>为了让<strong>JUnit</strong>能启动容器环境，<strong>Spring</strong>提供了<strong>@SpringBootTest</strong>注解。只需要在测试类前添加<strong>@SpringBootTest</strong>，就可以在测试时启动<strong>Spring</strong>容器。如果不指定注解的<strong>classes</strong>属性，也就是启动的配置类，那么会将主应用程序类，也就带有<strong>@SpringBootApplication</strong>注解的类作为配置类。</p><p>另外，如果使用的是<strong>JUnit4</strong>，还需要在测试类上额外添加<strong>@RunWith(SpringRunner.class)<strong>。需要这么做的原因涉及</strong>JUnit</strong>框架原理，在此不深究。</p><p>但问题是，使用<strong>@SpringBootTest</strong>注解时，会创建一个真实的<strong>SpringBoot</strong>上下文，并加载所有的<strong>Bean</strong>，这会导致测试的运行速度较慢。测试可能往往只是想测一个刚写完的某个方法，但却需要将许多不相关的<strong>Bean</strong>都加载进来，这会造成严重性能浪费。较长的测试启动时间也会大大降低测试时的主观感受。</p><p>要解决这个问题，就需要知道容器里的<strong>Bean</strong>是怎么样的方式被加载进去的，已经如何自定义加载需要的<strong>Bean</strong>，这也是下一篇要讨论的内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>JUnit</strong>是<strong>Java</strong>中最公认的测试框架。使用时只需要在测试类的测试方法上加<strong>@Test</strong>注解，即可对目标方法进行测试。在测试类中，可以使用许多功能并生成测试报告，来判断目标方法是否按照预期执行。</p><p>由于<strong>JUnit</strong>框架默认不会启动<strong>Spring</strong>容器，而<strong>Spring</strong>应用的功能依赖于<strong>Spring</strong>容器。因此直接使用<strong>JUnit</strong>测试<strong>Spring</strong>项目中的类会发生错误。可以使用<strong>@SpringBootTest</strong>在测试类中启动<strong>Spring</strong>容器环境。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-IoC-DI</title>
    <link href="/2023/04/13/SpringBoot-IoC-DI/"/>
    <url>/2023/04/13/SpringBoot-IoC-DI/</url>
    
    <content type="html"><![CDATA[<p>在讨论<strong>Spring</strong>框架时，其中最核心的组件莫过于 <strong>Spring Core</strong>。而<strong>Spring Core</strong>完成了两个关键概念：<strong>IoC</strong>（Inversion of Control，控制反转）和<strong>DI</strong>（Dependency Injection，依赖注入）。</p><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><strong>IoC</strong>是一种设计模式，它将对象的创建和管理的控制从应用程序代码转移到了容器中。在Java当中，为了提高代码的复用率和可维护性，我们采用模块化编程，将功能相关的代码抽取成一个类&#x2F;模块。在本文中，模块专指提供方法，被其他类调用的类，本身也是一个类；而模块的调用类就称为类。</p><p>如果不采用<strong>IoC</strong>，使用某个模块的方法时，需要通过<strong>new</strong>关键字创造对象，再调用其中的方法，或者通过模块类直接调用其中的静态方法。这样在代码中需要显示地创建对象。并且如果一个模块在多个类中被使用时，会被重复创建多次，造成性能浪费。如果采用单实例，则需要通过构造函数显示地将实例传递进来。这在一个模块被多个类使用，一个类会使用多个模块的情况下变得十分繁琐。</p><p>而在<strong>IoC</strong>模式下，所有类的实例都会由容器统一创建并管理。容器本身很像<strong>HashMap</strong>，可以通过类名&#x2F;类型等作为<strong>key</strong>，从容器中获取到<strong>value</strong>实例对象。当需要在某个类中使用某个模块的方法，不再需要手动创建，而是直接从容器中获取已经创建好的实例对象。这就是<strong>IoC</strong>创建对象的实例功能。实际上<strong>IoC</strong>常还被用来解决对象之间的依赖关系、处理对象的生命周期等，在此不赘述。</p><p>从描述中可以读到，每个模块的实例化时机也发生了变化。本来是在每次将被访问时，<strong>new</strong>一个实例；而<strong>IoC</strong>一般是在程序启动时就将所有模块进行实例化并放入容器。但这本身也可以通过配置项进行修改。</p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>在上文介绍中，<strong>IoC</strong>管理了实例的创建，并将所创实例统一用一个容器进行管理访问。那么每当需要使用某个模块时，操作变成了从容器中获取实例，再调用实例的方法。当一个类中有多个方法都使用同一个实例，这个实例会在每个方法中都需要获取一次。因为方法内定义的是局部变量，方法运行结束就会出栈。为了简化开发，可以将用到的实例都设置为成员变量，这样实例的作用域扩大到整个类，所有成员方法都能使用。额外一提，将实例设置为成员变量，只会记录实例的指针&#x2F;引用，并不会新建一个实例，因此其开销是可接受的。这种将某个实例赋值给成员变量的过程，叫依赖注入。</p><p>但问题还存在，每个成员变量的初始化该怎么操作。可以通过直接在声明时赋值、使用代码块初始化，或者通过构造函数初始化。但无论使用哪种方式，为每个成员变量显示地从容器中根据类名&#x2F;类型获取实例的代码不可避免。实际情况中，大部分实例在容器中都是单实例模式的，这意味着根据成员变量的类型，在容器中有且仅能获取到一个。</p><p>为了简化开发，<strong>Spring</strong>提供了 <strong>@Autowire</strong>注解。只需要在每个实例成员变量上添加这个注解，<strong>Spring</strong>就会在创建对象时，自动从容器中找到每个成员变量对应的单实例并赋值。这里也引出了新的问题，如果被引用的实例还没创建该怎么办，循环引用了该怎么办。这些问题可以单独再写一篇，再次略过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<strong>IoC</strong>和<strong>DI</strong>，程序员的开发过程变成了：</p><ol><li>开发每个模块，并通过<strong>IoC</strong>将模块实例化并放到容器中。</li><li>在需要引用模块的地方，声明模块实例的成员变量，并通过 <strong>@Autowire</strong>关键字实现<strong>DI</strong>。</li></ol><p>如果不使用<strong>IoC</strong>，那么程序员将难以知晓创建了多少实例，每个实例的状态，每个实例的生命周期。而<strong>IoC</strong>将创建的实例统一放在了容器当中，相当于提供了一个控制台，可以很容易的获取每个实例的信息。如果不使用<strong>DI</strong>，那么在每个类中调用某个模块的方法会十分繁琐。而通过<strong>成员变量</strong> + <strong>DI</strong>的模式，可以清楚地读到每个类依赖了哪些模块，并简化开发流程。</p><p>通过<strong>IoC</strong>和<strong>DI</strong>，整个过程的耦合度大大降低，基于这种模式的开发也成为了最佳实践。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-ConfigurationProperties</title>
    <link href="/2023/04/07/SpringBoot-ConfigurationProperties/"/>
    <url>/2023/04/07/SpringBoot-ConfigurationProperties/</url>
    
    <content type="html"><![CDATA[<p>写代码时，常会在代码中使用配置相关的常量。</p><p>对于这些配置常量，最佳实践是配置文件分离，即将这些配置常量写入一个配置文件中。常见的配置文件包括如properties、XML文件、JSON文件、YAML文件。这样每次修改配置时，不需要改动源文件并重新编译，也不需要通过命令行传参，只需改动配置文件中对应属性即可。而且把配置信息放在一起会使代码可读性，可维护性更好。</p><h2 id="Java中的配置文件"><a href="#Java中的配置文件" class="headerlink" title="Java中的配置文件"></a>Java中的配置文件</h2><p>Java的常用配置文件为properties文件。可以通过<code>FileInputStream</code>或<code>ClassLoader</code>来读取配置文件。并通过包装成<code>Properties</code>对象，来解析文件中的属性。由于Java的配置文件通常位于类路径下，因此使用<code>ClassLoader</code>来读取有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-comment">// 使用ClassLoader获取配置文件的输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getClassLoader().getResourceAsStream(fileName);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to find &quot;</span> + fileName + <span class="hljs-string">&quot; in classpath&quot;</span>);<br>    &#125;<br>    properties.load(inputStream);<br>    inputStream.close();<br>    <span class="hljs-keyword">return</span> properties;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后需要将配置文件中的属性赋值到Java类的字段上。这种配置文件和类字段映射的思想叫做<strong>配置文件驱动开发</strong>。</p><p>但在实际开发中，一整个项目的配置信息是十分多的。如果对于每一个配置属性都显式地赋值给一个类字段，那整个赋值过程会十分繁琐。因此需要一种方式，能将配置文件自动映射到类字段上。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="ConfigurationProperties"></a>ConfigurationProperties</h2><p>谈到Java开发就离不开Spring（SpringBoot）。Spring提供了许多常见且通用的功能和工具来简化 Java 应用程序的开发，例如上文提到的配置文件的自动映射。</p><p>在Spring当中，如果需要将配置文件映射到某个类上，那么只需要在这个类上添加<code>@ConfigurationProperties</code>注解，并将这个类在Spring容器中实例化，Spring就会自动完成配置属性注入的功能。</p><p>具体实现时，通常有两种方式。</p><ol><li><p><code>@ConfigurationProperties</code> + <code>@Component</code> </p></li><li><p><code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code></p></li></ol><p>其中<code>@ConfigurationProperties</code> 加在需要配置属性注入的类上，并在注解中指定配置属性的前缀。并通过<code>@Component</code> 将类加入到容器中。需要注意的是，通过这种方式需要确保在主配置类中开启了<code>@ComponentScan</code>，并且能扫描到此类。</p><p>而Spring的默认配置文件名为<code>application.properties</code>，且位于类路径的根目录下。这是Spring的<strong>默认大于配置</strong>软件设计原则。也就是如果没特殊情况，大家都遵守这样的约定。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">abc.name</span>=Tom<br><span class="hljs-attr">abc.version</span>=V1.<span class="hljs-number">1</span><br><span class="hljs-attr">logging.level.root</span>=info<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处定义了<code>MyConfiguration</code>类，并且包含两个字段<code>name</code>，<code>version</code>，字段名与配置文件中的属性键去掉前缀对应。并通过<code>@ConfigurationProperties(prefix = &quot;abc&quot;)</code>注解指定了配置文件中的前缀，这样就可以在配置文件中通过前缀组织不同配置的属性。</p><p>或者，可以使用<code>@EnableConfigurationProperties</code>，添加在主配置类上，此时可以将属性注入的类上的<code>@Component</code>去掉，否则容器中会有两个<code>MyConfiguration</code>的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyConfig.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>@EnableConfigurationProperties</code>中指定需要开启属性注入功能的类。</p><p>但在实际过程中，出现了一些问题。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在实际学习过程中，属性注入一直失败。最后排查发现，对于属性注入的类，还需要配置Setter方法。这是因为配置属性注入，是通过Java反射，调用了对应的Setter方法。可以自行显示地定义Setter方法，或者使用<code>@Data</code>注解，自动生成类的Getter、Setter方法。</p><p>但在定义完Setter方法后，使用<code>@ConfigurationProperties</code> + <code>@Component</code>的方式配置属性注入依旧无法完成。通过对类属性打上断点，并查看调用栈，发现要使用这种方式完成配置属性注入，容器内必须要有<code>ConfigurationPropertiesBindingPostProcessor</code>。这是一个<code>BeanPostProcessor</code>，本质也是一个Bean，但和普通Bean的不同在于它可以参与Bean的实例化过程，以对其他Bean进行属性修改或功能增强。而在不使用<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>的最小配置启动下，默认没有向容器中导入这个<code>BeanPostProcessor</code>。</p><p><img src="/img/ConfigurationPropertiesBindingPostProcessor.png" alt="ConfigurationPropertiesBindingPostProcessor"></p><p>并且在调用栈中，可以观察到最后是通过反射的方式，调用Setter方法来完成了配置属性注入。</p><p><img src="/img/SetName.png" alt="SetName"></p><p>而使用<code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code> 的方式则不需要<code>@EnableAutoConfiguration</code>配置项。通过调试发现，<code>@EnableConfigurationProperties</code> 带有<code>@Import(EnableConfigurationPropertiesRegistrar.class)</code>注解，而<code>EnableConfigurationPropertiesRegistrar</code>在方法<code>registerBeanDefinitions</code>中，向容器中注册了<code>ConfigurationPropertiesBindingPostProcessor</code>，而后被实例化以提供配置属性注入的功能。</p><p>这一部分内容很涉及框架层面的内容，暂时不准备挖的更深。总之，<code>@EnableConfigurationProperties</code> 本身就会向容器内导入<code>ConfigurationPropertiesBindingPostProcessor</code>，因此不需要<code>@EnableAutoConfiguration</code>也能完成配置属性注入工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置文件分离是软件部署的最佳实践，熟悉其过程和原理也是每个程序员的必修课。在Spring框架中，使用<code>@ConfigurationProperties</code> 来完成配置文件与类的绑定，在使用时需要指定每个类对应配置文件键的前缀。并把这个类放入容器中，以被<code>ConfigurationPropertiesBindingPostProcessor</code>完成属性注入的功能。而<code>ConfigurationPropertiesBindingPostProcessor</code>可以通过<code>@EnableAutoConfiguration</code>或<code>@EnableConfigurationProperties</code>导入。<code>ConfigurationPropertiesBindingPostProcessor</code>最终是通过Java反射完成属性注入，需要调用对应的Setter方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>ConfigurationProperties</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除/高亮页面元素的JS脚本</title>
    <link href="/2023/04/06/remove-highlight-javascript/"/>
    <url>/2023/04/06/remove-highlight-javascript/</url>
    
    <content type="html"><![CDATA[<p>最近开发了一个基于TamperMonkey的JS脚本，其主要功能为去除特定页面中的广告、Header等无效信息元素，并根据逻辑高亮其中重要信息元素。</p><p><a href="https://github.com/DracoYus/lolalytics-light">Github</a></p><p>从解决需求角度出发，常见的去除页面中的广告可以通过CSS植入，并利用样式选择器将广告元素的display属性设置为none。但需要根据逻辑高亮元素（如经过元素内文本排序后，对前n位进行高亮），简单的CSS植入无法满足这个需求。因此最后采用了TamperMonkey执行JS脚本的方案，利用JS操纵DOM元素来达到去除&#x2F;高亮元素的目的。</p><p>目标页面采用了懒加载处理，可见范围外的元素不会提前加载。而TamperMonkey的内置执行时机，只能在页面开始加载或加载完成后执行一次。对于页面加载完成后，动态新加载的元素，无法完成功能。</p><table><thead><tr><th>@run-at</th><th>Timing</th></tr></thead><tbody><tr><td>document-start</td><td>as fast as possible</td></tr><tr><td>document-body</td><td>body element exists</td></tr><tr><td>document-end</td><td>when or after the DOMContentLoaded event was dispatched</td></tr><tr><td>document-idle</td><td>after the DOMContentLoaded event was dispatched</td></tr><tr><td>context-menu</td><td>it is clicked at the browser context menu</td></tr></tbody></table><p>由于页面的动态加载，需要多次执行目标函数。一种做法是，通过<code>setInterval</code>函数来指定目标函数每隔一段时间执行。这样的优点是编码简单，缺点是消耗系统资源，不太优雅。页面动态加载会导致DOM元素的增加或减少，因此更为优雅的做法是注册事件，当页面元素发生变化时，重新执行目标函数，这就用到了<code>MutationObserver</code>。</p><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p><code>MutationObserver</code>可以检测页面元素属性变化、子节点的添加或删除、文本内容的变化等。</p><p><code>MutationObserver</code> 的使用步骤如下：</p><ol><li><p>创建一个 MutationObserver 对象，传入一个回调函数作为参数，该回调函数将在 DOM 树变化时被调用。在此问题中，callback就是去除&#x2F;高亮页面元素的函数。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>observe</code> 方法开始监视 DOM 元素的变化，传入要观察的 DOM 元素以及要观察的变化类型的配置对象。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">observer.<span class="hljs-title function_">observe</span>(target, options);<br></code></pre></td></tr></table></figure><p> <code>target</code> 是要观察的 DOM 元素，一般为<code>document.documentElement</code>，表示监视整个页面文档的元素变化。<code>options</code> 是一个配置对象，用于指定要观察的变化类型。此处为<code>&#123;childList: true, subtree: true&#125;</code>，表示检测target以及其子节点的元素变化。如果不设置，默认只监测<code>target</code>本身，子节点的添加和减少不会被监测到。</p></li><li><p>在回调函数中处理 DOM 变化的情况。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">mutationsList, observer</span>) &#123;<br>  <span class="hljs-comment">// mutationsList 是一个 MutationRecord 对象的数组，包含了发生的 DOM 变化</span><br>  <span class="hljs-comment">// observer 是当前的 MutationObserver 对象</span><br><br>  <span class="hljs-comment">// 在这里处理 DOM 变化的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 回调函数可以接收到发生变化的元素的信息。可以通过判断改变的是哪个元素，来具体执行去除&#x2F;高亮的动作。在本项目中，为了偷懒并没有在此进行判断。</p></li></ol><h2 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h2><p>在采用<code>MutationObserver</code>之后，页面出现了无法加载的情况。通过调试器查看到，目标函数被反复调用，整个页面陷入卡死的状态。猜测是页面元素发生变动，调用了目标函数后，目标函数也改变了页面元素（但是我的代码里没有啊？），反复触发了<code>MutationObserver</code>的目标函数，形成了递归死循环。为了解决这个问题，了解了函数防抖和函数节流。</p><h2 id="函数防抖和函数节流"><a href="#函数防抖和函数节流" class="headerlink" title="函数防抖和函数节流"></a>函数防抖和函数节流</h2><p>函数防抖和函数节流都是用于限制某个函数的执行频率。如果函数调用的频率小于设定的阈值，那么是否采用函数防抖和函数节流对程序执行没有任何区别。</p><p>防抖的基本思想是在一定的时间间隔内，只执行最后一次触发事件的处理函数，忽略在此时间间隔内的其他触发事件。与函数防抖不同，函数节流是在一定的时间间隔内，定期执行事件处理函数。</p><p>函数防抖就像拍卖，拍卖成功（目标函数执行）会在敲三锤（一定间隔后）执行，一旦在敲三锤前进行了竞拍（再次调用用防抖包裹的目标函数），那么间隔会被重置。</p><p>函数节流就像大学抢浴室。一个人进了浴室（调用用节流包裹的目标函数），其他人再想进去（再次调用用节流包裹的目标函数）就不行，必须等这个人洗完（一定间隔），一旦他洗完（目标函数执行），所有人都可以再次抢浴室（调用用节流包裹的目标函数）。从某种角度，这和锁机制很像，被上锁的对象为计时器。只有获得计时器的调用才会被真正执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId; <span class="hljs-comment">// 记录定时器的ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 如果已存在定时器，则先清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timerId) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    <span class="hljs-comment">// 创建新的定时器，延迟执行 func 函数</span><br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行 func 函数</span><br>      timerId = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空定时器ID</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123; <span class="hljs-comment">// 判断当前时间与上次执行的时间间隔是否超过指定的等待时间</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>      lastTime = now; <span class="hljs-comment">// 更新上次执行的时间戳</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖和节流都能限制函数被调用的频率，区别是什么时候能再次被调用，防抖是从多次小于设定间隔的连续调用的最后一次开始计算，而节流是从第一次调用开始计算，因此相同条件下，节流可以更快地进行第二次有效调用。</p><p>总的来说，函数防抖适合在需要等待一段时间后再执行函数的场景。如果目标函数不需要等待可以立即执行，则使用节流即可。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TamperMonKey</tag>
      
      <tag>MutationObserver</tag>
      
      <tag>函数防抖</tag>
      
      <tag>函数节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
