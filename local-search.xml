<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot-ConfigurationProperties</title>
    <link href="/2023/04/07/SpringBoot-ConfigurationProperties/"/>
    <url>/2023/04/07/SpringBoot-ConfigurationProperties/</url>
    
    <content type="html"><![CDATA[<p>写代码时，常会在代码中使用配置相关的常量。</p><p>对于这些配置常量，最佳实践是配置文件分离，即将这些配置常量写入一个配置文件中。常见的配置文件包括如properties、XML文件、JSON文件、YAML文件。这样每次修改配置时，不需要改动源文件并重新编译，也不需要通过命令行传参，只需改动配置文件中对应属性即可。而且把配置信息放在一起会使代码可读性，可维护性更好。</p><h2 id="Java中的配置文件"><a href="#Java中的配置文件" class="headerlink" title="Java中的配置文件"></a>Java中的配置文件</h2><p>Java的常用配置文件为properties文件。可以通过<code>FileInputStream</code>或<code>ClassLoader</code>来读取配置文件。并通过包装成<code>Properties</code>对象，来解析文件中的属性。由于Java的配置文件通常位于类路径下，因此使用<code>ClassLoader</code>来读取有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-comment">// 使用ClassLoader获取配置文件的输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getClassLoader().getResourceAsStream(fileName);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to find &quot;</span> + fileName + <span class="hljs-string">&quot; in classpath&quot;</span>);<br>    &#125;<br>    properties.load(inputStream);<br>    inputStream.close();<br>    <span class="hljs-keyword">return</span> properties;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后需要将配置文件中的属性赋值到Java类的字段上。这种配置文件和类字段映射的思想叫做<strong>配置文件驱动开发</strong>。</p><p>但在实际开发中，一整个项目的配置信息是十分多的。如果对于每一个配置属性都显式地赋值给一个类字段，那整个赋值过程会十分繁琐。因此需要一种方式，能将配置文件自动映射到类字段上。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="ConfigurationProperties"></a>ConfigurationProperties</h2><p>谈到Java开发就离不开Spring（SpringBoot）。Spring提供了许多常见且通用的功能和工具来简化 Java 应用程序的开发，例如上文提到的配置文件的自动映射。</p><p>在Spring当中，如果需要将配置文件映射到某个类上，那么只需要在这个类上添加<code>@ConfigurationProperties</code>注解，并将这个类在Spring容器中实例化，Spring就会自动完成配置属性注入的功能。</p><p>具体实现时，通常有两种方式。</p><ol><li><p><code>@ConfigurationProperties</code> + <code>@Component</code> </p></li><li><p><code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code></p></li></ol><p>其中<code>@ConfigurationProperties</code> 加在需要配置属性注入的类上，并在注解中指定配置属性的前缀。并通过<code>@Component</code> 将类加入到容器中。需要注意的是，通过这种方式需要确保在主配置类中开启了<code>@ComponentScan</code>，并且能扫描到此类。</p><p>而Spring的默认配置文件名为<code>application.properties</code>，且位于类路径的根目录下。这是Spring的<strong>默认大于配置</strong>软件设计原则。也就是如果没特殊情况，大家都遵守这样的约定。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">abc.name</span>=Tom<br><span class="hljs-attr">abc.version</span>=V1.<span class="hljs-number">1</span><br><span class="hljs-attr">logging.level.root</span>=info<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处定义了<code>MyConfiguration</code>类，并且包含两个字段<code>name</code>，<code>version</code>，字段名与配置文件中的属性键去掉前缀对应。并通过<code>@ConfigurationProperties(prefix = &quot;abc&quot;)</code>注解指定了配置文件中的前缀，这样就可以在配置文件中通过前缀组织不同配置的属性。</p><p>或者，可以使用<code>@EnableConfigurationProperties</code>，添加在主配置类上，此时可以将属性注入的类上的<code>@Component</code>去掉，否则容器中会有两个<code>MyConfiguration</code>的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyConfig.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>@EnableConfigurationProperties</code>中指定需要开启属性注入功能的类。</p><p>但在实际过程中，出现了一些问题。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在实际学习过程中，属性注入一直失败。最后排查发现，对于属性注入的类，还需要配置Setter方法。这是因为配置属性注入，是通过Java反射，调用了对应的Setter方法。可以自行显示地定义Setter方法，或者使用<code>@Data</code>注解，自动生成类的Getter、Setter方法。</p><p>但在定义完Setter方法后，使用<code>@ConfigurationProperties</code> + <code>@Component</code>的方式配置属性注入依旧无法完成。通过对类属性打上断点，并查看调用栈，发现要使用这种方式完成配置属性注入，容器内必须要有<code>ConfigurationPropertiesBindingPostProcessor</code>。这是一个<code>BeanPostProcessor</code>，本质也是一个Bean，但和普通Bean的不同在于它可以参与Bean的实例化过程，以对其他Bean进行属性修改或功能增强。而在不使用<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>的最小配置启动下，默认没有向容器中导入这个<code>BeanPostProcessor</code>。</p><p><img src="/img/ConfigurationPropertiesBindingPostProcessor.png" alt="ConfigurationPropertiesBindingPostProcessor"></p><p>并且在调用栈中，可以观察到最后是通过反射的方式，调用Setter方法来完成了配置属性注入。</p><p><img src="/img/SetName.png" alt="SetName"></p><p>而使用<code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code> 的方式则不需要<code>@EnableAutoConfiguration</code>配置项。通过调试发现，<code>@EnableConfigurationProperties</code> 带有<code>@Import(EnableConfigurationPropertiesRegistrar.class)</code>注解，而<code>EnableConfigurationPropertiesRegistrar</code>在方法<code>registerBeanDefinitions</code>中，向容器中注册了<code>ConfigurationPropertiesBindingPostProcessor</code>，而后被实例化以提供配置属性注入的功能。</p><p>这一部分内容很涉及框架层面的内容，暂时不准备挖的更深。总之，<code>@EnableConfigurationProperties</code> 本身就会向容器内导入<code>ConfigurationPropertiesBindingPostProcessor</code>，因此不需要<code>@EnableAutoConfiguration</code>也能完成配置属性注入工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置文件分离是软件部署的最佳实践，熟悉其过程和原理也是每个程序员的必修课。在Spring框架中，使用<code>@ConfigurationProperties</code> 来完成配置文件与类的绑定，在使用时需要指定每个类对应配置文件键的前缀。并把这个类放入容器中，以被<code>ConfigurationPropertiesBindingPostProcessor</code>完成属性注入的功能。而<code>ConfigurationPropertiesBindingPostProcessor</code>可以通过<code>@EnableAutoConfiguration</code>或<code>@EnableConfigurationProperties</code>导入。<code>ConfigurationPropertiesBindingPostProcessor</code>最终是通过Java反射完成属性注入，需要调用对应的Setter方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>ConfigurationProperties</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除/高亮页面元素的JS脚本</title>
    <link href="/2023/04/06/remove-highlight-javascript/"/>
    <url>/2023/04/06/remove-highlight-javascript/</url>
    
    <content type="html"><![CDATA[<p>最近开发了一个基于TamperMonkey的JS脚本，其主要功能为去除特定页面中的广告、Header等无效信息元素，并根据逻辑高亮其中重要信息元素。</p><p><a href="https://github.com/DracoYus/lolalytics-light">Github</a></p><p>从解决需求角度出发，常见的去除页面中的广告可以通过CSS植入，并利用样式选择器将广告元素的display属性设置为none。但需要根据逻辑高亮元素（如经过元素内文本排序后，对前n位进行高亮），简单的CSS植入无法满足这个需求。因此最后采用了TamperMonkey执行JS脚本的方案，利用JS操纵DOM元素来达到去除&#x2F;高亮元素的目的。</p><p>目标页面采用了懒加载处理，可见范围外的元素不会提前加载。而TamperMonkey的内置执行时机，只能在页面开始加载或加载完成后执行一次。对于页面加载完成后，动态新加载的元素，无法完成功能。</p><table><thead><tr><th>@run-at</th><th>Timing</th></tr></thead><tbody><tr><td>document-start</td><td>as fast as possible</td></tr><tr><td>document-body</td><td>body element exists</td></tr><tr><td>document-end</td><td>when or after the DOMContentLoaded event was dispatched</td></tr><tr><td>document-idle</td><td>after the DOMContentLoaded event was dispatched</td></tr><tr><td>context-menu</td><td>it is clicked at the browser context menu</td></tr></tbody></table><p>由于页面的动态加载，需要多次执行目标函数。一种做法是，通过<code>setInterval</code>函数来指定目标函数每隔一段时间执行。这样的优点是编码简单，缺点是消耗系统资源，不太优雅。页面动态加载会导致DOM元素的增加或减少，因此更为优雅的做法是注册事件，当页面元素发生变化时，重新执行目标函数，这就用到了<code>MutationObserver</code>。</p><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p><code>MutationObserver</code>可以检测页面元素属性变化、子节点的添加或删除、文本内容的变化等。</p><p><code>MutationObserver</code> 的使用步骤如下：</p><ol><li><p>创建一个 MutationObserver 对象，传入一个回调函数作为参数，该回调函数将在 DOM 树变化时被调用。在此问题中，callback就是去除&#x2F;高亮页面元素的函数。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>observe</code> 方法开始监视 DOM 元素的变化，传入要观察的 DOM 元素以及要观察的变化类型的配置对象。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">observer.<span class="hljs-title function_">observe</span>(target, options);<br></code></pre></td></tr></table></figure><p> <code>target</code> 是要观察的 DOM 元素，一般为<code>document.documentElement</code>，表示监视整个页面文档的元素变化。<code>options</code> 是一个配置对象，用于指定要观察的变化类型。此处为<code>&#123;childList: true, subtree: true&#125;</code>，表示检测target以及其子节点的元素变化。如果不设置，默认只监测<code>target</code>本身，子节点的添加和减少不会被监测到。</p></li><li><p>在回调函数中处理 DOM 变化的情况。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">mutationsList, observer</span>) &#123;<br>  <span class="hljs-comment">// mutationsList 是一个 MutationRecord 对象的数组，包含了发生的 DOM 变化</span><br>  <span class="hljs-comment">// observer 是当前的 MutationObserver 对象</span><br><br>  <span class="hljs-comment">// 在这里处理 DOM 变化的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 回调函数可以接收到发生变化的元素的信息。可以通过判断改变的是哪个元素，来具体执行去除&#x2F;高亮的动作。在本项目中，为了偷懒并没有在此进行判断。</p></li></ol><h2 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h2><p>在采用<code>MutationObserver</code>之后，页面出现了无法加载的情况。通过调试器查看到，目标函数被反复调用，整个页面陷入卡死的状态。猜测是页面元素发生变动，调用了目标函数后，目标函数也改变了页面元素（但是我的代码里没有啊？），反复触发了<code>MutationObserver</code>的目标函数，形成了递归死循环。为了解决这个问题，了解了函数防抖和函数节流。</p><h2 id="函数防抖和函数节流"><a href="#函数防抖和函数节流" class="headerlink" title="函数防抖和函数节流"></a>函数防抖和函数节流</h2><p>函数防抖和函数节流都是用于限制某个函数的执行频率。如果函数调用的频率小于设定的阈值，那么是否采用函数防抖和函数节流对程序执行没有任何区别。</p><p>防抖的基本思想是在一定的时间间隔内，只执行最后一次触发事件的处理函数，忽略在此时间间隔内的其他触发事件。与函数防抖不同，函数节流是在一定的时间间隔内，定期执行事件处理函数。</p><p>函数防抖就像拍卖，拍卖成功（目标函数执行）会在敲三锤（一定间隔后）执行，一旦在敲三锤前进行了竞拍（再次调用用防抖包裹的目标函数），那么间隔会被重置。</p><p>函数节流就像大学抢浴室。一个人进了浴室（调用用节流包裹的目标函数），其他人再想进去（再次调用用节流包裹的目标函数）就不行，必须等这个人洗完（一定间隔），一旦他洗完（目标函数执行），所有人都可以再次抢浴室（调用用节流包裹的目标函数）。从某种角度，这和锁机制很像，被上锁的对象为计时器。只有获得计时器的调用才会被真正执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId; <span class="hljs-comment">// 记录定时器的ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 如果已存在定时器，则先清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timerId) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    <span class="hljs-comment">// 创建新的定时器，延迟执行 func 函数</span><br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行 func 函数</span><br>      timerId = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空定时器ID</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123; <span class="hljs-comment">// 判断当前时间与上次执行的时间间隔是否超过指定的等待时间</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>      lastTime = now; <span class="hljs-comment">// 更新上次执行的时间戳</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖和节流都能限制函数被调用的频率，区别是什么时候能再次被调用，防抖是从多次小于设定间隔的连续调用的最后一次开始计算，而节流是从第一次调用开始计算，因此相同条件下，节流可以更快地进行第二次有效调用。</p><p>总的来说，函数防抖适合在需要等待一段时间后再执行函数的场景。如果目标函数不需要等待可以立即执行，则使用节流即可。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TamperMonKey</tag>
      
      <tag>MutationObserver</tag>
      
      <tag>函数防抖</tag>
      
      <tag>函数节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
