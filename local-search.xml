<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git-Rebase</title>
    <link href="/2023/06/19/Git-Rebase/"/>
    <url>/2023/06/19/Git-Rebase/</url>
    
    <content type="html"><![CDATA[<p><code>Git</code>是最常用的<code>VCS</code>(<em>version control</em> system，版本控制系统)工具。在<code>Git</code>中，多人协作开发涉及到多分支，而分支管理则必然会涉及<code>新建分支</code>和<code>分支合并</code>。相对于<code>新建分支</code>，<code>分支合并</code>复杂得多，是问题的高发地段。<code>合并分支</code>通常有两种方式，<code>merge</code>和<code>rebase</code>。其中<code>merge</code>是通过新建一个特殊的提交（本文不加区分地使用提交&#x2F;节点），这个提交指向了两个节点（常规的提交只有一个父节点），这两个节点分别来自不同的分支。</p><p><img src="/img/merge.png" alt="merge"></p><p>如果合并时发生冲突，那么<code>合并提交</code>还会包含了冲突解决的信息。在<code>IDEA</code>中查看提交的文件改动，会发现相较于常规的两个窗口（一个显示提交前的版本，一个显示提交后的版本），<code>合并提交</code>的改动有三个窗口，因为提交前的版本有两个，来自不同分支。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>相对于<code>merge</code>，<code>rebase</code>就要复杂得多。一个可能的原因是<code>rebase</code>会改动提交历史，并且没有交换律。</p><p>通俗来讲，<code>rebase</code>的工作是找到两个分支的共同的祖先节点，并统计自共同的祖先节点开始的所有提交，在另一条分支上执行一次。此处借用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">《Git Pro》</a>中的图片。</p><p><img src="/img/basic-rebase-1.png" alt="初始状态"></p><p><img src="/img/basic-rebase-3.png" alt="rebase后"></p><p>图中，找到<code>experiment</code>分支的<code>C4</code>节点，和<code>master</code>分支的<code>C3</code>节点的共同祖先，也就是<code>C2</code>节点，并将自<code>C2</code>开始的所有发生在一侧的提交，在另一侧重现（图中只有一个<code>C4</code>，如果有更多都会重现）。并将<code>experiment</code>的指针指向<code>C4&#39;</code>。<strong>这里就涉及到谁<code>rebase</code>到谁上的问题</strong>。体现在图中就是到底是新的<code>C4&#39;</code>在<code>C3</code>后，还是新的<code>C3&#39;</code>在<code>C4</code>后。</p><p>在<a href="https://git-scm.com/docs/git-rebase">官方文档</a>中，<code>git rebase</code>指令可以有很多变体。例如<code>git rebase A</code>、<code>git rebase A B</code> 、<code>git rebase --onto A C B</code>。其中A、B、C表示分支的索引或提交。指定A、B、C本质就是在解决谁<code>rebase</code>到谁上的问题。</p><p>在<code>merge</code>时，合并时两个分支的地位是均等的。在<code>A</code>分支输入<code>git merge B</code>和在<code>B</code>分支输入<code>git merge A</code>，最后的结果几乎是一致的。细微的区别是合并后指向<code>合并提交</code>的分支是<code>A</code>或<code>B</code>，但在切换到另一个分支再<code>merge</code>一次后(<code>fast-forward</code>)，状态就完全一致。<code>merge</code>的这种两分支互换对合并后结果几乎没影响，我称之为<strong>交换律</strong>。</p><p>相较于<code>merge</code>，<code>rebase</code>不遵循<strong>交换律</strong>。把<code>A</code>放在<code>B</code>上和把<code>B</code>放在<code>A</code>上，这显然是两个不同的状态。由于指令的复杂，以及A、B、C互相不可交换，地位不均等，导致<code>rebase</code>比<code>merge</code>更容易犯错。</p><p>回到上面提到的三个指令<code>git rebase A</code>、<code>git rebase A B</code> 、<code>git rebase --onto A C B</code>。其中<code>A</code>表示<code>新基</code>，<code>B</code>表示被<code>rebase</code>的分支，<code>C</code>表示从<code>C</code>开始计算到<code>B</code>的改动。上述指令的含义表示：<strong>从<code>C</code>开始统计，统计到<code>B</code>分支指向的节点做的所有改动，将这些改动在<code>A</code>上重现一次，并将<code>B</code>的引用指向重现完后的状态</strong>。如果<code>B</code>省略，则<code>B</code>默认为当前所在分支。如果<code>C</code>省略，则默认为<code>A</code>和<code>B</code>的最近的祖先节点。</p><h3 id="常规实践"><a href="#常规实践" class="headerlink" title="常规实践"></a>常规实践</h3><p>在实际开发中，通常有一个共享的主分支，例如<code>master</code>分支。开发人员从<code>master</code>分支上某个节点建立新分支<code>feature</code>，并在此上开发。相对于共享的<code>master</code>分支，<code>feature</code>通常是不共享的。<code>master</code>被多人共同使用，改动会造成较大影响，因此主分支上的提交历史通常不会修改。而<code>feature</code>分支历史的修改只影响个人。因此在涉及谁<code>rebase</code>到谁上的问题时，<strong>通常会将<code>feature</code>分支<code>rebase</code>到<code>master</code>上</strong>。因为<code>rebase</code>操作会修改被<code>rebase</code>的分支的提交历史，对应上图中原本的<code>C4</code>节点将无法通过新指针找到，提交历史从<code>C2</code>-&gt;<code>C4</code>，变成了<code>C2</code>-&gt;<code>C3</code>-&gt;<code>C4&#39;</code>。</p><p>为了将<code>feature</code>分支<code>rebase</code>到<code>master</code>上，当然可以使用<code>git rebase A B</code>指令。但通常在GUI操作中，会先切换到<code>feature</code>，在进行<code>rebase</code>操作，相当于执行了<code>git rebase A</code>，把<code>B</code>和<code>C</code>都省略了。这里有一个助记的方法，做的所有操作，都是在当前所在分支进行修改。根据这个助记，就能分辨<code>签出并变基到A(Checkout and Rebase onto Current)</code>，和<code>将A变基到B(Rebase Current onto Selected)</code>这两个操作的实际行为了。</p><p><img src="/img/IDEA-rebase2.png" alt="IDEA-rebase-本地分支"></p><p>在集中式的<code>VCS</code>中，例如<code>SVN</code>，开发人员在提交代码前，需要先拉取，这个行为就像是<code>rebase</code>。因为开发是基于主分支某个历史状态，而主分支会在开发过程中产生新的提交。在开发完成后，就需要把从开发基于的节点（共同的祖先节点），到主分支的最新状态中的修改，重新包括进来。结果就好像是在最新状态进行的开发，而不是某个历史状态。如果将修改引入的过程中遇到了冲突，那还涉及冲突解决。在<code>Git</code>中使用<code>rebase</code>而不是<code>merge</code>，会产生像集中式<code>VCS</code>简单的线性历史记录，使得整个开发历史更直观。</p><h3 id="rebase的撤销"><a href="#rebase的撤销" class="headerlink" title="rebase的撤销"></a>rebase的撤销</h3><p>如果在<code>rebase</code>时发生了冲突，则会在新的提交中包含冲突解决的信息。如上图中的<code>C4</code>和<code>C3</code>发生了冲突，那么需要在新的<code>C4&#39;</code>中解决冲突。冲突解决的结果是<code>C4</code>相对于<code>C2</code>做的修改，将不同于<code>C4&#39;</code>相对于<code>C3</code>做的修改。</p><p>由于提交历史的改动，导致<code>rebase</code>的撤销要麻烦一些。<code>rebase</code>前<code>experiment</code>处于<code>C4</code>节点，<code>rebase</code>后处于<code>C4&#39;</code>节点。撤销<code>rebase</code>应该将<code>experiment</code>指针重新指向<code>C4</code>，通常可以使用<code>git reset --hard</code>指令。但此时<code>C4</code>已不被任何分支跟踪，所以在<code>IDEA</code>的分支可视化界面中，找不到指向<code>C4</code>的指针，也找不到<code>C4</code>的哈希码。此处提供两个解决方案：</p><ol><li><code>rebase</code>前，在<code>C4</code>状态建立新分支<code>backup</code></li><li>使用<code>git reflog</code>指令，查看指针的历史信息，在其中寻找<code>C4</code>的哈希码</li></ol><p>而在<code>merge</code>中，撤销就简单的多。因为<code>合并提交</code>指向被合并前的状态，可以在GUI中选取。</p><h3 id="IDEA中的rebase使用"><a href="#IDEA中的rebase使用" class="headerlink" title="IDEA中的rebase使用"></a>IDEA中的rebase使用</h3><p>在开发完后，需要将代码rebase到主分支中。此时需要位于开发的<code>feature</code>分支，在分支界面中选取<strong>远程</strong>的<code>maseter</code>分支，选<strong>本地</strong>的可能会缺少最新的提交。当然也可以<code>pull</code>一下本地的<code>maseter</code>分支，再<code>rebase</code>到其上，但这样不优雅。选取后出现菜单如下。</p><p><img src="/img/IDEA-rebase.png" alt="IDEA-rebase-远程分支"></p><p>其中有两个<code>rebase</code>相关的选项,<code>将A变基到B(Rebase Current onto Selected)</code>和<code>使用变基拉入A(Pull into Current Using Rebase)</code>。那么这两个选项有什么区别，<a href="https://www.jetbrains.com/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch-onto-another-branch">官方文档</a>。</p><blockquote><ul><li>Rebase Current onto Selected (for both remote and local branches) to rebase the branch that is currently checked out on top of the selected.</li><li>Pull into Current Using Rebase (for remote branches) to fetch changes from the selected branch and rebase the current branch on top of these changes.</li></ul></blockquote><p>仔细一看好像没有什么区别。执行每个选项后，可以在<code>Git</code>选项卡的控制台中观察到实际执行的<code>git</code>指令，这两选项唯一的区别就是后者在rebase前会执行一次fetch，确保rebase时远程分支是最新状态。因此在实际开发中更建议使用后者。</p><h3 id="与cherry-pick对比"><a href="#与cherry-pick对比" class="headerlink" title="与cherry-pick对比"></a>与cherry-pick对比</h3><p>如果使用了<code>git rebase --onto A C B</code>形式的指令，则其行为与<code>cherry-pick</code>很像。<code>cherry-pick</code>可以把某个或某些提交，在其他分支上进行重现。如果指定<code>rebase</code>指令中<code>C</code>和<code>B</code>是同一个，那行为就等同于选了一个提交的<code>cherry-pick</code>。</p><p>当然还是存在许多区别。简单的区别是<code>git rebase</code>指令中的<code>B</code>必须是<code>分支</code>，而<code>cherry-pick</code>的参数是<code>提交</code>。<code>rebase</code>会选取<code>B</code>和<code>C</code>之间连续的所有提交，而<code>cherry-pick</code>可以只选择其中一部分，且不要求连续。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合并分支常用两种方式<code>merge</code>和<code>rebase</code>。</p><p>相较于<code>merge</code>，<code>rebase</code>的优势在于不会新增<code>合并提交</code>，并且会使得整个<code>提交历史</code>更加简洁。但缺点是会修改<code>提交历史</code>导致撤销麻烦，并且指令相对merge更为复杂，不符合交换律。</p><p>想要撤销rebase恢复到之前的状态，由于修改了提交历史，需要通过<code>git reflog</code>指令找到修改前状态的哈希值，再通过<code>git reset</code>恢复。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Rebase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design-Pattern-Relationships-Between-Objects</title>
    <link href="/2023/06/12/Design-Pattern-Relationships-Between-Objects/"/>
    <url>/2023/06/12/Design-Pattern-Relationships-Between-Objects/</url>
    
    <content type="html"><![CDATA[<p>最近半个月，结合视频和书籍，把<code>设计模式</code>反反复复看了好几遍。</p><p>编写<code>设计模式</code>的笔记和分享，确实具有一定难度。首先，<code>设计模式</code>本身是抽象的，是对实践经验的总结。这意味着，对于每个<code>设计模式</code>，并没有完全确定的规范，不同的人有着不同的经验，也会有不同的实现。所以<code>设计模式</code>本质是一种思想，是不同实现中的相同部分，而思想本身很难用文字来完整表述。其次，笔记很容易变成网络上已有资料的复制。因为从头思考每个概念，琢磨其间关系，设计表达，本身事件很麻烦的事情，为了偷懒就会去复制别人的表述。最后，笔者也不一定保证自己的理解是准确的。但在刚刚学习完，一定是印象最深刻的。所以趁此机会做下记录。</p><p><code>设计模式</code>是基于<code>面向对象编程(Object-Oriented Programming, OOP)</code>的。对于面向对象的思想和四大特性在此不赘述，直接从对象之间关系开始聊起。</p><h2 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h2><p>对象&#x2F;类之间（因为大部分类最后都会实例化，因此不加区分地使用类&#x2F;对象）的关系包括：<code>实现</code>、<code>继承</code>、<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>。</p><p>值得一提的是，不同编程语言对于<code>OOP</code>的支持也不同，例如<code>Python</code>中要定义抽象类&#x2F;接口，需要继承<code>ABC抽象基类</code>，而<code>Java</code>中可以通过<code>abstract class</code>来定义抽象类，通过<code>interface</code>来定义接口；<code>Java</code>中可以定义内部类，而<code>PHP</code>则不支持内部类。对象之间的关系是脱离于语言的，本文以<code>Java</code>为例，描述对象之间的关系在<code>Java</code>中的体现。</p><h3 id="继承和实现"><a href="#继承和实现" class="headerlink" title="继承和实现"></a>继承和实现</h3><p><code>继承</code>和<code>实现</code>的特征比较明显，容易区分。</p><p><code>继承</code>通常描述两个类中，其中一个类可以复制另一个类的<code>属性/成员变量</code>和<code>方法</code>。</p><p>通常来说，<code>继承</code>是为了提高代码复用性。如果有A、B两个类，在他们的定义中，都有一些相同的属性和方法，那么可以将这部分属性和方法抽取到C类中，并将A、B类都<code>继承</code>自C，那么A、B就拥有了C中定义的属性和方法。如果修改C类，那么A、B类会相应发生变动。而A&#x2F;B中，可以在C的基础上新增<code>属性</code>和<code>方法</code>，或者<code>重写</code>C中定义的<code>方法</code>，以此来区分C和A&#x2F;B。C和A、B类的关系就是<code>继承</code>，称C为<code>父类</code>，A&#x2F;B为<code>子类</code>。</p><p><code>实现</code>通常描述一个<code>类</code>实现了另一个<code>接口</code>的所有方法的过程。当一个<code>类</code>实现了一个<code>接口</code>时，它必须提供<code>接口</code>中定义的所有方法的具体实现。<code>接口</code>通常是一个特殊的<code>类</code>，不能包含<code>属性</code>、<code>构造方法</code>，且方法只有签名声明。</p><p><code>接口</code>通常定义不同对象间交互的规范，而<code>实现</code>则是提供规范的具体实施过程。如果有两个类A、B，在他们定义中，包含同名且功能类似但不完全相同的方法，则可以将这些同名函数抽取到一个<code>接口</code>C中，且只需声明函数签名即可。为了<code>实现</code>接口C，A&#x2F;B必须提供C中声明的所有方法的具体代码。</p><p>从此处看，<code>实现</code>本身没有提供额外的功能，也没有降低代码的冗余度。但可以利用多态的动态性，降低代码的耦合度。可以将代码中对A、B类的引用，都改成对接口C的引用。接口C的引用，可以指向所有实现了接口C的一堆类。调用C中声明的方法时，会动态根据对象具体类型，调用对应的实现。通过改成对接口C的引用，使得用到A、B的地方，不仅仅局限于只能使用A&#x2F;B。有一种接口变量类型是一堆具体类的集合感觉。</p><h3 id="依赖、关联、聚合、组合"><a href="#依赖、关联、聚合、组合" class="headerlink" title="依赖、关联、聚合、组合"></a>依赖、关联、聚合、组合</h3><p><code>依赖</code>也是容易区分的。因为其他所有的关系，都必然是<code>依赖</code>关系。如果修改一个类的定义可能会造成另一个类的变化，那么这两个类之间就存在<code>依赖</code>关系。</p><p>在一个类的代码中，只要见到了另一个类的代码，通常这两个类就是依赖关系。但不包含另一个类的代码，也可能是<code>依赖</code>关系，例如对象A依赖了对象B，而对象B依赖了对象C。根据定义，修改C的代码，可能会导致B的行为变动，从而引起对象A的变化。这样看大部分类之间都包含<code>依赖</code>关系。幸运的是，对于大部分的<code>依赖关系</code>我们不需要刻意关注。</p><p><code>关联</code>可视为一种特殊类型的<code>依赖</code>，即一个对象总是拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。</p><p>在<code>Java</code>中，方法形参、局部变量是存在于栈中，方法返回后，其引用就会随着弹出而销毁。因此这种关系通常是临时的，通常使用<code>依赖</code>描述。而<code>成员变量</code>，在对象整个生命周期、不同方法中，都可以访问，关系是永久性的，因此使用<code>关联</code>描述。</p><p>在<code>关联</code>中，又可以细分为<code>聚合</code>和<code>组合</code>。在许多教材中，<code>组合</code>是一种特殊的<code>聚合</code>，即<code>聚合</code>包含<code>组合</code>。但在实际术语使用中，<code>聚合</code>通常指<code>聚合</code>中不包含<code>组合</code>的那部分，因此通俗地说两者不是包含关系，而是并列互斥的关系。</p><p><code>关联</code>描述了一个对象A，通过成员变量的形式，拥有了另一个对象B的访问权限。在此基础上，如果对象A控制着对象B的生命周期，则A与B是<code>组合</code>关系，否则则是<code>聚合</code>关系。</p><p>常见的控制生命周期的形式，便是在构造函数中对成员变量进行实例化赋值，并且不提供<code>setter</code>方法。如此对象A在实例化时，便会完成对成员变量B的实例化，并且外部无法去替换成员变量的引用。对象A销毁时，由于全局不会再有对B的引用，B也会被销毁。<code>组合</code>体现出A和B“同生共死”的关系。</p><p>如果成员变量可以被外部替换，或者两者的生命周期可以不一致时，通常就是<code>聚合</code>关系。值得一提的是，<code>Spring</code>框架中，通过<code>@Autowired</code>注解自动注入的成员变量，通常是<code>聚合</code>关系，因为其生命周期不一致，被引用对象也可以作为其他对象的成员变量，并且也可以通过某些方式替换这些成员变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象之间的关系包括<code>实现</code>、<code>继承</code>、<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>。</p><p>其中<code>实现</code>、<code>继承</code>容易区分和识别。</p><p><code>依赖</code>是最弱的关系表示，剩下五种关系都是<code>关联</code>关系。</p><p><code>关联</code>在<code>Java</code>中，通常使用成员变量来表示。他包含两种具体情况。如果两个对象同生共死，则为<code>组合关系</code>，否则则是<code>聚合</code>关系。</p>]]></content>
    
    
    <categories>
      
      <category>DesignPattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DesignPattern</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Lazy-Initialization-PartII</title>
    <link href="/2023/05/26/SpringBoot-Lazy-Initialization-PartII/"/>
    <url>/2023/05/26/SpringBoot-Lazy-Initialization-PartII/</url>
    
    <content type="html"><![CDATA[<p>在<a href="/2023/05/04/SpringBoot-Lazy-Initialization/" title="SpringBoot-Lazy-Initialization">SpringBoot-Lazy-Initialization</a>提到，懒加载可以延迟容器中单实例的创建时机，从容器启动时延迟到实例被使用时。</p><p>在实际设置懒加载时，遇到了一些问题，在此记录并分析。</p><h2 id="静态方法访问"><a href="#静态方法访问" class="headerlink" title="静态方法访问"></a>静态方法访问</h2><p>如果试图调用一个类的静态方法，而此方法依赖的静态变量需要通过实例去进行设置，启用全局懒加载就会导致<code>NPE（NullPointerException）</code>报错。</p><p>常见的场景是，编写一个<code>SpringContextUtil</code>工具类，用于从容器中根据条件（名称、类型）获取<code>bean</code>。<code>SpringContextUtil</code>通过实现<code>ApplicationContextAware</code>接口，来设置静态成员变量，并通过公共静态方法来向外暴露。一个典型的<code>SpringContextUtil</code>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringContextUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        applicationContext = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> &#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>SpringContextUtil</code>实例化时，通过<code>ApplicationContextAwareProcessor</code>后置处理器调用<code>setApplicationContext</code>方法，完成属性注入。具体的注入时机引用源代码注释。</p><blockquote><p>Invoked after population of normal bean properties but before an init callback.</p></blockquote><p>问题在于，静态方法属于类，在懒加载的情况下，调用静态方法并不会引起类实例化，也因此不会对静态成员变量<code>applicationContext</code>进行设置，其值为引用类型的默认值<code>null</code>。此时调用静态方法<code>getBean</code>就会返回<code>NPE</code>。</p><p>解决的办法也很简单，就是将<code>SpringContextUtil</code>单独设置为非懒加载。由于<code>SpringContextUtil</code>是通过<code>@Component</code>注解，被组件扫描载入容器中，一种方法便是在<code>@ComponentScan</code>中设置<code>excludeFilters</code>属性。另一种更为简单优雅的做法是直接在<code>SpringContextUtil</code>类定义上添加<code>@lazy(false)</code>的注解。根据就近原则，会覆盖掉全局设置。</p><p>实际上<code>@lazy</code>有着很灵活的用法，可以添加在很多地方，在此不过多赘述。</p><h2 id="Mybatis扫描懒加载"><a href="#Mybatis扫描懒加载" class="headerlink" title="Mybatis扫描懒加载"></a>Mybatis扫描懒加载</h2><p>开启懒加载的另一种方式是通过设置<code>@ComponentScan</code>的<code>lazyInit</code>属性，将通过组件扫描载入的<code>bean</code>设置为懒加载。这么做是合理的。对于大型项目来说，通过组件扫描载入的<code>bean</code>数量远大于其他方式，而且是些影响范围较小的<code>bean</code>(相对于框架层)。这么设置可以较大程度加快程序启动，又尽可能避免了bug延迟暴露的问题。</p><p>但如此设置后，发现项目中的<code>Mybatis Mapper</code>并不会开启懒加载。研究后发现，<code>Mapper</code>扫描和组件扫描使用的并不是同一个扫描器。</p><p>查询<code>Mybatis</code>懒加载相关资料后，发现存在歧义。在<code>MyBatis</code>中，懒加载表示按需进行关联查询，这显然与<code>SpringBoot</code>中懒加载的含义不同。因此无法通过在<code>Mybatis</code>配置文件中，开启我们需要的<code>bean</code>懒加载功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>而<code>Mapper</code>扫描使用的是<code>ClassPathMapperScanner</code>。在<code>Mybatis</code>中，可以通过<code>@MapperScan</code>的<code>lazyInitialization</code>属性，设置<code>Mapper Bean</code>的懒加载。</p><p>但公司框架中使用的是<code>通用mapper</code>，<code>maven</code>坐标如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mapper&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>由于公司使用的<code>通用mapper</code>版本较早，仍未添加懒加载功能。新增懒加载的<a href="https://github.com/abel533/Mapper/pull/874">PR</a>。</p><p>因此无法开启懒加载，只能使用全局懒加载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际开发过程中，总会遇到预料之外的情况。调试、分析、学习的过程中积累的经验，远重要于解决问题本身。经过这次问题解决，对<code>Spring</code>、<code>Mybatis</code>框架的理解又更深入了一步。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Lazy Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven-compilation</title>
    <link href="/2023/05/17/Maven-compilation/"/>
    <url>/2023/05/17/Maven-compilation/</url>
    
    <content type="html"><![CDATA[<p>由于公司<code>Java</code>项目代码量庞大，使用<code>Maven</code>作为构建工具进行编译时，往往会花费较长时间。</p><p>进行代码测试时，修改一行代码，可能会引起整个项目重新编译。这是<code>Maven</code>的默认行为，一旦检测到代码变更，便重新编译改变文件对应的模块。但其实那些没有改动的代码，复用以前的编译结果即可。为此，引入了增量编译。</p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>增量编译(Incremental Compilation)是指，只重新编译修改的代码文件。</p><p>大部分<code>Java</code>开发人员都使用<code>IDEA</code>作为<code>IDE</code>。<code>IDEA</code>自带的构建工具默认支持增量编译，<a href="https://www.jetbrains.com/help/idea/compiling-applications.html#compile_module">官方文档</a>。</p><blockquote><p>When you change any class inside the build target and then execute the build action, IntelliJ IDEA performs the incremental build that compiles only the changed classes. IntelliJ IDEA also recursively builds the classes’ dependencies.</p></blockquote><p><code>IDEA</code>还会进行依赖分析，以确定是否需要连带重新编译其他文件。</p><p>而<code>Maven</code>则默认不开启增量编译，<a href="https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#optional-parameters">官方文档</a>。</p><blockquote><p>to enable&#x2F;disable incremental compilation feature.</p><p>This leads to two different modes depending on the underlying compiler. The default javac compiler does the following:</p><ul><li>true <strong>(default)</strong> in this mode the compiler plugin determines whether any JAR files the current module depends on have changed in the current build run; or any source file was added, removed or changed since the last compilation. If this is the case, the compiler plugin recompiles all sources.</li><li>false <strong>(not recommended)</strong> this only compiles source files which are newer than their corresponding class files, namely which have changed since the last compilation. This does not recompile other classes which use the changed class, potentially leaving them with references to methods that no longer exist, leading to errors at runtime.</li></ul></blockquote><p><code>Maven</code>通过设置<code>&lt;useIncrementalcompilation&gt;</code>标签来控制增量编译行为。比较坑的地方是，选项的实际行为不符合常规理解。设置为<code>true</code>时，关闭增量编译，这是默认行为；设置为<code>false</code>时，开启增量编译。</p><p>根据官方文档，<code>Maven</code>会比较源文件(<code>.java</code>)和编译文件(<code>.class</code>)的时间戳。如果源文件的修改时间晚于编译文件，意味着上次编译后源文件发生了变动，文件需要重新编译。默认不推荐增量编译是因为<code>Maven</code>不会进行依赖检查，因此如果修改的位置删除了一个函数，而这个函数在别的源文件中被引用，会导致运行时出错。</p><h2 id="无文件变动"><a href="#无文件变动" class="headerlink" title="无文件变动"></a>无文件变动</h2><p>无论是否开启增量编译，当所有源文件都没有发生改动时，编译并不会使任何文件重新编译。</p><p>Maven会有如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Maven">[INFO] Nothing to compile - all classes are up to date<br></code></pre></td></tr></table></figure><p>但在实际使用时，可能会出现一种情况：明明无文件变动，但导致了项目重新编译。这是因为项目代码中存在空文件。</p><p>空文件是指一个<code>.java</code>文件中，没有声明<code>public class</code>，使其并不会生成对应的<code>.class</code>文件。因此在进行时间戳对比时，会提示文件修改，导致项目重新编译。Maven提示如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Maven">[INFO] Changes detected - recompiling the module!<br></code></pre></td></tr></table></figure><p>这种情况一般发生在整个文件都被注释的情况。</p><h2 id="测试编译和跳过测试"><a href="#测试编译和跳过测试" class="headerlink" title="测试编译和跳过测试"></a>测试编译和跳过测试</h2><p>在使用<code>Maven</code>进行<code>clean compile</code>后，运行单元测试，发现IDEA又将项目代码编译了一遍。由于未设置<strong>将IDE构建&#x2F;运行操作委托给Maven</strong>，重新编译使用了<code>IDEA</code>原生构建工具。</p><p>研究后发现，<code>Maven</code>的<code>compile</code>阶段并不包括测试的编译，这可以从执行<code>mvn clean compile</code>命令后，<code>target</code>文件夹中并不会有<code>test-classes</code>文件夹生成可以看出。</p><p>因此在运行时，<code>IDEA</code>没有找到单元测试的<code>.class</code>文件，会再重新编译。</p><p>因此如果要编译整个项目，包括测试，需要使用<code>clean test</code>。但<code>test</code>阶段还默认绑定了单元测试运行，会将项目测试代码中带有<code>@Test</code>的方法都执行一遍，并生成测试报告。这也是日常开发不需要的，因此需要设置跳过测试运行。</p><p>如果去百度，可以搜到两条有关测试跳过的运行参数。</p><ul><li>-DskipTests</li><li>-Dmaven.test.skip&#x3D;true</li></ul><p>这两条都可以跳过测试运行，区别是<code>-Dmaven.test.skip=true</code>还会额外跳过测试阶段，而<code>-DskipTests</code>只是跳过了测试阶段中的测试运行目标。</p><p>为了保证<code>Maven</code>编译完后可以直接运行单元测试，应该选择<code>-DskipTests</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Maven</code>是最常用的构建工具，为了开启增量编译功能，需要在<code>pom</code>文件中将<code>compile</code>插件的<code>useIncrementalcompilation</code>属性设置为false。</p><p>如果希望<code>Maven</code>编译完后可以直接运行单元测试，需要至少使用<code>test</code>而不是<code>compile</code>。如果只希望编译测试代码，但跳过测试运行，需要设置运行参数<code>-DskipTests</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Incremental Compilation</tag>
      
      <tag>Test Compilation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Commit-Message</title>
    <link href="/2023/05/12/Git-Commit-Message/"/>
    <url>/2023/05/12/Git-Commit-Message/</url>
    
    <content type="html"><![CDATA[<p><code>Git</code>在<code>commit</code>时，必须输入<code>commit message</code>，来表示对提交内容的说明。没有则无法提交。</p><p>理论上，<code>commit message</code>可以输入任意内容。但如果参与多人协作开发和持续开发，就会有相应的规范，帮助程序员快速理解别人写的提交，或者回顾自己以前提交的作用。</p><p>目前应用最为广泛的规范是前端框架<code>Angular</code>提出的<a href="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#-commit-message-format">Angular提交信息规范</a>（简称规范）。</p><h2 id="Angular-Commit-Message-Format"><a href="#Angular-Commit-Message-Format" class="headerlink" title="Angular Commit Message Format"></a>Angular Commit Message Format</h2><p>总的来说，规范要求，每次提交信息包含三部分。</p><p>1.信息头(<code>header</code>)</p><p>2.信息体(<code>body</code>)</p><p>3.信息尾(<code>footer</code>)</p><p>三个部分用空行间隔，来区分。其中<code>body</code>和<code>footer</code>为可选部分。</p><figure class="highlight plaintext"><figcaption><span>Message</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Commit">&lt;header&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>header是三个部分中最复杂的。包含三个区域<code>&lt;type&gt;</code>、<code>&lt;scope&gt;</code>和<code>&lt;short summary&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs header">&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;<br>  │       │             │<br>  │       │             └─⫸ Summary in present tense. Not capitalized. No period at the end.<br>  │       │<br>  │       └─⫸ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|<br>  │                          elements|forms|http|language-service|localize|platform-browser|<br>  │                          platform-browser-dynamic|platform-server|router|service-worker|<br>  │                          upgrade|zone.js|packaging|changelog|docs-infra|migrations|<br>  │                          devtools<br>  │<br>  └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|test<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;type&gt;</code>为必须项，所有可能的取值和意义如下。</p><blockquote><ul><li><strong>build</strong>: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)</li><li><strong>ci</strong>: Changes to our CI configuration files and scripts (examples: CircleCi, SauceLabs)</li><li><strong>docs</strong>: Documentation only changes</li><li><strong>feat</strong>: A new feature</li><li><strong>fix</strong>: A bug fix</li><li><strong>perf</strong>: A code change that improves performance</li><li><strong>refactor</strong>: A code change that neither fixes a bug nor adds a feature</li><li><strong>test</strong>: Adding missing tests or correcting existing tests</li></ul></blockquote><p>其中用的最多的应该是<code>feat</code>、<code>fix</code>和<code>test</code>。</p><p><code>&lt;scope&gt;</code>为可选项，可能的取值人为规定，一般使用项目的某个模块名或业务名，用来表示提交的修改的影响范围。</p><p><code>&lt;short summary&gt;</code>为必须项。用一句话概括此次提交。此部分的要求如下。</p><blockquote><ul><li>use the imperative, present tense: “change” not “changed” nor “changes”</li><li>don’t capitalize the first letter</li><li>no dot (.) at the end</li></ul></blockquote><p>这样子设置header的好处是，在查看<code>commit</code>历史记录时，可以选择只显示第一行内容。可以很快地理解每次提交的性质。</p><p><img src="/img/commit-log.png" alt="commit-log"></p><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>这一部分详细描述提交的内容，比如所做修改的动机，所做修改的思路，改动前后程序表现的对比。</p><p>规范相对于<code>header</code>来说很简单，仅仅是使用祈使句和现在时。</p><h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p>这一部分一般是使用Github时才会较多使用，主要用来引用提交所针对得<code>PR</code>或<code>issue</code>，另外也可以用来说明重大更改和弃用说明。</p><p>由于这一部分在公司内使用不多，大部分情况下为空即可，因此不过多介绍，详见<a href="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#commit-message-footer">官方文档</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>git commit</code>时需要输入<code>commit message</code>，目前最常用的规范是<code>AngularJS commit message format</code>。</p><p>此规范包含三部分，其中最重要的部分为<code>header</code>。<code>header</code>中需要指明修改的类型、影响的范围和简单的一句话概括。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Commit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Lazy-Initialization</title>
    <link href="/2023/05/04/SpringBoot-Lazy-Initialization/"/>
    <url>/2023/05/04/SpringBoot-Lazy-Initialization/</url>
    
    <content type="html"><![CDATA[<p>在<a href="/2023/04/13/SpringBoot-Testing/" title="SpringBoot-Testing">SpringBoot-Testing</a>提到，使用<code>Junit</code>测试<code>SpringBoot</code>项目时，需要使用<code>@SpringBootTest</code>来创建一个<code>Spring容器</code>。而当<code>@SpringBootTest</code>标注的测试类没有使用内嵌<code>@Configuration</code>注解时，会自动使用<code>@SpringBootConfiguration</code>上的配置。</p><blockquote><p>Automatically searches for a @SpringBootConfiguration when nested @Configuration is not used, and no explicit classes are specified.</p></blockquote><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a><code>@SpringBootConfiguration</code></h2><p><code>@SpringBootConfiguration</code>本身是一个合成注解，包含三个注解：</p><ol><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ol><p>其中，<code>@SpringBootConfiguration</code>本身也包含<code>@Configuration</code>，也就是可以在类中通过<code>@bean</code>注解往容器中添加<code>bean</code>。<code>@EnableAutoConfiguration</code>为自动配置功能，可以根据pom文件中的依赖，自动向容器中添加<code>bean</code>。<code>@ComponentScan</code>组件扫描在<a href="/2023/04/17/SpringBoot-Configuration/" title="SpringBoot-Configuration">SpringBoot-Configuration</a>已经阐述过。</p><p>测试往往只针对某个新写的方法，但默认的配置需要将整个应用程序环境都启动，会导致测试程序启动缓慢。一个很直观的解决方法就是使用自定义的配置类，而不是使用默认的主应用的程序环境。</p><h2 id="自定义配置类"><a href="#自定义配置类" class="headerlink" title="自定义配置类"></a>自定义配置类</h2><p>前面提到<code>@SpringBootTest</code>标注如果带有内嵌<code>@Configuration</code>注解，则不会使用<code>@SpringBootConfiguration</code>上的配置。因此如果需要使用自定义配置类，需要在测试类上添加<code>@Configuration</code>或通过<code>@SpringBootTest</code>的<code>classes</code>属性指定自定义配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>内嵌自定义配置类需要定义在测试类中，并且使用<code>static</code>关键词修饰。</p><blockquote><p>static, non-private, non-final, nested classes annotated with @Configuration</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = TestConfiguration.class)</span><br></code></pre></td></tr></table></figure><p>在自定义配置类中，可以如<a href="/2023/04/17/SpringBoot-Configuration/" title="SpringBoot-Configuration">SpringBoot-Configuration</a>中往容器中添加<code>bean</code></p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>虽然Spring可以通过<code>Auto-configured Tests</code>和<code>@ComponentScan</code>来控制自动配置和包扫描规则，来避免不必要的bean导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;SomeExcludeClass.class&#125;)&#125;)</span><br></code></pre></td></tr></table></figure><p>但有时很难分清哪些被使用到，哪些没有被使用到，因为bean之间的依赖关系错综复杂。手动去控制自动配置规则和扫描规则太过繁琐。因此更直觉、简便的解决方法是使用懒加载。<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.lazy-initialization">官方文档</a></p><blockquote><p><code>SpringApplication</code> allows an application to be initialized lazily. When lazy initialization is enabled, beans are created as they are needed rather than during application startup. As a result, enabling lazy initialization can reduce the time that it takes your application to start.</p></blockquote><p>懒加载就是在<code>bean</code>被使用时才去实例化，而不是程序一启动就把所有的<code>bean</code>都实例化。因此可以加快程序的启动时间，但会增加用户使用时的延迟。</p><p>对于生产中的设备来说，启动时间（只启动一次，往往在半夜没用户使用时）、内存消耗是可以忽略的，但用户体验至关重要。因此生产实践中通常不开启懒加载。</p><blockquote><p>Lazy initialization can be enabled programmatically using the <code>lazyInitialization</code> method on <code>SpringApplicationBuilder</code> or the <code>setLazyInitialization</code> method on <code>SpringApplication</code>. Alternatively, it can be enabled using the <code>spring.main.lazy-initialization</code> property</p></blockquote><p>由于单元测试中容器是自动创建的，<code>lazyInitialization</code>和<code>setLazyInitialization</code>的方法无法执行，因此使用<code>application.properties</code>配置文件的方式是最简单优雅的。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.main.lazy-initialization</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>如果测试类需要使用独立的配置文件，可以在测试上使用<code>@TestPropertySource</code>注解来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestPropertySource(&quot;classpath:application-test.properties&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@SpringBootTest</code>标注的测试类，默认情况会使用<code>@SpringBootConfiguration</code>的环境设置。</p><p>如果需要使用自定义配置可以使用内嵌<code>@Configuration</code>或<code>@SpringBootTest</code>的<code>classes</code>属性。</p><p>懒加载是个加速程序启动的简单且有效方法。原理是将<code>bean</code>的实例化过程推迟到使用时才实例化。避免了测试过程中大部分<code>bean</code>都用不到，但会被实例化的问题。</p><p>在单元测试中，简单且优雅的方式是通过<code>application.properties</code>配置文件来开启懒加载。为了避免影响生产，通常采用测试独立的配置文件，并通过<code>@TestPropertySource</code>来指定。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Lazy Initialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Conflict</title>
    <link href="/2023/04/27/Git-Conflict/"/>
    <url>/2023/04/27/Git-Conflict/</url>
    
    <content type="html"><![CDATA[<p>最近在工作中频繁使用到了<code>Git</code>。虽然之前基本把<a href="https://git-scm.com/book/en/v2">《Pro Git》</a>读完了，但在实际使用中还是遇到不少问题。</p><p>究其原因，这可能因为国内的<code>Git</code>教程普遍基于命令行，并且只教最基础的使用。而大部分的开发人员往往使用集成在<code>IDE</code>中的<code>Git</code>，并且对于<code>Git</code>背后的原理和设计思路并不了解。</p><p>上一篇讲到当未<code>commit</code>的修改和将要进入的分支有<code>conflict</code>时，该怎么保存这些修改。这里将进入的分支可以是<code>checkout</code>到别的分支，或者是将要<code>update</code>、<code>rebase</code>、<code>merge</code>的分支。其中<code>checkout</code>引起的矛盾只有<code>IDE</code>才会发生，原生的命令行<code>Git</code>在那种情况下根本不允许<code>checkout</code>。但未详细说明什么是<code>conflict</code>，以及什么情况下会发生。</p><p>在<code>Git</code><a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#_basic_merge_conflicts">官方文档</a>中，对于冲突只有一句简单的解释。</p><blockquote><p>If you changed the same part of the same file differently in the two branches you’re merging, Git won’t be able to merge them cleanly.</p></blockquote><p>冲突发生在修改同一个文件同一个位置。同一个文件好理解，但修改是指什么，同一个位置又指什么？由于这部分内容实在未找到详细的文档，只能通过实验测试，来验证这两个到底指的什么意思。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验设置很简单，初始化一个空的<code>Git</code>库，并在其中建立一个<code>txt</code>文本文件，通过进行不同的位置，不同类型的修改，观察是否触发<code>conflict</code>，来尝试找出其中规律。</p><p>修改的类型，主要是增加和删除两种，修改可以看作是删除和修改同时进行。</p><p>同一个位置，可以是同一光标，同一行，相邻行，或者间隔更大的行。</p><h3 id="修改类型初始化设置"><a href="#修改类型初始化设置" class="headerlink" title="修改类型初始化设置"></a>修改类型初始化设置</h3><p>基于此，新建一个<code>ConflictTest.txt</code>文本文件，并初始化为如下。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br></code></pre></td></tr></table></figure><p><code>commit</code>后，新建分支<code>branch1</code>和<code>branch2</code>。</p><h3 id="同时增删"><a href="#同时增删" class="headerlink" title="同时增删"></a>同时增删</h3><p>从直觉上讲，如果两个分支同时对一行代码进行了增加和删除，那么此时必然会发生冲突，因为两个分支上的改动是互相矛盾的，必须决定这些改动的去留。实验也证实了这一点。在实验中，一个分支将<strong>first</strong>删除，另一个分支在行末添加了<strong>.</strong>，并触发了<code>conflict</code>。结果也不会智能地合成<strong>The line.</strong>。如果在同一行地不同位置进行了增删都会触发<code>conflict</code>，那在同一光标就更无疑问地会触发了。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">The line<br>===============<br>The first line.<br></code></pre></td></tr></table></figure><p>在提到智能地合成<strong>The line.</strong>，其实默认了一种改动去留的规则，也就是将两个分支的改动都保留。而实际情况，根据对A，B分支改动的去留，共有四种情况。解决冲突的过程本质就是在决定，对于这些发生在同一位置的改动，是都留，都舍弃，还是只保留其中一侧的改动。</p><h3 id="同时删除"><a href="#同时删除" class="headerlink" title="同时删除"></a>同时删除</h3><p>同时删除不同内容会触发<code>conflict</code>，而删除相同内容不会触发<code>conflict</code>，这也很符合直观理解。因为删除相同内容后，两个文件在这个位置地内容是完全相同的，不需要考虑改动的去留。</p><h3 id="同时增加"><a href="#同时增加" class="headerlink" title="同时增加"></a>同时增加</h3><p>同时增加是有些争议的地方。添加相同内容不会触发冲突，这点原理和删除相同内容一样。但同时添加不同内容<code>Git</code>会如何处理就有些无法确定，<code>Git</code>是否会将两部分添加都保留。这种情况非常常见，例如两个人同时在代码文件最末尾添加了新的函数。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br>The second line 1<br>===============<br>The first line<br>The second line 2<br></code></pre></td></tr></table></figure><p>两个分支分别在文件末添加了不同的内容，实验结果触发了<code>conflict</code>。对于多人开发的场景，解决冲突的方式更多是将两个人的修改都保留。</p><h3 id="一侧改动，另一侧没改动"><a href="#一侧改动，另一侧没改动" class="headerlink" title="一侧改动，另一侧没改动"></a>一侧改动，另一侧没改动</h3><p>上面实验给人的感觉是，如果两个分支的文件内容不同，则发生冲突。但有一种情况两个文件不同时也会发生<code>conflict</code>。也就是当对一侧（分支）文件没有改动，另一侧没改动时。对此猜测，可能其中一侧的文件快照是另一侧的父&#x2F;祖节点时（Git底层使用树的结构存储信息），则以更新的子节点为准。</p><p>为了验证这个猜测，对没改动的一侧进行了改动并提交，随后再进行一次改动，恢复初始状态并提交。此时原来没改动的一侧因为两次<code>commit</code>，文件的状态和另一侧不再是父&#x2F;祖关系。此时合并两个分支，也没触发<code>conflict</code>。所以否定了两个文件不同时，父&#x2F;祖关系可以避免<code>conflict</code>。</p><p>并且上面的测试，提交修改一次，再提交返回修改前状态，这也和矛盾最原始的定义有矛盾。即发生了同一文件同一位置的修改，但没<code>conflict</code>。</p><p>基于上述实验，本人猜测<code>Git</code>并不是对比了两个分支的文件，而是将两个文件和他们的共同祖先状态进行了对比。通过<code>diff</code>算法，计算了每个分支所做的修改。<code>Git</code>本身带有<code>diff</code>工具，但对其内部原理没有深究。通过对比两个分支的修改，如果修改发生在同一位置，那么则触发<code>conflict</code>。并且<code>IDE</code>提供的解决冲突的界面，三路合并，其中两路是两个分支的最新状态，另外一路是两个分支的共同祖先。这变相地也证明了对比的可能是两者从相同状态后，发生的差异。由于此部分内容没有查到详细资料，可能存在一定误解。</p><h3 id="修改位置初始化"><a href="#修改位置初始化" class="headerlink" title="修改位置初始化"></a>修改位置初始化</h3><p>新建一个<code>ConflictTest.txt</code>文本文件，并初始化为如下。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line<br>The second line<br>The third line<br></code></pre></td></tr></table></figure><p><code>commit</code>后，新建分支<code>branch1</code>和<code>branch2</code>。</p><h3 id="修改位置"><a href="#修改位置" class="headerlink" title="修改位置"></a>修改位置</h3><p>修改位置的实验相对简单。对其中一侧进行第一行修改，对另一侧进行第二&#x2F;三行修改时，发生了不同结果（同一行已在之前测试）。第二行触发了<code>conflict</code>而第三行没有。如果简单点说，这样可能就把问题解决了，相同位置指的是相邻行。</p><p>但往复杂了说，怎么样定义相邻行。原本相邻的行，通过插入换行符，使得其不在相邻，再进行修改，这会引起冲突吗？</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">The first line 1<br>The second line<br>The third line<br>===============<br>The first line<br><br><br>The second line 2<br>The third line<br></code></pre></td></tr></table></figure><p>答案是会。这可能因为差异是基于原祖先文件计算。一侧变动修改了第1行，另一侧变动修改了第2行，并且1行和2和之间插入了内容（空行）。这样看改动仍然发生在相邻行。</p><p>另外还有一种情况。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">branch1<br>The first line<br>The second line<br>The third line<br>===============<br>The first line<br>branch2<br>The second line<br>The third line<br></code></pre></td></tr></table></figure><p>此时在原来第1行之前、之后插入了内容。从某种程度上也算是相邻行，但没有触发<code>conflict</code>。所以说相邻行的解释也不够完备。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Git</code>在合并不同分支时，如果两个分支的同一文件状态不一致，则会计算其与共同祖先的差异。如果差异发生在相对于祖先文件的同一行或相邻行，则会引起<code>conflict</code>。</p><p>在解决冲突时，需要针对每个位置，决定是否舍弃和保留每个分支的改动。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Conflict</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-Stash</title>
    <link href="/2023/04/19/Git-Stash/"/>
    <url>/2023/04/19/Git-Stash/</url>
    
    <content type="html"><![CDATA[<p>为了简化本地测试代码的过程，往往会对一些代码&#x2F;配置进行修改。例如设置日志级别，开启Bean的懒加载，关闭一些不必要的服务。这些修改只发生在本地<code>工作区(Working Directory)</code>，不会<code>commit</code>到<code>本地仓库(Repository)</code>，更不会<code>push</code>到<code>远程仓库(Remote repositories)</code>。由于在<code>IDEA</code>中，默认没有启用<code>暂存区(Staging Area/Index)</code>，因此主要讨论的是<code>工作区</code>和<code>仓库</code>。</p><p>当<code>工作区</code>存在一些未<code>commit</code>的修改，并需要<code>checkout</code>到别的分支，并且这个分支也对被修改的文件做了其他修改，就会导致<code>冲突(conflict)</code>发生。</p><p>如果在<code>IDEA</code>中，发生了这样的冲突，则会不允许<code>checkout</code>。检查<code>IDEA</code>中的<code>git console</code>，错误信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: Your <span class="hljs-built_in">local</span> changes to the following files would be overwritten by checkout:<br>SomeFile.txt<br>Please commit your changes or stash them before you switch branches.<br>Aborting<br></code></pre></td></tr></table></figure><p>提示也十分明确，解决方法包括<code>commit</code>和<code>stash</code>。接下来就具体说明每一种方式是怎么解决的。</p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>前面提到，这些修改本身是不想<code>commit</code>的，因为下次<code>push</code>时会默认将这个<code>commit</code>推送到远程仓库。实际情况中不会选择这种方案。</p><p>在<code>commit</code>之后，<code>工作区</code>、<code>本地仓库</code>就保持一致了，不存在未保存的信息。此时<code>checkout</code>到别的分支时没有任何报错。从别的分支再返回时，也能恢复这部分<code>工作区</code>修改。</p><p>如果需要在别的分支上也应用这部分修改，那么就需要合并分支，也就是<code>merge</code>和<code>rebase</code>。由于两个分支存在<code>冲突</code>，在合并时会需要先解决<code>冲突</code>。但这样做，在两个分支上都会有这部分修改的commit。</p><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p><code>stash</code>是一个<code>git</code>命令，通过<code>stash</code>指令，可以将未提交的<code>工作区</code>和<code>暂存区</code>中的修改保存起来，并恢复到上一次<code>commit</code>的状态，像是将工作区<code>reset --hard</code>到了<code>HEAD</code>所指的版本。但修改部分的内容并没有丢失，像是有一个隐藏的临时<code>commit</code>。由于此时<code>工作区</code>和<code>本地仓库</code>保持一致，<code>checkout</code>到别的分支不会有任何问题。</p><p>在下次<code>checkout</code>回此分支时，可以通过<code>git stash pop</code>将<code>工作区</code>还原回之前的状态。像是<code>reset</code>回了之前的隐藏临时<code>commit</code>。如果在别的分支使用<code>git stash pop</code>，那么会发生<code>冲突</code>，但不会因此产生合并的<code>commit</code>。</p><h2 id="IDEA-Shelve"><a href="#IDEA-Shelve" class="headerlink" title="IDEA Shelve"></a>IDEA Shelve</h2><p><code>IDEA</code>提供了一个功能上和<code>stash</code>几乎一样的<code>Shelve</code>。略微有些区别是stash默认操作整个<code>工作区</code>，而<code>Shelve</code>可以通过<code>GUI</code>选择单个文件或<code>Changelist</code>。<code>Changelist</code>是<code>IDEA</code>提供的将未提交修改分组的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只有在<code>工作区</code>，<code>暂存区</code>和<code>版本库</code>一致时，也就是<code>working tree clean</code>时，才能<code>checkout</code>到别的分支。我们使用的<code>IDE</code>可以自动<code>stash</code>或<code>Shelve</code>，使得这三者不一致时也能<code>checkout</code>。但如果发生<code>冲突</code>，就需要手动解决<code>冲突</code>。</p><p>对于一些便于测试的代码&#x2F;配置修改，相较于<code>commit</code>更推荐<code>stash</code>或<code>Shelve</code>。如果使用的是<code>IDEA</code>，那么更推荐<code>Shelve</code>，因为其提供了<code>GUI</code>，并且可以方便地指定暂存部分修改。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Stash</tag>
      
      <tag>Shelve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Configuration</title>
    <link href="/2023/04/17/SpringBoot-Configuration/"/>
    <url>/2023/04/17/SpringBoot-Configuration/</url>
    
    <content type="html"><![CDATA[<p>前面提到，对于<code>Spring</code>项目来说，项目的功能取决于<code>Spring容器</code>中有哪些<code>bean</code>，每一个<code>bean</code>都是一个功能模块的实例化对象。所以问题就来到了如何向<code>Spring容器</code>中添加<code>bean</code>。</p><h2 id="XML-配置文件"><a href="#XML-配置文件" class="headerlink" title="XML 配置文件"></a>XML 配置文件</h2><p><code>XML配置文件</code>是最原始的添加<code>bean</code>的方式。使用<code>XML配置文件</code>符合了<code>配置文件分离</code>的原则。可以通过修改<code>XML配置文件</code>直接修改程序的功能，而不需要将项目重新编译。</p><p>在<code>XML配置文件</code>中通过<code>&lt;bean&gt;</code>标签来声明一个<code>bean</code>，并指定其类名、属性、依赖关系等信息，将该<code>bean</code>注册到<code>Spring</code>容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;anotherBean&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此处定义了一个<code>bean</code>，为<code>com.example.MyBean</code>类的实例对象，其标识符通过<code>id</code>属性指定。通过<code>&lt;property&gt;</code>标签，可以对其成员变量进行属性注入。对于基础数据类型，可以直接使用<code>value</code>属性进行赋值；对于对象数据类型，可以使用<code>ref</code>属性进行引用，属性值为另一个容器中<code>bean</code>的<code>id</code>。也可以通过设置<code>bean</code>的<code>autowire</code>属性来指定是否采用自动注入。例如可以指定<code>autowire=&quot;byType&quot;</code>来采用类型匹配自动注入。如果容器中符合成员变量类型的<code>bean</code>只有一个，那么就可以自动赋值。</p><p>启动时，通过指定<code>XML配置文件</code>，即可启动<code>Spring容器</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;configuration.xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>在定义<code>bean</code>时，还有许多可配置属性。但作为便于理解的笔记，这部分内容此处不再深入，可以在需要的时候去查相关文档。</p><ul><li><code>id</code>：指定 bean 的唯一标识符，用于在容器中进行引用。</li><li><code>class</code>：指定 bean 的类名，用于实例化 bean 对象。</li><li><code>scope</code>：指定 bean 的作用域，包括 singleton（单例，默认值）、prototype（原型）、request（请求）、session（会话）等。</li><li><code>init-method</code>：指定 bean 初始化时调用的方法。</li><li><code>destroy-method</code>：指定 bean 销毁时调用的方法。</li><li><code>property</code>：用于设置 bean 的属性值。</li></ul><p>其中可以指定<code>bean</code>的初始化<code>init-method</code>和销毁方法<code>destroy-method</code>，这也是上篇提到的管理<code>bean</code>生命周期的功能。</p><h2 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h2><p>如果需要往容器中添加一百个<code>bean</code>，那么需要在<code>XML配置文件</code>中写一百个<code>&lt;bean&gt;</code>标签，过程十分繁琐。实际项目中，需要添加到容器中的<code>bean</code>往往是自己写的<code>Java类</code>，这些<code>Java类</code>在<code>类路径</code>上通常有特点，例如处于某个包之下。指定某个<code>类路径/包</code>下的所有<code>Java类</code>都加入到<code>Spring容器中</code>这个想法就十分自然。这种批量添加<code>bean</code>的方式叫组件扫描。</p><p><code>XML配置文件</code>中开启组件扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用注解<code>@ComponentScan</code>开启组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages=&quot;com.example&quot;)</span><br></code></pre></td></tr></table></figure><p>组件扫描需要搭配<code>@Component</code>使用，这是一个类注解。只有扫描路径下带有<code>@Component</code>注解的类才会被添加到容器，没有的类则会被忽略。组件扫描<code>@ComponentScan</code>和<code>@Component</code>组合使用可以灵活地控制路径下哪些类会被添加入容器。</p><p>除了<code>@Component</code>，还可以通过设置<code>@ComponentScan</code>的<code>includeFilters</code>和<code>excludeFilters</code>属性，来灵活地自定义扫描路径下的过滤规则。</p><h2 id="配置类-Configuration"><a href="#配置类-Configuration" class="headerlink" title="配置类@Configuration"></a>配置类@Configuration</h2><p><code>Java</code>的注解特性太过便捷，<code>Spring</code>项目逐渐从传统<code>XML配置文件</code>方式向注解方式迁移，这种大量依赖注解来配置和管理<code>Spring容器</code>中的<code>Bean</code>的方式叫<code>注解驱动</code>。</p><p>在<code>注解驱动</code>下，一个<code>XML配置文件</code>对应于一个带有<code>@Configuration</code>注解的<code>Java类</code>。<code>XML配置文件</code>中所有的标签，都有对应的定义方式。其中最重要的<code>&lt;bean&gt;</code>标签，在配置类中对应一个方法。这个方法会被添加<code>@bean</code>注解，并且要求返回一个<code>对象实例</code>或对象的<code>工厂bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回Bean的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要一提的是，配置类本身也是一个<code>bean</code>，存在于容器中。</p><p>基于单一职责原则，一般一个配置类往往只负责一类高度相关的功能。要开启某个功能往往就是把这个功能对应的配置类加入到容器中。配置类就会自动把功能相关的bean注册到容器中。</p><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p>实际项目开发中，可能会同时运用<code>XML配置文件</code>和<code>@Configuration配置类</code>。<code>配置类</code>作为主流的导入<code>bean</code>方式，那么就需要提供在其中引入<code>XML配置文件</code>的方法。<code>@ImportResource</code>就是这个作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(&quot;classpath:appCtx-dubbo.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在公司项目中，提供的对外Dubbo服务没有采用<code>配置类</code>的方式，而是将其写在了<code>XML配置文件</code>。通过在<code>XML文件</code>引入<code>xmlns:dubbo</code>，在文件内部可以使用dubbo提供的特定标签<code>&lt;dubbo:service&gt;</code>来注册服务。然后通过<code>@ImportResource(&quot;classpath:appCtx-dubbo.xml&quot;)</code>将生产者和消费者对应的<code>bean</code>加入到容器中。</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>在Java配置类上使用<code>@Import</code>注解，将其他Java配置类引入当前配置类中，从而将这些配置类中定义的<code>Bean</code>一同注册到<code>Spring容器</code>中。<code>@Import</code>也能导入非配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;AnotherConfig.class, YetAnotherConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-comment">// 引入其他配置类中的Bean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相较于<code>@bean</code>的方式，<code>@Import</code>要简单很多。由于<code>@bean</code>注解在方法之上，可以通过编程式对每个<code>bean</code>进行细粒度的配置，而<code>@Import</code>就没法进行细粒度的控制。</p><p><code>@Import</code>通常也用于注解之上，使其变得更容易理解。例如<code>@Import(AspectJAutoProxyRegistrar.class)</code>就是<code>@EnableAspectJAutoProxy</code>上的注解。开启自动代理功能，本质就是导入了<code>AspectJAutoProxyRegistrar.class</code>注册器。注册器中，通过重载了<code>registerBeanDefinitions</code>的回调方法，向容器中动态注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>，从而开了<code>AspectJ</code>代理功能。相较于<code>@Import(AspectJAutoProxyRegistrar.class)</code>，<code>@EnableAspectJAutoProxy</code>更具有语义化。实际上，大部分的<code>@Enablexxx</code>本质都是利用了<code>@Import</code>导入了一些特殊的<code>bean</code>。</p><h2 id="实现BeanFactoryPostProcessor接口"><a href="#实现BeanFactoryPostProcessor接口" class="headerlink" title="实现BeanFactoryPostProcessor接口"></a>实现BeanFactoryPostProcessor接口</h2><p>这种方式作为用户不常用。一般作为开发者设计第三方库时的选择。</p><p>通过自定义一个实现了<code>BeanFactoryPostProcessor</code>接口的类，在其<code>postProcessBeanFactory()</code>方法中使用<code>BeanDefinitionRegistry</code>接口手动注册Bean到Spring容器中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 使用BeanDefinitionRegistry接口手动注册Bean</span><br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(MyBean.class);<br>        beanFactory.registerBeanDefinition(<span class="hljs-string">&quot;myBean&quot;</span>, beanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上还有<code>ImportBeanDefinitionRegistrar </code>。由于这部分内容找到的资料不多且良莠不齐，在此不深入讨论。</p><p>总的来说，这类方式是通过实现接口中预先定义的回调函数，在<code>Spring容器</code>启动过程的早期阶段会调用这些函数。在这些函数中，可以获取到<code>Spring容器</code>，并通过<code>Spring容器</code>的注册方法向其中注册自定义<code>bean</code>。</p><p>这部分内容令人感到困惑的原因是，<code>Spring容器</code>本身有多个接口和实现类，其中有许多都提供了注册方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Spring</code>应用的功能取决于其中的<code>bean</code>。向容器中添加&#x2F;注册<code>bean</code>可以通过许多形式。其中最常用的是通过<code>@Configuration</code>的方式自定义配置类。结合<code>SpringBoot</code>的<code>AutoConfiguration</code>，可以很容易将各种应用集成到<code>Spring</code>中。由于<code>AutoConfiguration</code>内容太复杂，限于篇幅放到下一篇。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Testing</title>
    <link href="/2023/04/13/SpringBoot-Testing/"/>
    <url>/2023/04/13/SpringBoot-Testing/</url>
    
    <content type="html"><![CDATA[<p>在写上一篇<code>IoC</code>和<code>DI</code>之前，本来想记录的是<code>SpringBoot</code>如何完成<code>AutoConfiguration</code>自动配置，但因为篇幅直接分离出来了一篇。这次又把<code>Testing</code>给分离了出来。</p><p>事情的起因是，写项目代码时，常常需要对自己写的部分进行测试和调试。根据自己以往的编程经验，个人习惯于写一点就运行一点，并通过断点调试来确认内存的运行状态，避免犯一些低级的逻辑错误。虽然公司有专门的测试岗位，但从代码提交到GitLab请求合并，到部署到测试服务器，到测试人员设计用例并测试，到反馈到开发人员，整个过程涉及多个人员，太过漫长。而一些代码本身就需要反复调试，例如写了一些数据库操作，需要确认数据库实际执行结果是否符合预期。例如一个循环的跳出是否符合预期。执行结果符合预期本身是个很玄乎的事，很多时候代码看起来没啥问题，跑起来却又满脸问号。询问同事，都回答说让测试去测。而我觉得开发人员有义务确保代码没有低级的逻辑错误。</p><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>在<code>SpringBoot</code>框架中，常用的测试框架是<code>JUnit</code>。现在最新版本<code>SpringBoot3.0.5</code>对应的<code>Junit5</code>版本，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing">官方文档</a>。公司内部使用的是<code>Junit4</code>。</p><p>对于<code>JUnit</code>框架内部原理暂时没深入了解。从使用角度，常常会对需要测试的类，新生成一个对应的测试类，命名规范通常为 <code>新测试类命 = 旧类命 + &quot;Test&quot;</code>。例如有一个<code>Calculator</code>类，那会新定义一个<code>CalculatorTest</code>测试类，并在测试类中定义成员测试方法，对应于被测试类中的方法。在每个成员方法中添加注解<code>@Test</code>，通过IDE或者构建工具就可以自动执行测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Addition方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSubtraction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 编写测试代码，测试Subtraction方法是否按照预期工作</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还可以编写其他测试方法...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在测试中，可以通过构建测试用例，并使用断言，将方法输出和预期输出进行对比。还可以使用代码覆盖率工具，来分析测试覆盖率。这些是<code>JUnit</code>核心功能，其他功能暂时还未深入了解。</p><h2 id="Testing-in-SpringBoot"><a href="#Testing-in-SpringBoot" class="headerlink" title="Testing in SpringBoot"></a>Testing in SpringBoot</h2><p>在<code>SpringBoot</code>中，一个应用有什么功能，取决于在容器中有哪些<code>Bean</code>实例。例如我需要访问数据库，容器中必须要有<code>JDBC</code>相关的<code>Bean</code>，我需要处理<code>web</code>请求，容器中必须有<code>Tomcat</code>和<code>Sevlet</code>相关的<code>Bean</code>。</p><p>如果采用上文的方式去测试<code>Spring</code>项目中某个模块，那必然会报错。因为<code>JUnit</code>并不会像<code>Spring</code>一样启动，并将这些功能<code>Bean</code>添加到容器中。也就无法完成例如依赖注入等功能。</p><p>为了让<code>JUnit</code>能启动容器环境，<code>Spring</code>提供了<code>@SpringBootTest</code>注解。只需要在测试类前添加<code>@SpringBootTest</code>，就可以在测试时启动<code>Spring</code>容器。如果不指定注解的<code>classes</code>属性，也就是启动的配置类，那么会将主应用程序类，也就带有<code>@SpringBootApplication</code>注解的类作为配置类。</p><p>另外，如果使用的是<code>JUnit4</code>，还需要在测试类上额外添加<code>@RunWith(SpringRunner.class)</code>。需要这么做的原因涉及<code>JUnit</code>框架原理，在此不深究。</p><p>但问题是，使用<code>@SpringBootTest</code>注解时，会创建一个真实的<code>SpringBoot</code>上下文，并加载所有的<code>Bean</code>，这会导致测试的运行速度较慢。测试可能往往只是想测一个刚写完的某个方法，但却需要将许多不相关的<code>Bean</code>都加载进来，这会造成严重性能浪费。较长的测试启动时间也会大大降低测试时的主观感受。</p><p>要解决这个问题，就需要知道容器里的<code>Bean</code>是怎么样的方式被加载进去的，已经如何自定义加载需要的<code>Bean</code>，这也是下一篇要讨论的内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JUnit</code>是<code>Java</code>中最公认的测试框架。使用时只需要在测试类的测试方法上加<code>@Test</code>注解，即可对目标方法进行测试。在测试类中，可以使用许多功能并生成测试报告，来判断目标方法是否按照预期执行。</p><p>由于<code>JUnit</code>框架默认不会启动<code>Spring</code>容器，而<code>Spring</code>应用的功能依赖于<code>Spring</code>容器。因此直接使用<code>JUnit</code>测试<code>Spring</code>项目中的类会发生错误。可以使用<code>@SpringBootTest</code>在测试类中启动<code>Spring</code>容器环境。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-IoC-DI</title>
    <link href="/2023/04/13/SpringBoot-IoC-DI/"/>
    <url>/2023/04/13/SpringBoot-IoC-DI/</url>
    
    <content type="html"><![CDATA[<p>在讨论<code>Spring</code>框架时，其中最核心的组件莫过于 <code>Spring Core</code>。而<code>Spring Core</code>完成了两个关键概念：<code>IoC</code>（Inversion of Control，控制反转）和<code>DI</code>（Dependency Injection，依赖注入）。</p><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><code>IoC</code>是一种设计模式，它将对象的创建和管理的控制从应用程序代码转移到了容器中。在Java当中，为了提高代码的复用率和可维护性，我们采用模块化编程，将功能相关的代码抽取成一个类&#x2F;模块。在本文中，模块专指提供方法，被其他类调用的类，本身也是一个类；而模块的调用类就称为类。</p><p>如果不采用<code>IoC</code>，使用某个模块的方法时，需要通过<code>new</code>关键字创造对象，再调用其中的方法，或者通过模块类直接调用其中的静态方法。这样在代码中需要显示地创建对象。并且如果一个模块在多个类中被使用时，会被重复创建多次，造成性能浪费。如果采用单实例，则需要通过构造函数显示地将实例传递进来。这在一个模块被多个类使用，一个类会使用多个模块的情况下变得十分繁琐。</p><p>而在<code>IoC</code>模式下，所有类的实例都会由容器统一创建并管理。容器本身很像<code>HashMap</code>，可以通过类名&#x2F;类型等作为<code>key</code>，从容器中获取到<code>value</code>实例对象。当需要在某个类中使用某个模块的方法，不再需要手动创建，而是直接从容器中获取已经创建好的实例对象。这就是<code>IoC</code>创建对象实例的功能。实际上<code>IoC</code>常还被用来解决对象之间的依赖关系、处理对象的生命周期等，在此不赘述。</p><p>从描述中可以发现，每个模块的实例化时机也发生了变化。本来是在每次将被访问时，<code>new</code>一个实例；而<code>IoC</code>一般是在程序启动时就将所有模块进行实例化并放入容器。但这本身也可以通过配置项进行修改。</p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>在上文介绍中，<code>IoC</code>管理了实例的创建，并将所创实例统一用一个容器进行管理访问。那么每当需要使用某个模块时，操作变成了从容器中获取实例，再调用实例的方法。当一个类中有多个方法都使用同一个实例，这个实例会在每个方法中都需要获取一次。因为方法内定义的是局部变量，方法运行结束就会出栈。为了简化开发，可以将用到的实例都设置为成员变量，这样实例的作用域扩大到整个类，所有成员方法都能使用。额外一提，将实例设置为成员变量，只会记录实例的指针&#x2F;引用，并不会新建一个实例，因此其开销是可接受的。这种将某个实例赋值给成员变量的过程，叫依赖注入。</p><p>但问题还存在，每个成员变量的初始化该怎么操作。可以通过直接在声明时赋值、使用代码块初始化，或者通过构造函数初始化。但无论使用哪种方式，为每个成员变量显示地从容器中根据类名&#x2F;类型获取实例的代码不可避免。实际情况中，大部分实例在容器中都是单实例模式的，这意味着根据成员变量的类型，在容器中有且仅能获取到一个。</p><p>为了简化开发，<code>Spring</code>提供了<code>@Autowire</code>注解。只需要在每个实例成员变量上添加这个注解，<code>Spring</code>就会在创建对象时，自动从容器中找到每个成员变量对应的单实例并赋值。这里也引出了新的问题，如果被引用的实例还没创建该怎么办，循环引用了该怎么办。这些问题可以单独再写一篇，在此略过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>IoC</code>和<code>DI</code>，程序员的开发过程变成了：</p><ol><li>开发每个模块，并通过<code>IoC</code>将模块实例化并放到容器中。</li><li>在需要引用模块的地方，声明模块实例的成员变量，并通过<code>@Autowire</code>关键字实现<code>DI</code>。</li></ol><p>如果不使用<code>IoC</code>，那么程序员将难以知晓创建了多少实例，每个实例的状态，每个实例的生命周期。而<code>IoC</code>将创建的实例统一放在了容器当中，相当于提供了一个控制台，可以很容易的获取每个实例的信息。如果不使用<code>DI</code>，那么在每个类中调用某个模块的方法会十分繁琐。而通过<code>成员变量</code> + <code>DI</code>的模式，可以清楚地读到每个类依赖了哪些模块，并简化开发流程。</p><p>通过<code>IoC</code>和<code>DI</code>，整个过程的耦合度大大降低，基于这种模式的开发也成为了最佳实践。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-ConfigurationProperties</title>
    <link href="/2023/04/07/SpringBoot-ConfigurationProperties/"/>
    <url>/2023/04/07/SpringBoot-ConfigurationProperties/</url>
    
    <content type="html"><![CDATA[<p>写代码时，常会在代码中使用配置相关的常量。</p><p>对于这些配置常量，最佳实践是配置文件分离，即将这些配置常量写入一个配置文件中。常见的配置文件包括如properties、XML文件、JSON文件、YAML文件。这样每次修改配置时，不需要改动源文件并重新编译，也不需要通过命令行传参，只需改动配置文件中对应属性即可。而且把配置信息放在一起会使代码可读性，可维护性更好。</p><h2 id="Java中的配置文件"><a href="#Java中的配置文件" class="headerlink" title="Java中的配置文件"></a>Java中的配置文件</h2><p>Java的常用配置文件为properties文件。可以通过<code>FileInputStream</code>或<code>ClassLoader</code>来读取配置文件。并通过包装成<code>Properties</code>对象，来解析文件中的属性。由于Java的配置文件通常位于类路径下，因此使用<code>ClassLoader</code>来读取有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-comment">// 使用ClassLoader获取配置文件的输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getClassLoader().getResourceAsStream(fileName);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to find &quot;</span> + fileName + <span class="hljs-string">&quot; in classpath&quot;</span>);<br>    &#125;<br>    properties.load(inputStream);<br>    inputStream.close();<br>    <span class="hljs-keyword">return</span> properties;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后需要将配置文件中的属性赋值到Java类的字段上。这种配置文件和类字段映射的思想叫做<code>配置文件驱动开发</code>。</p><p>但在实际开发中，一整个项目的配置信息是十分多的。如果对于每一个配置属性都显式地赋值给一个类字段，那整个赋值过程会十分繁琐。因此需要一种方式，能将配置文件自动映射到类字段上。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="ConfigurationProperties"></a>ConfigurationProperties</h2><p>谈到Java开发就离不开Spring（SpringBoot）。Spring提供了许多常见且通用的功能和工具来简化 Java 应用程序的开发，例如上文提到的配置文件的自动映射。</p><p>在Spring当中，如果需要将配置文件映射到某个类上，那么只需要在这个类上添加<code>@ConfigurationProperties</code>注解，并将这个类在Spring容器中实例化，Spring就会自动完成配置属性注入的功能。</p><p>具体实现时，通常有两种方式。</p><ol><li><p><code>@ConfigurationProperties</code> + <code>@Component</code> </p></li><li><p><code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code></p></li></ol><p>其中<code>@ConfigurationProperties</code> 加在需要配置属性注入的类上，并在注解中指定配置属性的前缀。并通过<code>@Component</code> 将类加入到容器中。需要注意的是，通过这种方式需要确保在主配置类中开启了<code>@ComponentScan</code>，并且能扫描到此类。</p><p>而Spring的默认配置文件名为<code>application.properties</code>，且位于类路径的根目录下。这是Spring的<code>默认大于配置</code>软件设计原则。也就是如果没特殊情况，大家都遵守这样的约定。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">abc.name</span>=Tom<br><span class="hljs-attr">abc.version</span>=V1.<span class="hljs-number">1</span><br><span class="hljs-attr">logging.level.root</span>=info<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处定义了<code>MyConfiguration</code>类，并且包含两个字段<code>name</code>，<code>version</code>，字段名与配置文件中的属性键去掉前缀对应。并通过<code>@ConfigurationProperties(prefix = &quot;abc&quot;)</code>注解指定了配置文件中的前缀，这样就可以在配置文件中通过前缀组织不同配置的属性。</p><p>或者，可以使用<code>@EnableConfigurationProperties</code>，添加在主配置类上，此时可以将属性注入的类上的<code>@Component</code>去掉，否则容器中会有两个<code>MyConfiguration</code>的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;abc&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(MyConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(MyConfig.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>@EnableConfigurationProperties</code>中指定需要开启属性注入功能的类。</p><p>但在实际过程中，出现了一些问题。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在实际学习过程中，属性注入一直失败。最后排查发现，对于属性注入的类，还需要配置Setter方法。这是因为配置属性注入，是通过Java反射，调用了对应的Setter方法。可以自行显示地定义Setter方法，或者使用<code>@Data</code>注解，自动生成类的Getter、Setter方法。</p><p>但在定义完Setter方法后，使用<code>@ConfigurationProperties</code> + <code>@Component</code>的方式配置属性注入依旧无法完成。通过对类属性打上断点，并查看调用栈，发现要使用这种方式完成配置属性注入，容器内必须要有<code>ConfigurationPropertiesBindingPostProcessor</code>。这是一个<code>BeanPostProcessor</code>，本质也是一个Bean，但和普通Bean的不同在于它可以参与Bean的实例化过程，以对其他Bean进行属性修改或功能增强。而在不使用<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>的最小配置启动下，默认没有向容器中导入这个<code>BeanPostProcessor</code>。</p><p><img src="/img/ConfigurationPropertiesBindingPostProcessor.png" alt="ConfigurationPropertiesBindingPostProcessor"></p><p>并且在调用栈中，可以观察到最后是通过反射的方式，调用Setter方法来完成了配置属性注入。</p><p><img src="/img/SetName.png" alt="SetName"></p><p>而使用<code>@ConfigurationProperties</code> + <code>@EnableConfigurationProperties</code> 的方式则不需要<code>@EnableAutoConfiguration</code>配置项。通过调试发现，<code>@EnableConfigurationProperties</code> 带有<code>@Import(EnableConfigurationPropertiesRegistrar.class)</code>注解，而<code>EnableConfigurationPropertiesRegistrar</code>在方法<code>registerBeanDefinitions</code>中，向容器中注册了<code>ConfigurationPropertiesBindingPostProcessor</code>，而后被实例化以提供配置属性注入的功能。</p><p>这一部分内容很涉及框架层面的内容，暂时不准备挖的更深。总之，<code>@EnableConfigurationProperties</code> 本身就会向容器内导入<code>ConfigurationPropertiesBindingPostProcessor</code>，因此不需要<code>@EnableAutoConfiguration</code>也能完成配置属性注入工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置文件分离是软件部署的最佳实践，熟悉其过程和原理也是每个程序员的必修课。在Spring框架中，使用<code>@ConfigurationProperties</code> 来完成配置文件与类的绑定，在使用时需要指定每个类对应配置文件键的前缀。并把这个类放入容器中，以被<code>ConfigurationPropertiesBindingPostProcessor</code>完成属性注入的功能。而<code>ConfigurationPropertiesBindingPostProcessor</code>可以通过<code>@EnableAutoConfiguration</code>或<code>@EnableConfigurationProperties</code>导入。<code>ConfigurationPropertiesBindingPostProcessor</code>最终是通过Java反射完成属性注入，需要调用对应的Setter方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>ConfigurationProperties</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>去除/高亮页面元素的JS脚本</title>
    <link href="/2023/04/06/remove-highlight-javascript/"/>
    <url>/2023/04/06/remove-highlight-javascript/</url>
    
    <content type="html"><![CDATA[<p>最近开发了一个基于TamperMonkey的JS脚本，其主要功能为去除特定页面中的广告、Header等无效信息元素，并根据逻辑高亮其中重要信息元素。</p><p><a href="https://github.com/DracoYus/lolalytics-light">Github</a></p><p>从解决需求角度出发，常见的去除页面中的广告可以通过CSS植入，并利用样式选择器将广告元素的display属性设置为none。但需要根据逻辑高亮元素（如经过元素内文本排序后，对前n位进行高亮），简单的CSS植入无法满足这个需求。因此最后采用了TamperMonkey执行JS脚本的方案，利用JS操纵DOM元素来达到去除&#x2F;高亮元素的目的。</p><p>目标页面采用了懒加载处理，可见范围外的元素不会提前加载。而TamperMonkey的内置执行时机，只能在页面开始加载或加载完成后执行一次。对于页面加载完成后，动态新加载的元素，无法完成功能。</p><table><thead><tr><th>@run-at</th><th>Timing</th></tr></thead><tbody><tr><td>document-start</td><td>as fast as possible</td></tr><tr><td>document-body</td><td>body element exists</td></tr><tr><td>document-end</td><td>when or after the DOMContentLoaded event was dispatched</td></tr><tr><td>document-idle</td><td>after the DOMContentLoaded event was dispatched</td></tr><tr><td>context-menu</td><td>it is clicked at the browser context menu</td></tr></tbody></table><p>由于页面的动态加载，需要多次执行目标函数。一种做法是，通过<code>setInterval</code>函数来指定目标函数每隔一段时间执行。这样的优点是编码简单，缺点是消耗系统资源，不太优雅。页面动态加载会导致DOM元素的增加或减少，因此更为优雅的做法是注册事件，当页面元素发生变化时，重新执行目标函数，这就用到了<code>MutationObserver</code>。</p><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p><code>MutationObserver</code>可以检测页面元素属性变化、子节点的添加或删除、文本内容的变化等。</p><p><code>MutationObserver</code> 的使用步骤如下：</p><ol><li><p>创建一个 MutationObserver 对象，传入一个回调函数作为参数，该回调函数将在 DOM 树变化时被调用。在此问题中，callback就是去除&#x2F;高亮页面元素的函数。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>observe</code> 方法开始监视 DOM 元素的变化，传入要观察的 DOM 元素以及要观察的变化类型的配置对象。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">observer.<span class="hljs-title function_">observe</span>(target, options);<br></code></pre></td></tr></table></figure><p> <code>target</code> 是要观察的 DOM 元素，一般为<code>document.documentElement</code>，表示监视整个页面文档的元素变化。<code>options</code> 是一个配置对象，用于指定要观察的变化类型。此处为<code>&#123;childList: true, subtree: true&#125;</code>，表示检测target以及其子节点的元素变化。如果不设置，默认只监测<code>target</code>本身，子节点的添加和减少不会被监测到。</p></li><li><p>在回调函数中处理 DOM 变化的情况。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">mutationsList, observer</span>) &#123;<br>  <span class="hljs-comment">// mutationsList 是一个 MutationRecord 对象的数组，包含了发生的 DOM 变化</span><br>  <span class="hljs-comment">// observer 是当前的 MutationObserver 对象</span><br><br>  <span class="hljs-comment">// 在这里处理 DOM 变化的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 回调函数可以接收到发生变化的元素的信息。可以通过判断改变的是哪个元素，来具体执行去除&#x2F;高亮的动作。在本项目中，为了偷懒并没有在此进行判断。</p></li></ol><h2 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h2><p>在采用<code>MutationObserver</code>之后，页面出现了无法加载的情况。通过调试器查看到，目标函数被反复调用，整个页面陷入卡死的状态。猜测是页面元素发生变动，调用了目标函数后，目标函数也改变了页面元素（但是我的代码里没有啊？），反复触发了<code>MutationObserver</code>的目标函数，形成了递归死循环。为了解决这个问题，了解了函数防抖和函数节流。</p><h2 id="函数防抖和函数节流"><a href="#函数防抖和函数节流" class="headerlink" title="函数防抖和函数节流"></a>函数防抖和函数节流</h2><p>函数防抖和函数节流都是用于限制某个函数的执行频率。如果函数调用的频率小于设定的阈值，那么是否采用函数防抖和函数节流对程序执行没有任何区别。</p><p>防抖的基本思想是在一定的时间间隔内，只执行最后一次触发事件的处理函数，忽略在此时间间隔内的其他触发事件。与函数防抖不同，函数节流是在一定的时间间隔内，定期执行事件处理函数。</p><p>函数防抖就像拍卖，拍卖成功（目标函数执行）会在敲三锤（一定间隔后）执行，一旦在敲三锤前进行了竞拍（再次调用用防抖包裹的目标函数），那么间隔会被重置。</p><p>函数节流就像大学抢浴室。一个人进了浴室（调用用节流包裹的目标函数），其他人再想进去（再次调用用节流包裹的目标函数）就不行，必须等这个人洗完（一定间隔），一旦他洗完（目标函数执行），所有人都可以再次抢浴室（调用用节流包裹的目标函数）。从某种角度，这和锁机制很像，被上锁的对象为计时器。只有获得计时器的调用才会被真正执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId; <span class="hljs-comment">// 记录定时器的ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 如果已存在定时器，则先清除之前的定时器</span><br>    <span class="hljs-keyword">if</span> (timerId) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    <span class="hljs-comment">// 创建新的定时器，延迟执行 func 函数</span><br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行 func 函数</span><br>      timerId = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空定时器ID</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123; <span class="hljs-comment">// 判断当前时间与上次执行的时间间隔是否超过指定的等待时间</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行函数</span><br>      lastTime = now; <span class="hljs-comment">// 更新上次执行的时间戳</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数防抖和节流都能限制函数被调用的频率，区别是什么时候能再次被调用，防抖是从多次小于设定间隔的连续调用的最后一次开始计算，而节流是从第一次调用开始计算，因此相同条件下，节流可以更快地进行第二次有效调用。</p><p>总的来说，函数防抖适合在需要等待一段时间后再执行函数的场景。如果目标函数不需要等待可以立即执行，则使用节流即可。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TamperMonKey</tag>
      
      <tag>MutationObserver</tag>
      
      <tag>函数防抖</tag>
      
      <tag>函数节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
